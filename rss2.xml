<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ike&#39;s blog</title>
    <link>https://qiyanan.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 28 Jul 2019 10:23:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C#-LINQ</title>
      <link>https://qiyanan.com/2019/07/28/C-LINQ/</link>
      <guid>https://qiyanan.com/2019/07/28/C-LINQ/</guid>
      <pubDate>Sun, 28 Jul 2019 10:08:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;LINQ&lt;/strong&gt;&lt;br&gt;定义一个匿名类型对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = new {myTitle = &amp;quot;anonymous type&amp;quot;, myOtherParam = new int[] { 1, 2,
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>LINQ</strong><br>定义一个匿名类型对象：</p><pre><code>var obj = new {myTitle = &quot;anonymous type&quot;, myOtherParam = new int[] { 1, 2, 3, 4 } };</code></pre><p><strong>扩展函数：</strong></p><ol><li>扩展方法必须在一个非嵌套、非泛型的静态类中定义</li><li>扩展方法必须是一个静态方法</li><li>扩展方法至少要有一个参数</li><li>第一个参数必须附加this关键字作为前缀</li><li>第一个参数不能有其他修饰符（比如ref或者out）</li><li>第一个参数不能是指针类型</li></ol><p><strong>LINQ 查询操作符</strong><br>.net的设计者在类库中定义了一系列的扩展方法来方便用户操作集合对象，这些扩展方法构成了LINQ的查询操作符<br>扩展方法有Where, Max, Select, Sum, Any, Average, All, Concat等都是针对IEnumberable的对象进行扩展<br>基本LINQ查询操作</p><ol><li>获取数据源<br>在LINQ查询中，第一步是指定数据源，在LINQ查询中，先使用from子句引入数据源和范围变量</li><li>筛选<br>使用where子句生成结果，查询仅返回表达式为true的元素</li><li>中间件排序<br>orederby子句根据要排序类型的默认比较器，对返回序列中的元素排序，字符串比较顺序默认从A到Z进行排序，逆序使用orderby…descendingz子句</li><li>分组<br>group 子句用于对所获得的结果进行分组，使用group子句结束查询时，结果将以列表的形式列出，列表中的每个元素都是具有key成员的对象，列表中的元素根据该键杯分组，在循环访问生成组序列的查询时，必须使用嵌套foreach循环，外层循环访问每个组，内层循环访问每个组的成员，<br>如果必须引用某个组操作的结果，可使用into关键字创建能被进一步查询的标识符</li><li>联接<br>联接操作在不同序列间创建关联</li><li>选择(投影)<br>Select子句指定在执行查询时产生的值的类型，查询表达式必须以select子句或group子句结尾</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Customers&gt; customers = new List&lt;Customers&gt;() &#123;</span><br><span class="line">    new Customers&#123; Name = &quot;QIyanan&quot;, City = &quot;Gansu&quot;, Age = 16 &#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;IkeQi&quot;,City=&quot;USA&quot;,Age=18&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingQi&quot;,City=&quot;London&quot;,Age=20&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingZhang&quot;,City=&quot;London&quot;,Age=22&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingWang&quot;,City=&quot;London&quot;,Age=24&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingSun&quot;,City=&quot;London&quot;,Age=25&#125;&#125;;</span><br><span class="line">var result = from customer in customers</span><br><span class="line">             where customer.City == &quot;London&quot; &amp;&amp; customer.Name == &quot;kingQi&quot;</span><br><span class="line">             orderby customer.Age descending</span><br><span class="line">             select customer;</span><br><span class="line">var queryCustomersByCity = from cust in customers</span><br><span class="line">                           group cust by cust.City;</span><br><span class="line">foreach(var customerGroup in queryCustomersByCity)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(customerGroup.Key);</span><br><span class="line">    foreach(var customer in customerGroup)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;       &#123;customer.Name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foreach (var customer in result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(customer.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var studentQuery = from student in students</span><br><span class="line">                       where student.Scores[0] &gt; 90 &amp;&amp; student.Scores[3] &lt; 80</span><br><span class="line">                       orderby student.Scores[0] descending</span><br><span class="line">                       select student;</span><br><span class="line">    foreach (var student in studentQuery)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;    &#123;student.Last&#125;,     &#123;student.First&#125;,     &#123;student.Scores[0]&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery2 = from student in students</span><br><span class="line">                        group student by student.Last[0];</span><br><span class="line">    foreach (var studentGroup in studentQuery2)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(studentGroup.Key);</span><br><span class="line">        foreach (var student in studentGroup)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;        &#123;student.Last&#125;,   &#123;student.First&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery3 = from student in students</span><br><span class="line">                        group student by student.Last[0] into studentGroup</span><br><span class="line">                        orderby studentGroup.Key</span><br><span class="line">                        select studentGroup;</span><br><span class="line">    foreach (var groupOfStudents in studentQuery3)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(groupOfStudents.Key);</span><br><span class="line">        foreach (var student in groupOfStudents)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;     &#123;0&#125;,    &#123;1&#125;&quot;, student.Last, student.First);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery5 = from student in students</span><br><span class="line">                        let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3]</span><br><span class="line">                        where totalScore / 4 &lt; student.Scores[0]</span><br><span class="line">                        select student.Last + &quot;     &quot; + student.First;</span><br><span class="line">    foreach (string s in studentQuery5)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery6 = from student in students</span><br><span class="line">                        let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3]</span><br><span class="line">                        select totalScore;</span><br><span class="line">    double averageScore = studentQuery6.Average();</span><br><span class="line">    Console.WriteLine($&quot;Classaverage score = &#123;averageScore&#125;&quot;);</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery7 = from student in students</span><br><span class="line">                        where student.Last == &quot;Garcia&quot;</span><br><span class="line">                        select student.First;</span><br><span class="line">    Console.WriteLine(&quot;The garcias in the class are:&quot;);</span><br><span class="line">    foreach (string s in studentQuery7)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-LINQ/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-多线程</title>
      <link>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <pubDate>Sun, 28 Jul 2019 09:05:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;创建多线程的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写线程所要执行的方法&lt;/li&gt;
&lt;li&gt;例化Thread类，并传入一个指向线程所要执行方法的委托。（这时线程已经产生，但还没有运行）&lt;/li&gt;
&lt;li&gt;调用Thread实例的Start方法，标记该线程可以被CPU执行了，但具体
        
      
      </description>
      
      <content:encoded><![CDATA[<p>创建多线程的步骤：</p><ol><li>编写线程所要执行的方法</li><li>例化Thread类，并传入一个指向线程所要执行方法的委托。（这时线程已经产生，但还没有运行）</li><li>调用Thread实例的Start方法，标记该线程可以被CPU执行了，但具体执行时间由CPU决定</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">namespace ConsoleApp2</span><br><span class="line">&#123;</span><br><span class="line">    using System;</span><br><span class="line">    using System.Collections.Generic;</span><br><span class="line">    using System.Linq;</span><br><span class="line">    using System.Text;</span><br><span class="line">    using System.Threading;</span><br><span class="line">    using System.Threading.Tasks;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            var p1 = new ThreadTest();</span><br><span class="line">            var thread1 = new Thread(new ThreadStart(p1.Thread1)); //该代码可改写为var thread1 = new Thread(p1.Thread1);</span><br><span class="line">            var thread2 = new Thread(delegate () &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(&quot;I am created by anonymous function&quot;); &#125; &#125;);</span><br><span class="line">            var thread3 = new Thread(() =&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(&quot;i am created by Lambda expression&quot;); &#125; &#125;);</span><br><span class="line">            thread1.Start();</span><br><span class="line">            thread2.Start();</span><br><span class="line">            thread3.Start();</span><br><span class="line">            Console.ReadKey(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class ThreadTest</span><br><span class="line">    &#123;</span><br><span class="line">        public void Thread1()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;this is no parms function&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-多线程与Java-多线程异同："><a href="#C-多线程与Java-多线程异同：" class="headerlink" title="C# 多线程与Java 多线程异同："></a>C# 多线程与Java 多线程异同：</h1><p>都是通过Thread类来实现多线程，<br>都是调用start方法来开启一个线程</p><h2 id="Java实现多线程一般有三种方法："><a href="#Java实现多线程一般有三种方法：" class="headerlink" title="Java实现多线程一般有三种方法："></a>Java实现多线程一般有三种方法：</h2><ol><li>继承Thread类,实现thread类里的run()方法</li><li>实现Runnable接口，重写run()方法，并将此对象以参数的形式传给Thread对象</li><li>实现Callable接口，重写Call()方法，并将此对象传给futureTask对象内，再将FutureTask对象作为参数传入Thread对象内。</li></ol><h2 id="C-实现多线程："><a href="#C-实现多线程：" class="headerlink" title="C# 实现多线程："></a>C# 实现多线程：</h2><ol><li>通过ThreadStart委托来实现多线程</li><li>使用匿名方法来实现多线程</li><li>使用Lambda表达式实现多线程</li><li>ThreeadPool实现多线程，只要执行完毕，自动退出<br><code>ThreadPool.QueueUserWorkItem(p1.Thread1);//委托的方法必须有一个Object类型的参数</code></li><li>Task实现多线程</li></ol>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-委托</title>
      <link>https://qiyanan.com/2019/07/28/C-%E5%A7%94%E6%89%98/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E5%A7%94%E6%89%98/</guid>
      <pubDate>Sun, 28 Jul 2019 03:14:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;委托&quot;&gt;&lt;a href=&quot;#委托&quot; class=&quot;headerlink&quot; title=&quot;委托:&quot;&gt;&lt;/a&gt;委托:&lt;/h1&gt;&lt;p&gt;委托就是具有相同返回值类型和参数的方法的抽象&lt;/p&gt;
&lt;h2 id=&quot;声明委托：&quot;&gt;&lt;a href=&quot;#声明委托：&quot; class=&quot;he
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="委托"><a href="#委托" class="headerlink" title="委托:"></a>委托:</h1><p>委托就是具有相同返回值类型和参数的方法的抽象</p><h2 id="声明委托："><a href="#声明委托：" class="headerlink" title="声明委托："></a>声明委托：</h2><p><code>delegate &lt;retutrn type&gt; 委托名(参数类型)</code><br>委托是一个特殊的类，需要实例化，凡是可以声明类的地方，都可以声明委托</p><h1 id="泛型委托："><a href="#泛型委托：" class="headerlink" title="泛型委托："></a>泛型委托：</h1><h2 id="Predicate-泛型委托"><a href="#Predicate-泛型委托" class="headerlink" title="Predicate 泛型委托"></a>Predicate 泛型委托</h2><p>表示的方法需要传入一个T类型的参数，并且返回一个bool类型的返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Predicate&lt;int&gt;(Compare);</span><br><span class="line">static bool Compare(int a)</span><br><span class="line">&#123;</span><br><span class="line">    var flag = false;</span><br><span class="line">    if (a &gt; 5)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = true;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Action-泛型委托"><a href="#Action-泛型委托" class="headerlink" title="Action 泛型委托"></a>Action 泛型委托</h2><p>参数0-16个，类型不确定。不能有返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Action&lt;int,string&gt;(Compare);</span><br><span class="line">static void Compare(int a,string b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Func-泛型委托"><a href="#Func-泛型委托" class="headerlink" title="Func 泛型委托"></a>Func 泛型委托</h2><p>参数0-16个，类型不确定，必须有一个返回值，返回值为最后一个参数类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Func&lt;int,string&gt;(Compare);</span><br><span class="line">static string Compare(int a)</span><br><span class="line">&#123;</span><br><span class="line">    return &quot;test Func&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h1><p>委托对象可使用“+”运算符进行合并，只有两个相同类型的委托可被合并<br>“-”运算符可用于从合并的委托中移除组件委托<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NumberChanger nc;</span><br><span class="line">var nc1 = new NumberChanger(AddNum);</span><br><span class="line">var nc2 = new NumberChanger(MultNum);</span><br><span class="line">nc = nc1;</span><br><span class="line">nc += nc2;</span><br><span class="line">nc(5);</span><br><span class="line">Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><code>Value of Num: 75</code><br>程序执行过程：<br>初始化两个委托nc1，nc2，实现委托的合并操作，执行nc(5)时，实际先执行AddNum(),执行之后紧接着执行MultNum()，因此，结果为75.</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E5%A7%94%E6%89%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-集合</title>
      <link>https://qiyanan.com/2019/07/28/C-%E9%9B%86%E5%90%88/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E9%9B%86%E5%90%88/</guid>
      <pubDate>Sun, 28 Jul 2019 02:59:19 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;集合-Collection&quot;&gt;&lt;a href=&quot;#集合-Collection&quot; class=&quot;headerlink&quot; title=&quot;集合(Collection)&quot;&gt;&lt;/a&gt;集合(Collection)&lt;/h1&gt;&lt;p&gt;ArrayList: 动态数组，需要装箱与拆箱&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合(Collection)"></a>集合(Collection)</h1><p>ArrayList: 动态数组，需要装箱与拆箱<br>List<t>: 与ArrayList类的泛型等效，性能提高</t></p><h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><h2 id="添加元素："><a href="#添加元素：" class="headerlink" title="添加元素："></a>添加元素：</h2><p>List.Add(T item); 添加一个元素<br>List.AddRange(IEnumerable<t> Collection); 添加一组元素<br>Insert(int index, T item); 在index位置添加一个元素<br>遍历List元素; 使用foreach进行遍历</t></p><h2 id="删除元素："><a href="#删除元素：" class="headerlink" title="删除元素："></a>删除元素：</h2><p>List.Remove(T item); 删除一个值<br>List.RemoveAt(int index); 删除下标为index的元素<br>List.RemoveRange(int index , int count); 从下标index开始，删除count个元素<br>List.Contains(T item); 判断某个元素是否在该List中<br>List.Sort(); 在List里面元素排序,默认是元素第一个字母按升序<br>List.Reverse(); 给List里面元素顺序反转<br>List.Clear(); 清空List<br>List.Count(); 获取元素数目：<br>List.Find(Predicate<t>match);搜索与指定谓词所定义的条件相匹配的元素，并返回整个List中的第一个匹配元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var list = new List&lt;string&gt;();</span><br><span class="line">string[] temArr = &#123; &quot;aq&quot;, &quot;qwe&quot;, &quot;qweqwr&quot;, &quot;wqeqw&quot;, &quot;ewq&quot;, &quot;aeqw&quot;, &quot;dad&quot;, &quot;a&quot; &#125;;</span><br><span class="line">list.AddRange(temArr);</span><br><span class="line">var str = list.Find(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        if (x.Length == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">Console.WriteLine(str);</span><br></pre></td></tr></table></figure></t></p><p>List.FindLast();搜索与指定谓词所定义的条件相匹配的元素，并返回整个List中的最后一个匹配元素<br>List.TrueForAll();确定是否List中的每个元素都与指定的谓词所定义的条件相匹配<br>List.FindAll();检查与指定谓词所定义的条件相匹配的所有元素<br>List.Take(n);获得前n行 返回值为IEnumetable<t>,T的类型与List<t>的类型一样<br>List.RemoveAll();移除与指定谓词所定义的条件相匹配的所有元素，返回删除的个数<br>Dictionary&lt;[key],[value]&gt;;提供快速的基于键值的元素查找,必须对键值类型进行说明<br>创建及初始化：<br><code>var myDictonary = new Dictionary&lt;int,string&gt;();</code><br>添加一个元素：<br><code>myDictonary.Add(1, &quot;C#&quot;);</code><br>通过Key查找元素：<br><code>myDictonary[1];</code></t></t></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E9%9B%86%E5%90%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-运算符重载</title>
      <link>https://qiyanan.com/2019/07/28/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <pubDate>Sun, 28 Jul 2019 02:49:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;运算符重载：重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。&lt;br&gt;&lt;figure class=&quot;hi
        
      
      </description>
      
      <content:encoded><![CDATA[<p>运算符重载：重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">    public double Length &#123; get; set; &#125;</span><br><span class="line">    public double Width &#123; get; set; &#125;</span><br><span class="line">    public double Heigth &#123; get; set; &#125;</span><br><span class="line">    public double GetVolume()</span><br><span class="line">    &#123;</span><br><span class="line">         return this.Length * this.Width * this.Heigth;</span><br><span class="line">    &#125;</span><br><span class="line">     public static Box operator +(Box b, Box c)</span><br><span class="line">    &#123;</span><br><span class="line">        var box = new Box();</span><br><span class="line">        box.Length = b.Length + c.Length;</span><br><span class="line">        box.Width = b.Width + c.Width;</span><br><span class="line">        box.Heigth = b.Heigth + c.Heigth;</span><br><span class="line">        return box;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var box1 = new Box();</span><br><span class="line">    box1.Length = 10;</span><br><span class="line">    box1.Width = 20;</span><br><span class="line">    box1.Heigth = 30;</span><br><span class="line">    var box2 = new Box();</span><br><span class="line">    box2.Length = 30;</span><br><span class="line">    box2.Width = 40;</span><br><span class="line">    box2.Heigth = 50;</span><br><span class="line">    var box3 = box1 + box2;</span><br><span class="line">    Console.WriteLine(box1.GetVolume());</span><br><span class="line">    Console.WriteLine(box2.GetVolume());</span><br><span class="line">    Console.WriteLine(box3.GetVolume());</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-文件操作</title>
      <link>https://qiyanan.com/2019/07/28/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Sun, 28 Jul 2019 02:37:48 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;File-I-O&quot;&gt;&lt;a href=&quot;#File-I-O&quot; class=&quot;headerlink&quot; title=&quot;File I/O&quot;&gt;&lt;/a&gt;File I/O&lt;/h1&gt;&lt;h2 id=&quot;Directory-类的常用属性&quot;&gt;&lt;a href=&quot;#Directory-类的常
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="File-I-O"><a href="#File-I-O" class="headerlink" title="File I/O"></a>File I/O</h1><h2 id="Directory-类的常用属性"><a href="#Directory-类的常用属性" class="headerlink" title="Directory 类的常用属性"></a>Directory 类的常用属性</h2><p><code>public System.IO.DirectoryInfo Directory { get; }</code><br><code>DirectoryName, Exists, isReadOnly, length(当前文件的的大小), Name</code></p><h2 id="Directory-类的常用方法"><a href="#Directory-类的常用方法" class="headerlink" title="Directory 类的常用方法:"></a>Directory 类的常用方法:</h2><p><strong>CreateDirectory()</strong><br>在指定路径中创建所有目录和子目录，除非他们已经存在， 如果该目录已存在，此方法不会创建一个新目录，但它将返回DirectoryInfo现有目录的对象。<br><strong>Delete()</strong><br>从指定路径删除空目录<br><strong>Delete(String, Boolean)</strong><br>删除指定的目录，并删除该目录所有的子目录和文件<br><strong>Move()</strong><br>移动目录<br><code>public static void Move (string sourceDirName, string destDirName)</code><br><strong>GetDirectories()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static string[] GetDirectories (string path);//返回路径中子目录的完整名称的数组, 如果未找到任何目录，则为空数组</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static string[] GetDirectories (string path, string searchPattern)</span><br></pre></td></tr></table></figure><p>string path: 相对路径或者绝对路径，此字符串不区分大小写<br>string searchPattern:  与path中的子目录的名称匹配的搜索字符串，此参数可以包含有效文本个通配符的组合，不支持正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var directory = Directory.GetDirectories(@&quot;c:\&quot;);</span><br><span class="line">foreach (var d in directory)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GetFiles()</strong><br>得到当前目录下所有文件<br><code>public static string[] GetFiles (string path)</code><br><strong>Exists()</strong><br>指向现有目录，则为true，如果该目录不存在或者在尝试确定指定目录是否存在时出错，则为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var directoryPath = @&quot;c:\test&quot;;</span><br><span class="line">var filePath = @&quot;MyTest.txt&quot;;</span><br><span class="line">if (!Directory.Exists(directoryPath))//尝试确定指定目录是否存在时，则为false</span><br><span class="line">&#123;</span><br><span class="line">    Directory.CreateDirectory(directoryPath);</span><br><span class="line">&#125;</span><br><span class="line">if (!File.Exists(Path.Combine(directoryPath,filePath)))</span><br><span class="line">&#123;</span><br><span class="line">    using (StreamWriter sw = File.CreateText(Path.Combine(directoryPath, filePath)))//文件夹路径必须存在，</span><br><span class="line">    &#123;</span><br><span class="line">        sw.WriteLine(&quot;hello&quot;);</span><br><span class="line">        sw.WriteLine(&quot;and&quot;);</span><br><span class="line">        sw.WriteLine(&quot;welcome&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">using (StreamReader sr = File.OpenText(Path.Combine(directoryPath, filePath)))</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    while ((s = sr.ReadLine()) != null)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DirectoryInfo类的常用属性"><a href="#DirectoryInfo类的常用属性" class="headerlink" title="DirectoryInfo类的常用属性:"></a>DirectoryInfo类的常用属性:</h2><p>Exists; FullNam; Name; Parent; Root;</p><h2 id="DirectoryInfo类的常用方法"><a href="#DirectoryInfo类的常用方法" class="headerlink" title="DirectoryInfo类的常用方法:"></a>DirectoryInfo类的常用方法:</h2><p>初始化：<br><code>var dir = new DirectoryInfo(Path);</code><br><strong>Create()</strong><br>创建一个空目录<br><strong>Delete()</strong><br><code>public override void Delete ();//若当前目录为空则删除</code><br><code>public void Delete (bool recursive);//指定是否删除子目录和文件</code><br><strong>CreateSubdirectory()</strong><br>在指定路径的基础上创建一个或多个子目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var direcotaryInfo = new DirectoryInfo(@&quot;c:\test\test\test&quot;);</span><br><span class="line">direcotaryInfo.CreateSubdirectory(&quot;text&quot;);</span><br></pre></td></tr></table></figure></p><p><strong>GetDirectories()</strong><br><code>public System.IO.DirectoryInfo[] GetDirectories ()</code><br><strong>GetFiles()</strong><br><code>public System.IO.FileInfo[] GetFiles ()</code><br><code>public System.IO.FileInfo[] GetFiles (string searchPattern);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach (var fi in di.GetFiles(&quot;*2*&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fi.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MoveTo()</strong><br><code>public void MoveTo (string destDirName)</code></p><h2 id="File与FileInfo的区别："><a href="#File与FileInfo的区别：" class="headerlink" title="File与FileInfo的区别："></a>File与FileInfo的区别：</h2><p>File是静态类，所有方法都是静态的，可以通过类名直接调用，不需要实例化，如果对文件进行少量操作，或者对很多文件进行操作，建议使用<br>FileInfo是普通类，只有实例化对象之后才可以调用其中的方法，如果需要对一个文件进行大量操作，建议使用FileInfo</p><h2 id="File常用方法："><a href="#File常用方法：" class="headerlink" title="File常用方法："></a>File常用方法：</h2><p><strong>Create(string path)</strong><br><code>Delete(string path)// 删除文件应先判空</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (File.Exists(filePath))</span><br><span class="line">&#123;</span><br><span class="line">  File.Delete(filePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Move()</strong><br><code>public static void Move (string sourceFileName, string destFileName)</code><br><strong>Copy()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void Copy (string sourceFileName, string destFileName)//复制以后不允许覆盖同名文件</span><br></pre></td></tr></table></figure></p><p><strong>ReadAllText(string path)</strong><br><code>public static string ReadAllText(string path)//打开一个文件，读取所有的行，然后关闭文件</code><br><strong>ReadAllLines(string path)</strong><br><code>public static string[] ReadAllLines(string path)</code><br><strong>ReadLines(string path)</strong><br><code>public static IEnumerable&lt;string&gt; ReadLines(string path)</code><br><strong>ReadAllBytes(string path)</strong><br><code>public static byte[] ReadAllBytes(string path)</code></p><h2 id="FileInfo类常用属性"><a href="#FileInfo类常用属性" class="headerlink" title="FileInfo类常用属性"></a>FileInfo类常用属性</h2><p>初始化：<br><code>var fileinfo = new FileInfo(@&quot;C:\test\test\test.txt&quot;);//路径必须是文件</code></p><h2 id="FileInfo类的常用方法"><a href="#FileInfo类的常用方法" class="headerlink" title="FileInfo类的常用方法"></a>FileInfo类的常用方法</h2><p><strong>Create()</strong><br><code>public System.IO.FileStream Create ()</code><br><strong>Delete()</strong><br><code>public override void Delete ()</code><br><strong>MoveTo()</strong><br><code>public void MoveTo (string destFileName)    //将指定文件移到新位置，提供要指定新文件名的选项</code><br><strong>CopyTo()</strong><br><code>public System.IO.FileInfo CopyTo (string destFileName)//不允许覆盖源文件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public System.IO.FileInfo CopyTo (string destFileName, bool overwrite)//可以覆盖源文件</span><br></pre></td></tr></table></figure></p><p>遍历一个目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void GetAllFiles(string directoryPath)</span><br><span class="line">&#123;</span><br><span class="line">    var rootDirectory = new DirectoryInfo(directoryPath);</span><br><span class="line">    foreach (var file in rootDirectory.GetFiles())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;File Name is &#123;file.Name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var directory in rootDirectory.GetDirectories())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(directory.Name);</span><br><span class="line">        this.GetAllFiles(directory.FullName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object——&gt;MarshalByRefObject——&gt;Stream——&gt;FileStream</span><br><span class="line">Object——&gt;MarshalByRefObject——&gt;TextReader——&gt;StreramReader</span><br><span class="line">Object——&gt;MarshalByRefObject——&gt;TextWriter——&gt;StreamWriter</span><br><span class="line">Object——&gt;MarshalByRefObject——&gt;TextReader——&gt;StringReader</span><br><span class="line">Object——&gt;MarshalByRefObject——&gt;TextWriter——&gt;StringWriter</span><br></pre></td></tr></table></figure><h2 id="Strean"><a href="#Strean" class="headerlink" title="Strean"></a>Strean</h2><p>流，提供了读写的方法是以字节码的形式从流中读取内容</p><h2 id="FileStream"><a href="#FileStream" class="headerlink" title="FileStream"></a>FileStream</h2><p>处理的是字节，继承Stream，一个FileStream类的实例实际代表一个文件流，使用FileStream类可以对文件系统上的文件 进行读取，写入，打开和关闭操作<br><code>public FileStream(string path, FileMode mode, FileAccess access);</code><br><strong>path</strong>指明文件搜所在路径信息<br><strong>mode</strong>是FileMode的枚举值，表示打开或者创建的方式<br>CreateNew 创建新文件，如果文件已存在，则IOExcepption<br>Create 创建新文件，文件已存在，源文件将被覆盖<br>Open 打开文件，如果文件不存在则报FileNoFoundException<br>OpenOrCreate 打开文件，文件不存在则创建文件<br>Truncate 打开已经存在的文件，清楚文件中的内容，保留文件的创建日期，如果文件不存在，则会跑出异常<br>Append 打开先有文件并把Position设置在文档尾部，如果文件不存在将创建新文件，Append只能同FileAccess.Writer 一起使用<br><strong>access</strong> 是FileAccess的枚举值，它控制对文件的访问权限<br>Read 打开文件用于只读<br>Write 打开文件用于读写<br>ReadWrite 打开文件用于读写<br>创建文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Create, FileAccess.Write);</span><br></pre></td></tr></table></figure></p><h2 id="FileStream-类中常用属性"><a href="#FileStream-类中常用属性" class="headerlink" title="FileStream 类中常用属性"></a>FileStream 类中常用属性</h2><p><strong>bool CanRead</strong> 表示是否可以读取<br><strong>bool CanSeek</strong> 表示是否支持查找<br><strong>bool CanWrite</strong> 表示是否可以写入<br><strong>bool IsAsync</strong> 表示是异步还是同步打开<br><strong>bool Length</strong> 获取用字节表示的流长度<br><strong>string Name</strong> 获取文件的全路径<br><code>int Read(byte[] array,int offset,int count) //从流中读取字节块并将数据写入给定缓冲区中</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Open, FileAccess.Read))</span><br><span class="line">&#123;</span><br><span class="line">    var array = new byte[fileStream.Length];</span><br><span class="line">    fileStream.Read(array, 0, array.Length);</span><br><span class="line">    var c = Encoding.UTF8.GetChars(array);</span><br><span class="line">    Console.WriteLine(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>void Write(byte[] array,int offset,int count) //将字节块写入文件流</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))</span><br><span class="line">&#123;</span><br><span class="line">    var name = &quot;qiyanan&quot;;</span><br><span class="line">    var arrayWrite = Encoding.UTF8.GetBytes(name);</span><br><span class="line">    fileStream.Write(arrayWrite, 0, arrayWrite.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StreamReader"><a href="#StreamReader" class="headerlink" title="StreamReader"></a>StreamReader</h2><p>处理的是字符，从流中读取字符<br><strong>构造函数</strong>：<br><code>StreamReader(Stream) //为指定的流初始化StreamReader类的新实例</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))</span><br><span class="line">&#123;</span><br><span class="line">    using (var streanReader = new StreamReader(fileStream))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StreamReader-String"><a href="#StreamReader-String" class="headerlink" title="StreamReader(String)"></a>StreamReader(String)</h2><p>为指定的文件名初始化StreamReader类的新实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using (var streamReader=new StreamReader(@&quot;c:\test\a.txt&quot;))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StreamReader-Stream-Encoding"><a href="#StreamReader-Stream-Encoding" class="headerlink" title="StreamReader(Stream, Encoding)"></a>StreamReader(Stream, Encoding)</h2><p>默认编码是Unicode, UTF-8是其子集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))</span><br><span class="line">&#123;</span><br><span class="line">    using (var streanReader = new StreamReader(fileStream, Encoding.GetEncoding(&quot;GB2312&quot;)))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>常用方法</strong><br><strong>Read()</strong><br>单字符读入<br><code>public override int Read (); //返回值为ascll码</code><br><strong>ReadLine()</strong><br>行读入<br><code>public override string ReadLine ()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using (var streanReader = new StreamReader(@&quot;C:\test\a.txt&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    string Ichar = null;</span><br><span class="line">    while ((Ichar=streanReader.ReadLine() )!= null)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Ichar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h2><p>从字符串读取字符</p><h2 id="StreamWriter"><a href="#StreamWriter" class="headerlink" title="StreamWriter"></a>StreamWriter</h2><p><code>public override void Write(string value)//字符串写入</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using (var streamWriter=new StreamWriter(@&quot;c:\test\a.txt&quot;,true))</span><br><span class="line">&#123;</span><br><span class="line">    var str = &quot;qi yanan is good  &quot;;</span><br><span class="line">    streamWriter.Write(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>public override void Write(char value) //字符写入</code><br><code>public override void Write(char[] buffer)//字符数组写入</code><br>public virtual void WriteLine () //写入空行，等同于跳到下一行<br>`</p><h2 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h2><p>字符串写入</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream:"></a>Stream:</h2><p>BufferedStream //提供针对Stream的包装功能，使Stream支持缓存读写功能<br>MemoryStream   //提供对内存中一块数据的读写<br>FileStream     //提供基本的对文件进行二进制流读写的功能，与文件的类型无关<br>UnmanagedMemoryStream //提供从托管代码访问非托管内存块的能力</p><h2 id="文件操作注意事项："><a href="#文件操作注意事项：" class="headerlink" title="文件操作注意事项："></a>文件操作注意事项：</h2><p>不要将文件流一次性读取到内存中，这样很容易造成内存泄漏<br>一定要保证文件流被关闭，可以使用using和try…finallya两种方式<br>用流读写数据时需要注意读写的长度是否准确，避免读写空字符<br>判断StreamReader是否读写结束不可直接判断读取string是否为空<br>StreamReader和StteramWriter是对文本的操作，应注明编码格式</p><h2 id="对内存中一块数据的读写"><a href="#对内存中一块数据的读写" class="headerlink" title="对内存中一块数据的读写"></a>对内存中一块数据的读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void ShowMemoryString(string testString)</span><br><span class="line">&#123;</span><br><span class="line">    using (MemoryStream stream = new MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        if (stream.CanWrite)</span><br><span class="line">        &#123;</span><br><span class="line">            byte[] buffer = Encoding.Default.GetBytes(testString);</span><br><span class="line">            stream.Write(buffer, 0, buffer.Length);</span><br><span class="line">            byte[] resultBuffer = stream.ToArray();</span><br><span class="line">            string resultString = Encoding.UTF8.GetString(resultBuffer);</span><br><span class="line">            Console.WriteLine(resultString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileStream对文件进行字节流读写的功能，与文件的类型无关"><a href="#FileStream对文件进行字节流读写的功能，与文件的类型无关" class="headerlink" title="FileStream对文件进行字节流读写的功能，与文件的类型无关"></a>FileStream对文件进行字节流读写的功能，与文件的类型无关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void ShowFileContent(string filePath)</span><br><span class="line">&#123;</span><br><span class="line">    FileStream fileStream = File.Open(filePath, FileMode.Open);</span><br><span class="line">    byte[] fileContentBuffer = new byte[fileStream.Length];</span><br><span class="line">    fileStream.Read(fileContentBuffer, 0, fileContentBuffer.Length);</span><br><span class="line">    fileStream.Close();</span><br><span class="line">    string fileContent = Encoding.Default.GetString(fileContentBuffer);</span><br><span class="line">    Console.WriteLine(fileContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用using语法糖省略文件流关闭操作"><a href="#使用using语法糖省略文件流关闭操作" class="headerlink" title="使用using语法糖省略文件流关闭操作"></a>使用using语法糖省略文件流关闭操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void ShowFileContent(string filePath)</span><br><span class="line">&#123;</span><br><span class="line">    byte[] fileContentBuffer;</span><br><span class="line">    using(FileStream fileStream = File.Open(filePath, FileMode.OpenOrCreate))</span><br><span class="line">    &#123;</span><br><span class="line">        fileContentBuffer = new byte[fileStream.Length];</span><br><span class="line">        fileStream.Read(fileContentBuffer,0,fileContentBuffer.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    string fileContent = Encoding.Default.GetString(fileContentBuffer);</span><br><span class="line">    Console.WriteLine(fileContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分批次读入文件的内容"><a href="#分批次读入文件的内容" class="headerlink" title="分批次读入文件的内容"></a>分批次读入文件的内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void CopyFileContent(string sourceFilePath, string destinationFilePath)</span><br><span class="line">&#123;</span><br><span class="line">    using (FileStream destinationFileStream = File.Open(destinationFilePath, FileMode.Create, FileAccess.Write))</span><br><span class="line">    &#123;</span><br><span class="line">        const int bufferSize = 4 * 1024 * 1024;</span><br><span class="line">        byte[] fileContentBuffer = new byte[bufferSize];</span><br><span class="line">        using (FileStream sourceFileStream = File.Open(sourceFilePath, FileMode.Open, FileAccess.Read))</span><br><span class="line">        &#123;</span><br><span class="line">            int data;</span><br><span class="line">            do</span><br><span class="line">            &#123;</span><br><span class="line">                data = sourceFileStream.Read(fileContentBuffer, 0, fileContentBuffer.Length);</span><br><span class="line">                destinationFileStream.Write(fileContentBuffer, 0, data);</span><br><span class="line">            &#125; while (data &gt; 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileMode-定义了四种打开文件的方法："><a href="#FileMode-定义了四种打开文件的方法：" class="headerlink" title="FileMode 定义了四种打开文件的方法："></a>FileMode 定义了四种打开文件的方法：</h2><p>Append: 打开一个已有文件，并将光标放置在文件的末尾，如果文件不存在，则创建文件<br>Create: 创建一个新的文件，如果文件已存在，则删除旧文件，然后创建新文件<br>CreateNew：创建一个新文件，如果文件已存在，则抛出异常<br>Open：打开一个已有的文件，如果文件不存在，则抛出异常<br>FileAccess成员有Read, ReadWrite 和Write</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-关键字</title>
      <link>https://qiyanan.com/2019/07/28/C-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <pubDate>Sun, 28 Jul 2019 02:19:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;abstract&quot;&gt;&lt;a href=&quot;#abstract&quot; class=&quot;headerlink&quot; title=&quot;abstract&quot;&gt;&lt;/a&gt;abstract&lt;/h1&gt;&lt;p&gt;abstract修饰符可用于类，方法，属性。在类声明中使用abstract指明这个类仅用作其
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>abstract修饰符可用于类，方法，属性。在类声明中使用abstract指明这个类仅用作其他类的基类，而不用于实例化，标记为抽象的成员必须由派生自抽象类的非抽象类来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">abstract class Shape</span><br><span class="line">&#123;</span><br><span class="line">    public abstract int x &#123; get;&#125;</span><br><span class="line">    public abstract int GetArea();</span><br><span class="line">&#125;</span><br><span class="line">class Square : Shape</span><br><span class="line">&#123;</span><br><span class="line">    int side;</span><br><span class="line">    public Square(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        this.side = n;</span><br><span class="line">    public override int GetArea()</span><br><span class="line">    &#123;</span><br><span class="line">        return side * side;</span><br><span class="line">    &#125;</span><br><span class="line">    public override int x</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return x + 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interface I</span><br><span class="line">    &#123;</span><br><span class="line">        void N();</span><br><span class="line">    &#125;</span><br><span class="line">    abstract class C : I</span><br><span class="line">    &#123;</span><br><span class="line">        public abstract void N();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽象类功能："><a href="#抽象类功能：" class="headerlink" title="抽象类功能："></a>抽象类功能：</h2><ol><li>抽象类不能实例化</li><li>抽象类可能包含抽象方法和访问器</li><li>无法使用sealed修饰符来修改抽象类</li><li>派生自抽象类的非抽象类，必须包含全部已继承的抽象方法和访问器的实际实现</li></ol><h2 id="抽象方法功能："><a href="#抽象方法功能：" class="headerlink" title="抽象方法功能："></a>抽象方法功能：</h2><ol><li>抽象方法是隐式的虚拟方法</li><li>只有抽象类中才允许抽象方法声明</li><li>抽象方法没有主体，仅以 ; 结尾，签名之后没有大括号 {}</li><li>抽象方法中不能使用static或virtual关键字修饰</li></ol><h2 id="抽象属性："><a href="#抽象属性：" class="headerlink" title="抽象属性："></a>抽象属性：</h2><ol><li>静态属性上不能使用abstract修饰符</li><li>通过包含使用override修饰符的属性声明，可在派生类中写抽象继承属性</li></ol><h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><p>修饰符可将方法，lambda 表达式或匿名方法指定为异步。如果对方法或表达式使用此修饰符，则称其为异步方法</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>使用const 关键字声明某个常量字段或常量局部变量，相当于Java中的static final 组合</p><h1 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h1><p>const关键字不同。const字段只能在该字段的声明中初始化。readonly字段可以在声明或者构造函数中初始化。因此，根据所需要使用的构造函数，readonly字段可能具有不同的值。</p><h1 id="as"><a href="#as" class="headerlink" title="as"></a>as</h1><p>将结果显示转换为给定的引用或可以为null值的类型，如果无法进行转换，则as运算符返回null，与强制类型转换不同，as运算符永远不会引发异常</p><h1 id><a href="#" class="headerlink" title="()"></a>()</h1><p>强制转换运算符(T)E表达式E的结果显示的转换为T,如果转换失败，则发生编译时错误</p><h1 id="TyprOf"><a href="#TyprOf" class="headerlink" title="TyprOf()"></a>TyprOf()</h1><p>用于获取某个类型的System.Type实例，</p><h1 id="base"><a href="#base" class="headerlink" title="base"></a>base</h1><ol><li>关键字用于从子类中访问父类的成员，</li><li>调用基类上已被其他方法重写的方法，</li><li>指定创建子类实例跳跃父类构造函数</li></ol><h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><p>语句将终止其所在位置的最接近封闭循环或switch语句，控制权传递给已终止语句后面的语句</p><h1 id="checked"><a href="#checked" class="headerlink" title="checked"></a>checked</h1><p>对整型类型算术运算和转换显示启用溢出检查</p><h1 id="default-T"><a href="#default-T" class="headerlink" title="default(T)"></a>default(T)</h1><p>生成T类型的默认值：T t = default(T);</p><h1 id="event"><a href="#event" class="headerlink" title="event"></a>event</h1><p>声明发布服务器类中的事件,事件是天生的多播委托，没有赋值，只有+=以及-=操作，事件可以做到隔离保护，数据安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace ConsoleApp3</span><br><span class="line">&#123;</span><br><span class="line">    public delegate void GreetingDelegate(string name);</span><br><span class="line">    public class GreetingManager</span><br><span class="line">    &#123;</span><br><span class="line">        public  event GreetingDelegate greetingDelegate;</span><br><span class="line"></span><br><span class="line">        public void GreetPeople(string name)</span><br><span class="line">        &#123;</span><br><span class="line">            greetingDelegate(name);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        private static void EnglishGreeting(string name)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Morning , &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">        private static void ChineseGreeting(string name)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;zao shang hao ,&quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">        //public static void GreetPeople(string name, GreetingDelegate MakeGreeting)</span><br><span class="line">        //&#123;</span><br><span class="line">        //    MakeGreeting(name);</span><br><span class="line">        //&#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            GreetingManager gm = new GreetingManager();</span><br><span class="line">            gm.greetingDelegate += ChineseGreeting;</span><br><span class="line">            gm.GreetPeople(&quot;ike qi&quot;);</span><br><span class="line">            gm.greetingDelegate += EnglishGreeting;</span><br><span class="line">            //gm.greetingDelegate = EnglishGreeting;</span><br><span class="line">            //gm.greetingDelegate += ChineseGreeting;</span><br><span class="line">            gm.GreetPeople(&quot;qi ya nan &quot;);</span><br><span class="line">            //gm.GreetPeople(&quot;Ike Qi&quot;, EnglishGreeting);</span><br><span class="line">            //GreetingDelegate greetingDelegate=new GreetingDelegate(EnglishGreeting);</span><br><span class="line">            //greetingDelegate = EnglishGreeting;</span><br><span class="line">            //greetingDelegate += ChineseGreeting;</span><br><span class="line">            //greetingDelegate(&quot;qiyanan&quot;);</span><br><span class="line">            //GreetPeople(&quot;qiyanan&quot;,greetingDelegate);</span><br><span class="line">            //greetingDelegate -= ChineseGreeting;</span><br><span class="line">            //greetingDelegate(&quot;zhang hong chao &quot;);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="operator和implicit或explicit"><a href="#operator和implicit或explicit" class="headerlink" title="operator和implicit或explicit"></a>operator和implicit或explicit</h2><p>分别用于定义隐式转换或显式转换，定义转换的类型必须是该转换类型或目标类型。可用两种类型中的任何一种类型来定义两种用户定义类型之间的转换。</p><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>修饰符用于声明在外部实现的方法，还可以定义外部程序集别名，使得可以从单个程序集中引用同一组件的不同版本</p><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p>通过使用 finally 块，可以清除 try 块中分配的任何资源，即使在 try 块中发生异常，也可以运行代码。 通常情况下，finally 块的语句会在控件离开 try 语句时运行。</p><h1 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h1><p>可防止垃圾回收器重新定位可移动的变量</p><h1 id="is"><a href="#is" class="headerlink" title="is"></a>is</h1><p>运算符检查表达式的结果是否与给定类型兼容</p><p>#lock #<br>获取给定对象的互斥 lock，执行语句块，然后释放 lock。 持有 lock 时，持有 lock 的线程可以再次获取并释放 lock。 阻止任何其他线程获取 lock 并等待释放 lock。<br>当同步对共享资源的线程访问时，请锁定专用对象实例<br><code>private readonly object balanceLock=new object();</code><br>避免将以下对象用作lock对象：<br><strong>this，Type实例，字符串实例，包括字符串文本</strong></p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><ol><li>运算符创建类型的新实例，</li><li>可用作成员声明修饰符或泛型类型约束。</li><li>可以显式隐藏从基类继承的成员。 隐藏继承的成员时，该成员的派生版本将替换基类版本。 虽然可以不使用 new 修饰符来隐藏成员，但将收到编译器警告。 如果使用 new 来显式隐藏成员，将禁止此警告</li></ol><h1 id="out"><a href="#out" class="headerlink" title="out"></a>out</h1><p>作为参数修饰符，它允许按引用而不是按值向方法传递参数。接口和委托的泛型类型参数声明中，该声明指定类型参数为协变。</p><h1 id="params"><a href="#params" class="headerlink" title="params"></a>params</h1><p>关键字可以指定采用数目可变的参数的方法参数。</p><h1 id="params-1"><a href="#params-1" class="headerlink" title="params"></a>params</h1><p>关键字之后不允许有任何其他参数，并且在方法声明中只允许有一个 params 关键字。params 参数类型必须是一维数组</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p>关键字指示按引用传递的值要使用 ref 参数，方法定义和调用方法均必须显式使用 ref 关键</p><h1 id="sealed"><a href="#sealed" class="headerlink" title="sealed"></a>sealed</h1><p>修饰符可阻止其他类继承自该类</p><h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><p>用于获取非托管类型的大小</p><h1 id="可空类型-Nullable"><a href="#可空类型-Nullable" class="headerlink" title="可空类型(Nullable)"></a>可空类型(Nullable)</h1><p>C# 提供了一个特殊的数据类型，Nullable类型，表示一个数据类型可以赋值为空</p><h1 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h1><p>在数据类型后面加上 ? 可使其变成可空类型<br><code>int? x=null;</code></p><h1 id="-2"><a href="#-2" class="headerlink" title="??"></a>??</h1><p>如果 ?? 前面的操作数的结果是null，则返回 ?? 后面操作数的值，否则就是前面操作数的值</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E5%85%B3%E9%94%AE%E5%AD%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-String成员</title>
      <link>https://qiyanan.com/2019/07/28/C-String%E6%88%90%E5%91%98/</link>
      <guid>https://qiyanan.com/2019/07/28/C-String%E6%88%90%E5%91%98/</guid>
      <pubDate>Sun, 28 Jul 2019 01:05:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;String成员属性&quot;&gt;&lt;a href=&quot;#String成员属性&quot; class=&quot;headerlink&quot; title=&quot;String成员属性&quot;&gt;&lt;/a&gt;String成员属性&lt;/h2&gt;&lt;p&gt;Chars(索引器): 获取string对象特定位置的字符 //java必须
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="String成员属性"><a href="#String成员属性" class="headerlink" title="String成员属性"></a>String成员属性</h2><p>Chars(索引器): 获取string对象特定位置的字符 //java必须使用 charAt() 方法获取特定字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">   var str = &quot;1234&quot;;     </span><br><span class="line">   for(int i = 0; i &lt; str.Length; i++)</span><br><span class="line">   &#123;</span><br><span class="line"> Console.WriteLine(str[i]);</span><br><span class="line">   &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>length: 获取字符串长度 //C#属于属性，Java属于方法length（）</p><h2 id="String成员方法"><a href="#String成员方法" class="headerlink" title="String成员方法"></a>String成员方法</h2><p>Compare(string, string)：<br>比较两个指定的 String 对象，并返回一个指示二者在排序顺序中的相对位置的整数，属于静态方法<br>Format(): 格式化链接字符串<br>public static string Format (string format, object arg0);<br>Contains(): 返回一个bool，指示特定的字符是否在此字符串内<br>public bool Contains (string value);<br>StartsWith(): 确定此字符串实例的开头是否与指定的字符串匹配<br>public bool StartsWith (string value);<br>EndsWith(): 确定此字符串实例的结尾是否与特定的字符串匹配<br>public bool EndsWith (string value);<br>IndexOf(string): 字符串第一次出现的位置<br>public int IndexOf (string value);<br>LastIndexOf(String): 字符串最后一次出现的位置<br>public int LastIndexOf (string value);<br>Replace(string , string): 返回一个新的字符串，字符串调研该方法会把与字符串中第一个参数替换成第二个参数的内容<br>public string Replace (string oldValue, string newValue);<br>Split(Char[]): 分割字符串, 返回一个字符数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">var str = &quot;1;2;34&quot;;</span><br><span class="line">var a = str.Split(&apos;;&apos;);</span><br><span class="line">        foreach (var b in a)</span><br><span class="line">        &#123;</span><br><span class="line">           Console.WriteLine(b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Substring(int):  从特定位置切割字符串<br>public string Substring (int startIndex);<br>public string Substring (int startIndex, int length);从指定的字符位置开始且具有指定的长度<br>ToLower(): 转换为小写模式<br>ToUpper(): 转换为大写模式<br>Trim(): 移除字符串中的所有前导和尾部空白字符<br>OrdinalIgnoreCase(): 忽略字符串大小写进行比较</p><h2 id="StringBuilder-常用属性"><a href="#StringBuilder-常用属性" class="headerlink" title="StringBuilder 常用属性"></a>StringBuilder 常用属性</h2><p>Capacity: 获取或设置可包含在当前实例所分配的内存中的最大字符数<br>Chars[Int32]: 获取或设置此实例中指定字符位置处的字符<br>Length: 获取或设置当前 StringBuilder 对象的长度。<br>MaxCapacity: 获取此实例的最大容量。</p><h2 id="StringBuilder-常用方法"><a href="#StringBuilder-常用方法" class="headerlink" title="StringBuilder 常用方法"></a>StringBuilder 常用方法</h2><p>Append(): 追加<br>AppendFormat(“{0}，{1}”，): 格式化追加<br>Clear(): 从当前StringBuilder实例中移除所有字符<br>Equals(Object): 确定指定的对象是否等于指定的对象<br>Insert(int , String): 将字符串插入到指定字符位置<br>Remove(int , int): 将指定范围的字符串从此实例中移除<br>Replace(String , String): 将此实例中出现的所有指定字符串的替换为其他指定字符串</p><h2 id="Object类的Equals方法："><a href="#Object类的Equals方法：" class="headerlink" title="Object类的Equals方法："></a>Object类的Equals方法：</h2><p>Equals(object a, object b): 比较值是否相等<br>ReferenceEquals(object a, object b): 比较引用是否相等，对于值类型会先进行装箱,值类型会返回false<br>==: 对于值类型和string，比较值是否相等,对于引用类型，比较引用是否相等</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-String%E6%88%90%E5%91%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-编码规范</title>
      <link>https://qiyanan.com/2019/07/28/C-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
      <pubDate>Sun, 28 Jul 2019 00:37:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;格式化代码&quot;&gt;&lt;a href=&quot;#格式化代码&quot; class=&quot;headerlink&quot; title=&quot;格式化代码:&quot;&gt;&lt;/a&gt;格式化代码:&lt;/h2&gt;&lt;p&gt;Crtl K + D ( Visual Studio )&lt;br&gt;花括号 { } 尽量不要省略&lt;br&gt;缩进使用四个
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码:"></a>格式化代码:</h2><p>Crtl K + D ( Visual Studio )<br>花括号 { } 尽量不要省略<br>缩进使用四个空格, 不使用制表符 tab</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范:"></a>命名规范:</h2><p>PasCal: 所有单词首字母大写<br>Camel: 首单词首字母小写，其他单词首字母大写<br>以下是具体的命名规范<br><img src="/2019/07/28/C-编码规范/命名规范.jpg" alt="avatar"></p><h2 id="通用命名约定——单词的选择"><a href="#通用命名约定——单词的选择" class="headerlink" title="通用命名约定——单词的选择"></a>通用命名约定——单词的选择</h2><ol><li>为标识符选择易于阅读的名字</li><li>可读性</li><li>避免使用下划线，连字符</li><li>不适用匈牙利命名方式</li><li>避免使用与关键字有冲突的标识符</li><li>尽量使用CLR通用类型名，例：String, int32, int64 …<h2 id="Namespace的命名："><a href="#Namespace的命名：" class="headerlink" title="Namespace的命名："></a>Namespace的命名：</h2><company>.(<product>|<technology>)  [[<feature>[.Subnamespace]],如：AvePoint.PlatformRecovery.Backup<br>不能根据公司的组织架构来定义命名空间<h2 id="文件组织："><a href="#文件组织：" class="headerlink" title="文件组织："></a>文件组织：</h2>不要在一个源文件中包含一个以上的公用类型，<br>要用相同的名字命名文件与类<br>文件结构和命名空间的结构是一致的<h1 id="将using指令放在命名空间之内"><a href="#将using指令放在命名空间之内" class="headerlink" title="将using指令放在命名空间之内"></a>将using指令放在命名空间之内</h1><h2 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h2>代码足够清晰不用注释<br>避免块注释<br>不要把注释放在行尾，一般放在上面<br>接口第一个字母大写 I<br>基类使用 base 结尾<br>Bool 类型使用 is，can 等前缀<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理:"></a>异常处理:</h2>尽量使用系统异常<br>使用 throw 抛出异常，不使用 throw e<br>不使用异常写程序逻辑<br>不要百分百吞掉异常<h2 id="日志规范："><a href="#日志规范：" class="headerlink" title="日志规范："></a>日志规范：</h2>要在异常日志中保留完整的堆栈信息<br>不在循环体内打 log</feature></technology></product></company></li></ol>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-File类</title>
      <link>https://qiyanan.com/2019/05/21/Java-File%E7%B1%BB/</link>
      <guid>https://qiyanan.com/2019/05/21/Java-File%E7%B1%BB/</guid>
      <pubDate>Tue, 21 May 2019 11:33:14 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在Java语言里提供有对于文件操作系统操作的支持，这个支持就在java.io.File类中进行了定义，File类是唯一一个与文件本身操作（创建，删除，重命名等等）有关的类。&lt;/p&gt;
&lt;h1 id=&quot;File类的基本使用：&quot;&gt;&lt;a href=&quot;#File类的基本使用：&quot; cl
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在Java语言里提供有对于文件操作系统操作的支持，这个支持就在java.io.File类中进行了定义，File类是唯一一个与文件本身操作（创建，删除，重命名等等）有关的类。</p><h1 id="File类的基本使用："><a href="#File类的基本使用：" class="headerlink" title="File类的基本使用："></a>File类的基本使用：</h1><ol><li>File类是Comparable接口的一个子类，所以File类的对象是可以做排序处理的。</li><li>构造方法：<strong>public File(String pathname)</strong>,设置要操作的完整路径；<br>构造方法：public File(File parent, String child), 设置父路径与子目录</li><li>如果要进行文件的基本操作，可以使用如下的方法：<br>创建新的文件：public boolean creatNewFile() throws IOException<br>判断文件是否存在: <strong>public boolean exists();</strong><br>删除文件：<strong>public boolean delete();</strong></li></ol><h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><ol><li>在使用File类进行文件处理的时候需要注意的是：<br>程序——&gt; JVM ——&gt; 操作系统函数——&gt; 文件处理。</li><li>在进行文件创建的时候有一个重要的前提：文件的父路径必须首先存在。<br>获取父路径：<strong>public File getParentFile();</strong><br>创建目录：<strong>public boolean mkdirs();</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        File file = new File(&quot;D:/hello/demo/demo.txt&quot;);</span><br><span class="line">        if (!file.getParentFile().exists()) &#123;</span><br><span class="line">            file.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        if (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(file.createNewFile());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/05/21/Java-File%E7%B1%BB/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
