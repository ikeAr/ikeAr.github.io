<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ike&#39;s blog</title>
    <link>https://qiyanan.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 06 Aug 2019 08:23:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C#-浅度复制与深度复制</title>
      <link>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/</guid>
      <pubDate>Tue, 06 Aug 2019 08:14:26 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;浅度复制和深度复制&quot;&gt;&lt;a href=&quot;#浅度复制和深度复制&quot; class=&quot;headerlink&quot; title=&quot;浅度复制和深度复制&quot;&gt;&lt;/a&gt;浅度复制和深度复制&lt;/h1&gt;&lt;h2 id=&quot;浅度复制&quot;&gt;&lt;a href=&quot;#浅度复制&quot; class=&quot;headerli
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="浅度复制和深度复制"><a href="#浅度复制和深度复制" class="headerlink" title="浅度复制和深度复制"></a>浅度复制和深度复制</h1><h2 id="浅度复制"><a href="#浅度复制" class="headerlink" title="浅度复制"></a>浅度复制</h2><p>浅度复制指按照引用复制对象<br>简单的按照成员复制对象可以通过派生于System. Object的MemberwiseClone()方法来完成，这是一个受保护的方法，这个方法提供的复制功能称为浅度复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Content </span><br><span class="line">&#123;</span><br><span class="line">    public int val;</span><br><span class="line">&#125;</span><br><span class="line">public class Cloner </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public Cloner(int newVal) =&gt; MyContent.val = newVal;</span><br><span class="line">    public object GetCopy() =&gt; MemberwiseClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cloner mySource = new Cloner(5);</span><br><span class="line">Cloner myTarget = (Cloner) mySource.GetCopy();</span><br><span class="line">Console.WriteLine($ &quot;myTarget.MyContent.Val=&#123;myTarget.MyContent.val&#125;&quot;);</span><br><span class="line">mySource.MyContent.val = 2;</span><br><span class="line">Console.WriteLine($ &quot;myTarget.MyContent.Val=&#123;myTarget.MyContent.val&#125;&quot;);</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><h2 id="深度复制"><a href="#深度复制" class="headerlink" title="深度复制"></a>深度复制</h2><p>复制的是一个对象的值<br>可以实现一个ICloneable接口，以标准方式进行深度复制，如果使用这个接口，就必须实现它包含的Clone()方法，这个方法返回一个System. Object的值，我们可以采用各种处理方式，实现所选的任何一个方法体来得到这个对象，如果愿意就可以进行深度复制，但不是必须的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Cloner: ICloneable </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public Cloner(int newVal) =&gt; MyContent.val = newVal;</span><br><span class="line"></span><br><span class="line">    public object Clone() </span><br><span class="line">    &#123;</span><br><span class="line">        Cloner clonedCloner = new Cloner(MyContent.val);</span><br><span class="line">        return clonedCloner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //public object GetCopy() =&gt; MemberwiseClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意在比较复杂的对象系统中，调用Clone是一个递归过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Cloner: ICloneable </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public object Clone() </span><br><span class="line">    &#123;</span><br><span class="line">        Cloner clonedCloner = new Cloner();</span><br><span class="line">        clonedCloner.MyContent = MyContent.Clone();</span><br><span class="line">        return clonedCloner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-迭代器</title>
      <link>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <pubDate>Tue, 06 Aug 2019 08:11:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;p&gt;只要实现了IEnumerable接口，就可以使用foreach循环&lt;br&gt;在foreach循环中，迭代一个collectionObj
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>只要实现了IEnumerable接口，就可以使用foreach循环<br>在foreach循环中，迭代一个collectionObject集合的过程如下：</p><ol><li>调用collectionObject. GetEnumerator(), 返回一个IEnumerator引用，这个方法可通过IEnumerable接口的实现代码来获得，但这是可选的。</li><li>调用所返回的IEnumerator接口的MoveNext()方法。</li><li>如果MoveNext() 方法返回true，就使用IEnumerator接口的Current属性来获取对象的一个引用，用于foreach循环</li><li>重复前面两步，直到MoveNext()方法返回false为止，此时循环停止</li></ol><h2 id="IEnumerable和IEnumerator使用场景："><a href="#IEnumerable和IEnumerator使用场景：" class="headerlink" title="IEnumerable和IEnumerator使用场景："></a>IEnumerable和IEnumerator使用场景：</h2><ol><li>如果要迭代一个类，则使用方法GetEnumerator(), 其返回类型是IEnumerator。</li><li>如果要迭代一个类成员，例如一个方法，则使用IEnumerable。</li></ol><p><strong>在迭代器块中，使用yield关键字选择要在foreach循环中使用的值</strong><br><code>yield return &lt; value &gt;;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Program </span><br><span class="line">&#123;</span><br><span class="line">    public static IEnumerable SimpleList() </span><br><span class="line">    &#123;</span><br><span class="line">        yield return &quot;string 1&quot;;</span><br><span class="line">        yield return &quot;string 2&quot;;</span><br><span class="line">        yield return &quot;string 3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args) </span><br><span class="line">    &#123;</span><br><span class="line">        foreach(var x in SimpleList()) </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Program </span><br><span class="line">&#123;</span><br><span class="line">    private long min;</span><br><span class="line">    private long max;</span><br><span class="line">    public Program(): this(2, 100) &#123;&#125;</span><br><span class="line">    public Program(long minimum, long maxinum) </span><br><span class="line">    &#123;</span><br><span class="line">        if (minimum &lt; 2) </span><br><span class="line">        &#123;</span><br><span class="line">            min = 2;</span><br><span class="line">        &#125; else </span><br><span class="line">        &#123;</span><br><span class="line">            min = minimum;</span><br><span class="line">        &#125;</span><br><span class="line">        max = maxinum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IEnumerator GetEnumerator() </span><br><span class="line">    &#123;</span><br><span class="line">        for (var possiblePrime = min; possiblePrime &lt;= max; possiblePrime++) </span><br><span class="line">        &#123;</span><br><span class="line">            bool isPrime = true;</span><br><span class="line">            for (var possibleFactor = 2; possibleFactor &lt;= (long) Math.Floor(Math.Sqrt(possiblePrime)); possibleFactor++) </span><br><span class="line">            &#123;</span><br><span class="line">                var remainderAfterDivision = possiblePrime % possibleFactor;</span><br><span class="line">                if (remainderAfterDivision == 0) </span><br><span class="line">                &#123;</span><br><span class="line">                    isPrime = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (isPrime) </span><br><span class="line">            &#123;</span><br><span class="line">                yield</span><br><span class="line">                return possiblePrime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void Main(string[] args) </span><br><span class="line">    &#123;</span><br><span class="line">        var primeFrom2to1000 = new Program(55, 100);</span><br><span class="line">        foreach(long i in primeFrom2to1000) </span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write($ &quot;&#123;i&#125;   &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器和集合"><a href="#迭代器和集合" class="headerlink" title="迭代器和集合"></a>迭代器和集合</h2><p>在字典类型的集合中的对象使用迭代器进行迭代存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Animal: DictionaryBase </span><br><span class="line">&#123;</span><br><span class="line">    public void Add(string newID, Animal newAnimal) </span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary.Add(newID, newAnimal);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Delete(string animalID) </span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary.Remove(animalID);</span><br><span class="line">    &#125;</span><br><span class="line">    public Animal this[string animalID] //声明索引器</span><br><span class="line">    &#123;</span><br><span class="line">        get </span><br><span class="line">        &#123;</span><br><span class="line">            return (Animal) Dictionary[animalID];</span><br><span class="line">        &#125;</span><br><span class="line">        set </span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary[animalID] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可在这段代码中添加如下的简单迭代器，以便执行预期操作(对子类特有的操作)：//<strong>不加此方法，程序在编译的时候可以编译过去，但是会在运行时报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public new IEnumerator GetEnumerator() </span><br><span class="line">&#123;</span><br><span class="line">    foreach(object animal in Dictionary.Values) </span><br><span class="line">    &#123;</span><br><span class="line">        yield</span><br><span class="line">        return (Animal) animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可使用下面的代码来迭代集合中的Animal对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var animal1 = new Animal();</span><br><span class="line">animal1.Add(&quot;01&quot;, new Animal() </span><br><span class="line">&#123;</span><br><span class="line">    Name = &quot;dog&quot;</span><br><span class="line">&#125;);</span><br><span class="line">animal1.Add(&quot;02&quot;, new Animal());</span><br><span class="line">animal1.Add(&quot;03&quot;, new Animal());</span><br><span class="line">animal1.Add(&quot;04&quot;, new Animal());</span><br><span class="line">foreach(Animal a in animal1) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-特性和预编译指令</title>
      <link>https://qiyanan.com/2019/08/06/C-%E7%89%B9%E6%80%A7%E5%92%8C%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E7%89%B9%E6%80%A7%E5%92%8C%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/</guid>
      <pubDate>Tue, 06 Aug 2019 08:09:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;特性-Attribute&quot;&gt;&lt;a href=&quot;#特性-Attribute&quot; class=&quot;headerlink&quot; title=&quot;特性(Attribute)&quot;&gt;&lt;/a&gt;特性(Attribute)&lt;/h1&gt;&lt;p&gt;特性(Attribute) 是用于在运行时传递程序中各种
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="特性-Attribute"><a href="#特性-Attribute" class="headerlink" title="特性(Attribute)"></a>特性(Attribute)</h1><p>特性(Attribute) 是用于在运行时传递程序中各种元素(比如类，方法，结构，枚举，组件等)的行为信息的声明性标签，. NET框架提供了两种类型的特性：预定义特性和自定义特性<br>. NEt提供了三种预定义特性：</p><ol><li>AttributeUsage</li></ol><p><code>[AttributeUsage( validon, AllowMultiple=allowmultiple, Inherited=inherited)]</code><br>validon 规定特性可被放置的语言元素，它是枚举器AttributeTargets的值的组合，默认值是AttributeTarget. All<br>allowmultiple(可选)为该特性的AllowMultiple属性(property)提供一个布尔值，表示在一个地方能否被多次使用<br>inherited(可选的)为该特性的提供一个布尔值，表示该特性可否被派生类所继承</p><ol start="2"><li>Conditional</li></ol><p>标记了一个条件方法，它会引起方法调用的条件编辑，取决于指定的值，比如Debug和Trace<br><code>[Conditional( conditionalSymbol)]</code><br>使用Conditional是封闭#if和#endif内部方法的替代方法<br>条件方法受到以下限制</p><pre><code>-条件方法必须是类声明或结构声明中的方法，如果在接口声明中的方法上指定Conditional属性，将出现编译时错误-条件方法必须有返回值-不能用override修饰符标记条件方法，凡是，可以用virtual修饰符标记条件方法-条件方法不能是接口方法的实现-如果条件方法用在“委托创建表达式”中，也会发生编译时错误</code></pre><ol start="3"><li>Obsolete</li></ol><p><code>[Obsolete(&quot; 方法提示 &quot;, bool )]//标注方法为过期方法, bool 表示调用以后编译器是否报错，true 表示报错。</code></p><h1 id="C-中的预编译指令"><a href="#C-中的预编译指令" class="headerlink" title="C#中的预编译指令"></a>C#中的预编译指令</h1><ol><li>#define 和#undef</li></ol><p>`</p><p>#define DEBUG<br><code>告诉编译器存在给定名称的符号，类似于声明一个变量，这个变量没有真正的值，只是存在而已，这个符号不是实际代码的一部分，而只在编译器编译黛玛诗存在，在C#中没有任何意义</code></p><p>#undef DEBUG<br>`<br>如果符号不存在，#undef没有任何作用，如果符号已存在，则#define也不起作用，必须把#define和#undef命令放在C#源文件的开头为止，在声明要编译的任何对象的代码之前，#define本身没有什么用，但与其他预处理指令(特别是#if)结合使用时，它的功能就非常强大了。</p><ol start="2"><li>#if、#elif、#else 和#endif</li></ol><p>这些指令告诉编译器是否要编译某个代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int DoSomeWork(double x) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    if DEBUG</span><br><span class="line">    Console.WriteLine(&quot;x is &quot; + x);#</span><br><span class="line">    endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只有前面的#define命令定义了符号DEBUG后才执行</p><ol start="3"><li>#warning 和 #error</li></ol><p>当编译器遇到他们时，会分别产生警告或错误。如果编译器遇到#warning指令，会给用户显示#warnong指令后面的文本，之后编译继续执行，如果编译器遇到#error指令，就会给用户显示后面的文本，作为一条编译错误消息，然后立即退出编译，不会产生IL代码</p><ol start="4"><li>#region 和#endregion</li></ol><p>用于吧一段代码标记为有给定名称的一个快</p><ol start="5"><li>#line</li></ol><p>改变编译器在警告个错误信息中显示的文件名和行号信息</p><ol start="6"><li>#pragma</li></ol><p>抑制或还原指定的编译警告，可以在累活方法级别执行</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E7%89%B9%E6%80%A7%E5%92%8C%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-反射</title>
      <link>https://qiyanan.com/2019/08/06/C-%E5%8F%8D%E5%B0%84/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E5%8F%8D%E5%B0%84/</guid>
      <pubDate>Tue, 06 Aug 2019 08:04:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是元数据，什么是反射？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序是用来处理数据的，文本和特性都是数据数据，而我们
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>什么是元数据，什么是反射？</strong></p><ol><li>程序是用来处理数据的，文本和特性都是数据数据，而我们程序本身（类的定义和BCL中的类）这些都是数据</li><li>有关程序及其类型的数据被称为元数据(metadata), 他们保存在程序的程序集中。</li><li>程序在运行时，可以查看其它程序集或其本身的元数据。一个运行的程序查看本身的元数据或者其它程序集的元数据的行为叫做反射</li></ol><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>BCL 声明了一个叫做Type的抽象类，它被设计用来包含类型的特性，使用这个类的对象能让我们获取程序使用的类型的信息。</p><ol><li>由于Type是抽象类，因此不能利用它去实例化对象，</li><li>对于程序中用到的每一个类型，CLR都会创建一个包含这个类型信息的Type类型的对象</li><li>程序中用到的每一个类型都会关联到独立的Type类的对象</li><li>不管创建的类型有多少个示例，只有一个Type对象会关联到所有这些实例</li></ol><h2 id="获取Type对象"><a href="#获取Type对象" class="headerlink" title="获取Type对象"></a>获取Type对象</h2><ol><li>通过类的实例来获取Type对象</li></ol><p><code>Type t = myInstance. GetType()</code><br>在object类有一个GetType的方法，返回Type对象，因为所有类都是从object继承的，所以我们可以在任何类型上使用GetType()来获取它的Type对象</p><ol start="2"><li>通过typeof 运算符合类名获取Type对象</li></ol><p><code>Type t= typeof(ClassName)</code></p><h3 id="获取里面的字段"><a href="#获取里面的字段" class="headerlink" title="获取里面的字段"></a>获取里面的字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo() fi = t.GetFields(); //只能获取public字段</span><br><span class="line">foreach(FieldInfo f in fi) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(f.Name + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取里面的属性"><a href="#获取里面的属性" class="headerlink" title="获取里面的属性"></a>获取里面的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PropertyInfo[] fi = t.GetProperties(); //只能获取public字段</span><br><span class="line">foreach(PropertyInfo f in fi)</span><br><span class="line"> &#123;</span><br><span class="line">    Console.WriteLine(f.Name + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取里面的方法"><a href="#获取里面的方法" class="headerlink" title="获取里面的方法"></a>获取里面的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo[] fi = t.GetMethods(); //只能获取public字段</span><br><span class="line">foreach(MethodInfo f in fi) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(f.Name + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取Assembly对象"><a href="#获取Assembly对象" class="headerlink" title="获取Assembly对象"></a>获取Assembly对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass my = new MyClass();</span><br><span class="line">Assenbly assem = my.GetType().Assembly; //通过累的type对象获取他所在的程序集Assembly</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E5%8F%8D%E5%B0%84/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-static关键字</title>
      <link>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <guid>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <pubDate>Mon, 05 Aug 2019 08:46:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;静态类&quot;&gt;&lt;a href=&quot;#静态类&quot; class=&quot;headerlink&quot; title=&quot;静态类&quot;&gt;&lt;/a&gt;静态类&lt;/h1&gt;&lt;p&gt;静态类与非静态类的重要区别在于静态类不能被shi’li’hu&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h1><p>静态类与非静态类的重要区别在于静态类不能被shi’li’hu</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-XML</title>
      <link>https://qiyanan.com/2019/08/04/C-XML/</link>
      <guid>https://qiyanan.com/2019/08/04/C-XML/</guid>
      <pubDate>Sun, 04 Aug 2019 06:34:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h1&gt;&lt;h2 id=&quot;XML基础&quot;&gt;&lt;a href=&quot;#XML基础&quot; class=&quot;headerlink&quot; title=&quot;XML基础&quot;&gt;&lt;/a&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="XML基础"><a href="#XML基础" class="headerlink" title="XML基础"></a>XML基础</h2><ol><li>XML是一种标记语言，与HTML很类似</li><li>XML的设计宗旨是持久化或传递数据，而非显示数据</li><li>XML标签没有被预定义，我们可以根据需要自行定义标签，具有自我描述性</li><li>XML本质上仅仅是才纯文本</li></ol><h2 id="XML模式"><a href="#XML模式" class="headerlink" title="XML模式"></a>XML模式</h2><p>XML文档可以用模式来描述，模式是另一个XML文件，描述了允许在一个特定的文档中使用的元素和特性</p><h2 id="XML文档对象模型"><a href="#XML文档对象模型" class="headerlink" title="XML文档对象模型"></a>XML文档对象模型</h2><p>常用的DOM类：<br>XmlNode: 这个类表示文档树中的一个节点，是许多类的基类，如果这个节点表示XML文档的根，就可以从它导航到文档的任意位置<br>XmlDocument: 扩展了XmlNode类，但通常是使用XML的第一个对象，因为这个类用于加载磁盘或其他地方的数据并在这些位置保存数据<br>XmlElement: 表示XML文档中的一个元素，XmlElement派生于XmlLinkedNode，XmlLinkedNode派生于XmlNode<br>XmlAttribute: 表示一个特性，与XmlDocument类一样，派生于XmlNode类<br>XmlText：表示开始标记和结束标记之间的文本<br>XmlNodeList: 标识一个节点集合</p><h3 id="XmlDocument"><a href="#XmlDocument" class="headerlink" title="XmlDocument"></a>XmlDocument</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var document = new XmlDocument();</span><br><span class="line">document.Load(@&quot;C:\地址&quot;);、//文件名是一个绝对路径</span><br></pre></td></tr></table></figure><h3 id="XmlElement"><a href="#XmlElement" class="headerlink" title="XmlElement"></a>XmlElement</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol><li>FirstChild<br>该属性返回当前节点之后的第一个子节点</li><li>LastChild<br>返回当前节点之后的最后一个子节点</li><li>ParentNode<br>返回当前节点的父节点</li><li>NextSibling<br>返回有相同父节点的下一个节点</li><li>HasChildNodes<br>检查当前元素是否有子元素，而不是必须获取FirstChild的值并检查是否为null</li></ol><h3 id="获取节点值"><a href="#获取节点值" class="headerlink" title="获取节点值"></a>获取节点值</h3><ol><li>InnerText 获取当前节点中所有子节点的文本，把它作为一个串联字符串返回</li><li>InnerXml 返回类似于InnerText的文本</li><li>Value Value属性是操作文档中信息的最精炼方式</li></ol><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ol><li>CreateNode<br>创建任意类型的节点，该方法有三个重载，两个允许创建XmlNodeType 枚举中所列出的类型，另一个允许把要使用的节点类型指定为字符串，</li><li>CreateElement<br>只能创建XmlElement类型的节点</li><li>CreateAttribute<br>只能创建XmlAttribute类型的节点</li><li>CreateTextNode<br>创建XmlTextNode类型的节点</li><li>CreatCommen<br>创建注释</li></ol><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><ol><li>AppendChild<br>把一个节点追加到XmlNode类型或派生类型的节点上</li><li>InsertAfter<br>可以控制插入新节点的位置，该方法有两个参数，第一个是新节点，第二个是在其后插入新节点的节点</li><li>InsertBefour<br>新节点在参考节点之后</li></ol><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ol><li>RemoveAll<br>删除节点之上的所有子节点，并且删除字典的特性</li><li>RemoveChild<br>删除节点上的一个子节点，返回从文档中删除的节点</li></ol><h3 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h3><ol><li>SelectSingleNode<br>选择一个节点</li><li>SelectNodes<br>以XmlNodeList类的形式返回一个节点集合</li></ol><h2 id="XML转换为JSON"><a href="#XML转换为JSON" class="headerlink" title="XML转换为JSON"></a>XML转换为JSON</h2><p>C# 系统库有限的支持JSON. 但是可以使用免费的第三方类库将XMl转换为JSON.</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/C-XML/#disqus_thread</comments>
    </item>
    
    <item>
      <title>GitHub使用技巧</title>
      <link>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <guid>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <pubDate>Sun, 04 Aug 2019 06:31:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;Git两大特点&quot;&gt;&lt;a href=&quot;#Git两大特点&quot; class=&quot;headerlink&quot; title=&quot;Git两大特点
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git两大特点"><a href="#Git两大特点" class="headerlink" title="Git两大特点"></a>Git两大特点</h2><ol><li>版本控制</li><li>分布式</li></ol><h2 id="git最基本操作"><a href="#git最基本操作" class="headerlink" title="git最基本操作"></a>git最基本操作</h2><p>初始化仓库：<br><code>git init</code><br>将一个文件添加到暂存区<br><code>git add code.txt</code><br>创建一个版本记录<br><code>git commit -m &#39;verson1&#39;(版本的说明信息)</code><br>查看版本记录<br><code>git log</code><br>版本回退<br><code>git reset --hard head^ /hard head~1-100</code><br>再次返回<br><code>git reset --hard 版本号</code><br>查看之前的操作记录<br><code>git reflog</code><br>查看当前文件状态<br><code>git status</code><br>未添加到暂存区之前撤销改动(增删改)<br><code>git checkout -- 文件名</code><br>撤销暂存区的修改<br><code>git reset HEAD file</code><br>对比文件不同</p><ol><li>工作区文件与版本文件对比</li></ol><p>git diff HEAD – code.txt<br>–代表版本文件<br>++代表工作区文件</p><ol start="2"><li>对比两个版本之间某个文件的不同</li></ol><p>git diff HEAD HEAD^ – code.txt</p><p>删除文件</p><ol><li>不放在暂存区</li></ol><p>rm 文件名</p><ol start="2"><li>放在暂存区</li></ol><p>git rm 文件名</p><h2 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h2><p>查看分支<br><code>git branch</code><br>创建分支<br><code>git branch 分支名</code><br>创建并切换一个新的分支<br><code>git checkout -b 分支名</code><br>切换分支<br><code>git checkout master</code><br>合并<br><code>git merge 分支名</code><br>删除分支<br><code>git branch -d 分支名</code><br>合并冲突(两个分支上同时提交且编辑同一个文件)</p><p><strong><em>每次操作暂存区内容都必须git commit 创建版本记录</em></strong></p><h2 id="工作区-Working-Directory"><a href="#工作区-Working-Directory" class="headerlink" title="工作区(Working Directory)"></a>工作区(Working Directory)</h2><p>电脑中的目录，就是一个工作区</p><h2 id="版本库-Repository"><a href="#版本库-Repository" class="headerlink" title="版本库(Repository)"></a>版本库(Repository)</h2><p>工作区有一个隐藏目录.git, 这个不是工作区，而是git的版本库<br>git的版本库里存了很多东西，其中最重要的就是称为stage的暂存区，还有git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-Lambda表达式</title>
      <link>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <guid>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <pubDate>Sun, 04 Aug 2019 06:26:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;p&gt;“Lambda表达式”是一个匿名函数，是一种高效的类似于函数式编程的表达式，Lamb
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>“Lambda表达式”是一个匿名函数，是一种高效的类似于函数式编程的表达式，Lambda简化了了开发中需要编写的代码量，它可以包含表达式和语句，并且可用于创建委托或表达式目录树类型，支持带有可绑定到委托或表达式树的输入参数的内联表达式。lambda表达式使用=&gt;运算符，该运算符读作”goes to”。Lambda运算符的左边是输入参数，右边是表达式或语句块。<br><code>x =&gt; x*x</code><br>可以将此表达式分配给委托类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delegate int del(int i);</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    del myDelegate = x =&gt; x * x;</span><br><span class="line">    int j = myDelegate(5); //j = 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目录树类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Linq.Expressions;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApplication1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Expression&lt;del&gt; myET = x =&gt; x * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表达式位于=&gt;运算符右侧的lambda表达式称为”表达式lambada”,表达式Lambda会返回表达式的结果，并采用以下基本形式<br><code>(input parameters) =&gt; expression</code><br>仅当lambda只有一个输入参数时，括号才是可选的；否则括号是必须的，括号内的两个或更多个输入参数使用逗号加以分隔；<br><code>(x, y) =&gt; x == y</code><br>有时，编译器难以或无法推断输入类型。如果出现这种情况，你可以显示指定类型<br><code>(int x, string s) =&gt; s.Length &gt; x</code><br>使用空括号指定零个输入参数：<br><code>() =&gt; SomeMethod()</code><br>当Lambada表达式中有多个语句时<br><code>(input paramenters) =&gt; {statement;}</code></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-LINQ</title>
      <link>https://qiyanan.com/2019/07/28/C-LINQ/</link>
      <guid>https://qiyanan.com/2019/07/28/C-LINQ/</guid>
      <pubDate>Sun, 28 Jul 2019 10:08:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;LINQ&lt;/strong&gt;&lt;br&gt;定义一个匿名类型对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = new {myTitle = &amp;quot;anonymous type&amp;quot;, myOtherParam = new int[] { 1, 2,
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>LINQ</strong><br>定义一个匿名类型对象：</p><pre><code>var obj = new {myTitle = &quot;anonymous type&quot;, myOtherParam = new int[] { 1, 2, 3, 4 } };</code></pre><p><strong>扩展函数：</strong></p><ol><li>扩展方法必须在一个非嵌套、非泛型的静态类中定义</li><li>扩展方法必须是一个静态方法</li><li>扩展方法至少要有一个参数</li><li>第一个参数必须附加this关键字作为前缀</li><li>第一个参数不能有其他修饰符（比如ref或者out）</li><li>第一个参数不能是指针类型</li></ol><p><strong>LINQ 查询操作符</strong><br>.net的设计者在类库中定义了一系列的扩展方法来方便用户操作集合对象，这些扩展方法构成了LINQ的查询操作符<br>扩展方法有Where, Max, Select, Sum, Any, Average, All, Concat等都是针对IEnumberable的对象进行扩展<br>基本LINQ查询操作</p><ol><li>获取数据源<br>在LINQ查询中，第一步是指定数据源，在LINQ查询中，先使用from子句引入数据源和范围变量</li><li>筛选<br>使用where子句生成结果，查询仅返回表达式为true的元素</li><li>中间件排序<br>orederby子句根据要排序类型的默认比较器，对返回序列中的元素排序，字符串比较顺序默认从A到Z进行排序，逆序使用orderby…descendingz子句</li><li>分组<br>group 子句用于对所获得的结果进行分组，使用group子句结束查询时，结果将以列表的形式列出，列表中的每个元素都是具有key成员的对象，列表中的元素根据该键杯分组，在循环访问生成组序列的查询时，必须使用嵌套foreach循环，外层循环访问每个组，内层循环访问每个组的成员，<br>如果必须引用某个组操作的结果，可使用into关键字创建能被进一步查询的标识符</li><li>联接<br>联接操作在不同序列间创建关联</li><li>选择(投影)<br>Select子句指定在执行查询时产生的值的类型，查询表达式必须以select子句或group子句结尾</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Customers&gt; customers = new List&lt;Customers&gt;() &#123;</span><br><span class="line">    new Customers&#123; Name = &quot;QIyanan&quot;, City = &quot;Gansu&quot;, Age = 16 &#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;IkeQi&quot;,City=&quot;USA&quot;,Age=18&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingQi&quot;,City=&quot;London&quot;,Age=20&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingZhang&quot;,City=&quot;London&quot;,Age=22&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingWang&quot;,City=&quot;London&quot;,Age=24&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingSun&quot;,City=&quot;London&quot;,Age=25&#125;&#125;;</span><br><span class="line">var result = from customer in customers</span><br><span class="line">             where customer.City == &quot;London&quot; &amp;&amp; customer.Name == &quot;kingQi&quot;</span><br><span class="line">             orderby customer.Age descending</span><br><span class="line">             select customer;</span><br><span class="line">var queryCustomersByCity = from cust in customers</span><br><span class="line">                           group cust by cust.City;</span><br><span class="line">foreach(var customerGroup in queryCustomersByCity)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(customerGroup.Key);</span><br><span class="line">    foreach(var customer in customerGroup)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;       &#123;customer.Name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foreach (var customer in result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(customer.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var studentQuery = from student in students</span><br><span class="line">                       where student.Scores[0] &gt; 90 &amp;&amp; student.Scores[3] &lt; 80</span><br><span class="line">                       orderby student.Scores[0] descending</span><br><span class="line">                       select student;</span><br><span class="line">    foreach (var student in studentQuery)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;    &#123;student.Last&#125;,     &#123;student.First&#125;,     &#123;student.Scores[0]&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery2 = from student in students</span><br><span class="line">                        group student by student.Last[0];</span><br><span class="line">    foreach (var studentGroup in studentQuery2)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(studentGroup.Key);</span><br><span class="line">        foreach (var student in studentGroup)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;        &#123;student.Last&#125;,   &#123;student.First&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery3 = from student in students</span><br><span class="line">                        group student by student.Last[0] into studentGroup</span><br><span class="line">                        orderby studentGroup.Key</span><br><span class="line">                        select studentGroup;</span><br><span class="line">    foreach (var groupOfStudents in studentQuery3)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(groupOfStudents.Key);</span><br><span class="line">        foreach (var student in groupOfStudents)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;     &#123;0&#125;,    &#123;1&#125;&quot;, student.Last, student.First);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery5 = from student in students</span><br><span class="line">                        let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3]</span><br><span class="line">                        where totalScore / 4 &lt; student.Scores[0]</span><br><span class="line">                        select student.Last + &quot;     &quot; + student.First;</span><br><span class="line">    foreach (string s in studentQuery5)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery6 = from student in students</span><br><span class="line">                        let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3]</span><br><span class="line">                        select totalScore;</span><br><span class="line">    double averageScore = studentQuery6.Average();</span><br><span class="line">    Console.WriteLine($&quot;Classaverage score = &#123;averageScore&#125;&quot;);</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery7 = from student in students</span><br><span class="line">                        where student.Last == &quot;Garcia&quot;</span><br><span class="line">                        select student.First;</span><br><span class="line">    Console.WriteLine(&quot;The garcias in the class are:&quot;);</span><br><span class="line">    foreach (string s in studentQuery7)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LINQ查询函数<br><strong>Where(); 查询结果过滤</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list0 = new List&lt;int&gt; &#123; 6, 4, 2, 7, 9, 0 &#125;;</span><br><span class="line">list0.Where(x =&gt; x &gt; 5);</span><br><span class="line">list0.Where(x =&gt; x &gt;= 1).Where(x =&gt; x &lt;= 5);</span><br><span class="line">list0.Where(x =&gt; x &gt;= 1 &amp;&amp; x &lt;= 5);</span><br></pre></td></tr></table></figure></p><p><strong>Select(), SelectMany();</strong><br>处理结果会传回一个对象，这个对象可以是现在对象，也可以是匿名类型<br>在LINQ语句中的select new语句，会自动被编译器转换Select()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Num = from a in list0</span><br><span class="line">          where a &gt; 3</span><br><span class="line">          select new</span><br><span class="line">          &#123;</span><br><span class="line">             Number = a</span><br><span class="line">          &#125;;</span><br><span class="line">Console.WriteLine(Num.FirstOrDefault().Number);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var selectNum = list0.Where(x =&gt; x &gt; 3).Select(x =&gt; new &#123; Number = x &#125;);</span><br></pre></td></tr></table></figure><p>SelectMany()类似于数据库中的CrossJoin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">List&lt;int&gt; list2 = new List&lt;int&gt;() &#123; 6, 4, 5, 7, 9, 0 &#125;;</span><br><span class="line">var query = list1.SelectMany(x =&gt; list2);</span><br><span class="line">foreach (var iterm in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(iterm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>GroupBy()</strong><br>会按照给定的key(keySelector)以及内容elementSelector,产生群组后的结果GroupBy()设置了使用数列本身作为Key值，并且利用这个Key分组产生分组的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5, 1, 5, 4, 3, 2, 5, 5, 5, 6, 2, 3, 6 &#125;;</span><br><span class="line">var query = list.GroupBy(x =&gt; x);</span><br><span class="line">foreach (var item in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;numer is  &#123;item.Key&#125;, numer has &#123;item.Count()&#125;&quot;);</span><br><span class="line">    foreach (var x in item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;           &#123;x&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ToLookUp()</strong><br>返回值是一个泛型Lookup&lt;TKey, TElement&gt;, 看起来和GroupBy()类似，但是Yolookup是立即执行，GroupBy是延迟执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var marrks = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123; Mark = 90, Group = &quot;A&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 80, Group = &quot;B&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 70, Group = &quot;C&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 60, Group = &quot;D&quot;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">var lookUpValue = marrks.ToLookup(x =&gt; x.Group);</span><br><span class="line">foreach(var item in lookUpValue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;=========Group:&#123;0&#125;===========&quot;,item.Key);</span><br><span class="line">    foreach(var result in item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(result.Group+&quot;   &quot;+result.Mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Join</strong><br>将两个集合进行连接，即数据库中的Inner Join<br>使用LINQ语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var Mark = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123;Name = &quot;C&quot; , Mark = 65&#125;,</span><br><span class="line">    new &#123;Name = &quot;A&quot; , Mark = 70&#125;,</span><br><span class="line">    new &#123;Name = &quot;B&quot; , Mark = 80&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">var Age = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123;Name = &quot;B&quot; , Age = 18&#125;,</span><br><span class="line">    new &#123;Name = &quot;C&quot; , Age = 17&#125;,</span><br><span class="line">    new &#123;Name = &quot;A&quot; , Age = 20&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var query = from mk in Mark</span><br><span class="line">            join ee in Age on mk.Name equals ee.Name</span><br><span class="line">            select new</span><br><span class="line">            &#123;</span><br><span class="line">                name = mk.Name,</span><br><span class="line">                mark = mk.Mark,</span><br><span class="line">                age = ee.Age</span><br><span class="line">            &#125;;</span><br><span class="line">foreach(var item in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;name &#123;item.name&#125;, Score &#123;item.mark&#125;, Age &#123;item.age&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用LINQ函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var quer1 = Mark.Join(Age, mk =&gt; mk.Name, ae =&gt; ae.Name, (mk, ae) =&gt; new &#123; name = mk.Name, mark = mk.Mark, age = ae.Age &#125;);</span><br><span class="line">foreach (var item in quer1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;name &#123;item.name&#125;,  score&#123; item.mark&#125;,  age&#123;item.age&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中Mark是第一个集合，Join方法的第一个参数Age是第二个集合，mk =&gt; mk.name 是 第一个集合的外键，ae=&gt;ae.Name是第二个集合的外键。<br><strong>GroupJoin;</strong><br>将两个集合进行联接，并对结果进行分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义国家类</span><br><span class="line">class Country</span><br><span class="line">&#123;</span><br><span class="line">    public string CountryName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义省类</span><br><span class="line">class Province</span><br><span class="line">&#123;</span><br><span class="line">    public Country OwnerCountry &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceName &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceSize &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceSpot &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//对国家类进行实例化</span><br><span class="line">Country c1 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;China&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c2 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;America&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c3 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;Korea&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c4 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;Russian&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//对省实例化</span><br><span class="line">Province p1 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Hunan&quot;,</span><br><span class="line">    ProvinceSize = &quot;200&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Old City&quot;,</span><br><span class="line">    OwnerCountry = c1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p2 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Chicago&quot;,</span><br><span class="line">    ProvinceSize = &quot;150&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Linkin Park&quot;,</span><br><span class="line">    OwnerCountry = c2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p3 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Seoul&quot;,</span><br><span class="line">    ProvinceSize = &quot;100&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Tian Tian World&quot;,</span><br><span class="line">    OwnerCountry = c3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p4 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Hunan&quot;,</span><br><span class="line">    ProvinceSize = &quot;200&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Tian Meng Mountain&quot;,</span><br><span class="line">    OwnerCountry = c1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p5 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Moscow&quot;,</span><br><span class="line">    ProvinceSize = &quot;80&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Moscow University&quot;,</span><br><span class="line">    OwnerCountry = c4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p6 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Moscow&quot;,</span><br><span class="line">    ProvinceSize = &quot;80&quot;,</span><br><span class="line">    ProvinceSpot = &quot;HelloWorld&quot;,</span><br><span class="line">    OwnerCountry = c4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义省集合</span><br><span class="line">List&lt;Province&gt; provinces = new List&lt;Province&gt;</span><br><span class="line">&#123;</span><br><span class="line">    p1,p2,p3,p4,p5,p6</span><br><span class="line">&#125;;</span><br><span class="line">//定义国家集合</span><br><span class="line">var countries = new List&lt;Country&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c1,c2,c3,c4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用Join连接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    //使用Join连接</span><br><span class="line">    var joinResult = countries.Join(provinces, country =&gt; country, province =&gt; province.OwnerCountry, (country, province) =&gt;</span><br><span class="line">    new</span><br><span class="line">    &#123;</span><br><span class="line">        countryName = country.CountryName,</span><br><span class="line">        provinceName = province.ProvinceName,</span><br><span class="line">        size = province.ProvinceSize,</span><br><span class="line">        spot = province.ProvinceSpot</span><br><span class="line">    &#125;);</span><br><span class="line">    foreach(var item in joinResult)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;countryName is &#123;item.countryName&#125; , provinceName is &#123;item.provinceName&#125; , size is &#123;item.size&#125;, spot is &#123;item.spot&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用GroupJoin</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var groupJoinResult = countries.GroupJoin(provinces, country=&gt;country, province =&gt; province.OwnerCountry, (country,province) =&gt; new</span><br><span class="line">&#123;</span><br><span class="line">    Name=country.CountryName,</span><br><span class="line">    ProvinceSet=province.Select(x=&gt;x)</span><br><span class="line">&#125;);</span><br><span class="line">foreach (var item in groupJoinResult)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Name);</span><br><span class="line">    foreach(var p in item.ProvinceSet)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(p.ProvinceName + &quot;  &quot; + p.ProvinceSize + &quot;  &quot; + p.ProvinceSpot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-LINQ/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-多线程</title>
      <link>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <pubDate>Sun, 28 Jul 2019 09:05:30 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;p&gt;什么是进程？&lt;br&gt;狭义定义：进程就是一段程序的执行过程&lt;br&gt;广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>什么是进程？<br>狭义定义：进程就是一段程序的执行过程<br>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，他是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元<br>进程的特点<br>动态性，并发性，独立性，异步性<br>进程的基本操作<br>获取进程<br><code>Process[] processes = Process. GetProcesses()；</code><br>启动进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProcessStartInfo psi = newProcessStartInfo();</span><br><span class="line">//设置psi属性</span><br><span class="line">//命令行参数</span><br><span class="line">Process newProcess = Process.Start(psi);</span><br></pre></td></tr></table></figure><p>杀掉进程：<br><code>Process. Close()//并非真正结束进程，释放进程所占用的资源</code><br><code>Process. Kill()//不建议使用</code><br><strong>什么是线程？</strong><br>线程，称为轻量级进程，是程序执行流的最小单元，一个标准的线程是由线程ID, 当前指令指针(PC), 寄存器集合和堆栈组成，线程是进程的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源<br><strong>多线程编程</strong><br><strong>. NET程序中基本的线程</strong></p><ol><li>Garbage collector 线程：用于垃圾回收</li><li>Finalizer线程：用于调度对象的Finalize方法</li><li>Main线程：程序的额入口线程</li><li>UI线程：用于更新渲染用户界面，存在于Windows Form, WPF, Windows Store类型的程序中</li></ol><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new Thread(Run); //创建</span><br><span class="line">t.Start(); //启动</span><br><span class="line">t.Name = &quot;Hello World&quot;; //设置线程名</span><br><span class="line">t.isBackground = true; //设置为后台进程, 随着进程的退出线程也退出</span><br><span class="line">Thread.Sleep(1000); //挂起当前线程</span><br><span class="line">t.Join(); //阻塞当前线程，直到t线程结束</span><br><span class="line">t.Abort();</span><br><span class="line">终止t， 无条件退出， 报一个异常</span><br><span class="line">t.Interrupt(); //当t处于Wait，Sleep或Join时，终止t，且会报一个异常</span><br><span class="line">Thread类构造函数可使用下面的delegate作为参数：</span><br><span class="line">ThreadStart:</span><br><span class="line">    public delegate void ThreadStart();</span><br></pre></td></tr></table></figure><h2 id="线程池-ThreadPool"><a href="#线程池-ThreadPool" class="headerlink" title="线程池(ThreadPool)"></a>线程池(ThreadPool)</h2><p>创建线程需要时间和资源，如果有很多不同的小任务要起线程来完成，可以使用ThreaPool创建和管理这些线程，ThreadPool管理着一个线程列表，可以在需要时增减线程的数量，这个数量的上限和下限都是可匹配的，也可以重复利用线程。<br>和使用Thread类创建线程的方式不同，使用ThreadPool时，线程的创建，销毁以及并发线程数等因素皆有ThreadPool统一控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(WaitCallback callBack);</span><br><span class="line">ThreadPool.QueueUserWorkItem(WaitCallback callback, Object state);</span><br></pre></td></tr></table></figure><p><strong>使用ThreadPool时应注意</strong></p><ol><li>ThreadPool中的线程均为后台线程，不能改成前台线程</li><li>ThreadPool中的线程不能被显式退出或暂停</li><li>ThreadPool中的线程不能被显式的修改线程明和控制优先级</li><li>ThreadPool中的线程不能被显式Join，必须使用其他的同步资源手段达到这个目的</li><li>正常的线程运行结束后会被销毁，而ThreadPool中的线程会被重复利用</li><li>ThreadPool中线程不应该用于管理常驻线程或其他需要一直运行的线程，这种情况应该是使用Thread类穿件一个新的线程</li></ol><h2 id="Task类"><a href="#Task类" class="headerlink" title="Task类"></a>Task类</h2><p>Task是对ThreadPool进行一层抽象封装，旨在是开发专注于上层操作，不用关心底层Thread的控制</p><ol><li>Task具有很强的灵活性</li><li>可以指定连续的工作</li><li>可以区分执行任务的成功与否</li><li>可以创建依赖关系，将任务层次化</li></ol><p><strong>两种表现形式：</strong><br>Task, Task<tresult>, 后者表示可以返回结果</tresult></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var tf = new TaskFactory();</span><br><span class="line">var t1 = tf.StartNew();</span><br></pre></td></tr></table></figure><p><code>var t2 = Task. Factory. StartNew(TaskMethod);</code><br><code>var t3 = new Task(TaskMethod);</code><br><code>t3. Start(); //表示异步启动</code><br><strong>Task连续执行</strong><br>Task t1 = new Task(DoOnFirst);<br>Task t2 = t1. ContinueWith(DoOnSecond);<br>Task t3 = t1. ContinueWith(DoOnSecond);<br>Task t4 = t2. ContinueWith(DoOnSecond);<br>Task t5 = t1. ContinueWith(DoOnError, TaskContinuationOptions, OnlyOnfaulted);<br>TaskContinuationOptions枚举参数：<br>OnlyOnFaulted, NotOnFaulted, OnlyOnCancled, NotOnCanceled, OnlyOnRanToToCompletion, ExcuteSynchronously…<br><strong>Task层次执行</strong><br>在父Task中创建一个子Task，就形成了层次依赖关系，父Task结束，则子Task也随着结束<br><strong>Task类常用方法</strong><br>ContinueWith: 创建一个在当前task执行结束后开始执行的新Task<br>Delay：创建一个在指定Delay时间后完成的Task<br>Run：返回一个压入ThreadPool的新Task<br>Start：开始一个Task<br>Wait：等待当前实例Task结束<br>WaitAll：等待所有Task结束<br>WaitAny：等待任意Task结束<br>WhenAll: 创建一个新的Task, 当被传作参数的所有Task都结束后，这个Task会被标识为结束<br>WhenAny: 创建一个新Task, 当被传作参数的任意Task结束后，这个Task会被标识为结束<br>CurrentId：获取当前正在执行的task ID<br><strong>Task类常用属性</strong><br>isCompleted: 判断当前task实例是否已经结束<br>isFaulted：判断当前task实例是否由于一个未捕获的异常而结束<br>Status：获取当前task实例的状态<br>IsCanceled: 判断当前task实例是否被取消<br>Exception：获取导致当前task结束的异常<br>Factory：返回一个Task的工厂用来创建新task<br>ID: 获取当前task实例ID</p><h2 id="异步委托"><a href="#异步委托" class="headerlink" title="异步委托"></a>异步委托</h2><p>如果要创建一个轻量级的线程，一种简单的办法是使用委托(Delegate), 并异步调用它。<br>委托通过线程池来完成异步任务<br><strong>可以使用不同的技术异步调用委托</strong></p><ol><li>Poll</li><li>AsyncWaitHandle</li><li>AsyncCallback</li></ol><p><strong>基本模型：</strong><br>IAsyncResult ar=delegate. BeginInvoke(…, AsyncCallback, …);<br>object obj = delegaye. EndInvoke(ar);<br>async和await关键字<br>async关键字：标识一个方法是异步的。<br>await关键字：用来等待一个异步方法的结果</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="进程内部的同步"><a href="#进程内部的同步" class="headerlink" title="进程内部的同步"></a>进程内部的同步</h3><ol><li>Lock //区域性加锁，内部实现基于Monitor </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">    int i;</span><br><span class="line">    private object thisLock = new object();</span><br><span class="line">    public void Increase() &#123;</span><br><span class="line">        lock(thisLock) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Monitor</li></ol><p>锁<br><code>Monitor. Enter(thisLock)</code><br>释放锁<br><code>Monitor. Exit(this. Lock); //建议写在finally块中</code></p><ol start="3"><li>InterLocked //</li><li>AutoResetEvent类 //允许线程通过发信号互相通信</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AutoResetEvent are = new AutoResetEvent(false);</span><br><span class="line">are.WaitOne(); //阻塞当前线程，等待信号量</span><br><span class="line">are.Set(); //设置信号量，唤醒一个等待信号量的线程</span><br></pre></td></tr></table></figure><h3 id="多个进程中线程的同步"><a href="#多个进程中线程的同步" class="headerlink" title="多个进程中线程的同步"></a>多个进程中线程的同步</h3><ol><li>WaitHandle</li><li>Mutex</li><li>Semaphore</li><li>Event</li><li>ReaderWriterLockSlim</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>所谓死锁是指两个或以上的进程在执行过程中，因正度资源而造成的一种互相等待的现象，若无外力作用，他们都无法推进下去。</p><p>创建多线程的步骤：</p><ol><li>编写线程所要执行的方法</li><li>例化Thread类，并传入一个指向线程所要执行方法的委托。（这时线程已经产生，但还没有运行）</li><li>调用Thread实例的Start方法，标记该线程可以被CPU执行了，但具体执行时间由CPU决定</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">namespace ConsoleApp2 &#123;</span><br><span class="line">    using System;</span><br><span class="line">    using System.Collections.Generic;</span><br><span class="line">    using System.Linq;</span><br><span class="line">    using System.Text;</span><br><span class="line">    using System.Threading;</span><br><span class="line">    using System.Threading.Tasks;</span><br><span class="line">    class Program &#123;</span><br><span class="line">        static void Main() &#123;</span><br><span class="line">            var p1 = new ThreadTest();</span><br><span class="line">            var thread1 = new Thread(new ThreadStart(p1.Thread1)); //该代码可改写为var thread1 = new Thread(p1.Thread1);</span><br><span class="line">            var thread2 = new Thread(delegate() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    Console.WriteLine(&quot;I am created by anonymous function&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            var thread3 = new Thread(() =&gt; &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    Console.WriteLine(&quot;i am created by Lambda expression&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread1.Start();</span><br><span class="line">            thread2.Start();</span><br><span class="line">            thread3.Start();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class ThreadTest &#123;</span><br><span class="line">        public void Thread1() &#123;</span><br><span class="line">            Console.WriteLine(&quot;this is no parms function&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-多线程与Java-多线程异同："><a href="#C-多线程与Java-多线程异同：" class="headerlink" title="C# 多线程与Java 多线程异同："></a>C# 多线程与Java 多线程异同：</h1><p>都是通过Thread类来实现多线程<br>都是调用start方法来开启一个线程</p><h2 id="Java实现多线程一般有三种方法："><a href="#Java实现多线程一般有三种方法：" class="headerlink" title="Java实现多线程一般有三种方法："></a>Java实现多线程一般有三种方法：</h2><ol><li>继承Thread类, 实现thread类里的run()方法</li><li>实现Runnable接口，重写run()方法，并将此对象以参数的形式传给Thread对象</li><li>实现Callable接口，重写Call()方法，并将此对象传给futureTask对象内，再将FutureTask对象作为参数传入Thread对象内。</li></ol><h2 id="C-实现多线程："><a href="#C-实现多线程：" class="headerlink" title="C# 实现多线程："></a>C# 实现多线程：</h2><ol><li>通过ThreadStart委托来实现多线程</li><li>使用匿名方法来实现多线程</li><li>使用Lambda表达式实现多线程</li><li>ThreeadPool实现多线程，只要执行完毕，自动退出</li></ol><p><code>ThreadPool. QueueUserWorkItem(p1. Thread1); //委托的方法必须有一个Object类型的参数</code></p><ol start="5"><li>Task实现多线程</li></ol><h1 id="NET程序集"><a href="#NET程序集" class="headerlink" title=". NET程序集"></a>. NET程序集</h1><p>程序集，简单来说就是一个公共语言运行库(CLR)为宿主的，版本化的，自描述的二进制文件，<br><strong>程序集的构成：</strong></p><ol><li>程序集清单</li><li>元数据</li><li>实现这些类型的MSIL代码</li><li>资源集，诸如位图，指针，静态文本等。</li></ol><p><strong>程序集分类：</strong></p><ol><li>私有程序集（部署在本地）</li><li>共享程序集（部署在全局应用缓存——GAC)</li></ol><h1 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h1><p>类库是一个综合性的面向对象的可重用类型集合，这些类库包括：接口，抽象类和具体类<br>类库不等于框架（Franework）<br>类库会在编译之后生成一个dll文件，其他项目可以引用 </p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
