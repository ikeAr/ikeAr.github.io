<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ike&#39;s blog</title>
    <link>http://qiyanan.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 22 May 2019 07:42:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java-File类</title>
      <link>http://qiyanan.com/2019/05/21/Java-File%E7%B1%BB/</link>
      <guid>http://qiyanan.com/2019/05/21/Java-File%E7%B1%BB/</guid>
      <pubDate>Tue, 21 May 2019 11:33:14 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在Java语言里提供有对于文件操作系统操作的支持，这个支持就在java.io.File类中进行了定义，File类是唯一一个与文件本身操作（创建，删除，重命名等等）有关的类。&lt;/p&gt;
&lt;h1 id=&quot;File类的基本使用：&quot;&gt;&lt;a href=&quot;#File类的基本使用：&quot; cl
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在Java语言里提供有对于文件操作系统操作的支持，这个支持就在java.io.File类中进行了定义，File类是唯一一个与文件本身操作（创建，删除，重命名等等）有关的类。</p><h1 id="File类的基本使用："><a href="#File类的基本使用：" class="headerlink" title="File类的基本使用："></a>File类的基本使用：</h1><ol><li>File类是Comparable接口的一个子类，所以File类的对象是可以做排序处理的。</li><li>构造方法：<strong>public File(String pathname)</strong>,设置要操作的完整路径；<br>构造方法：public File(File parent, String child), 设置父路径与子目录</li><li>如果要进行文件的基本操作，可以使用如下的方法：<br>创建新的文件：public boolean creatNewFile() throws IOException<br>判断文件是否存在: <strong>public boolean exists();</strong><br>删除文件：<strong>public boolean delete();</strong></li></ol><h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><ol><li>在使用File类进行文件处理的时候需要注意的是：<br>程序——&gt; JVM ——&gt; 操作系统函数——&gt; 文件处理。</li><li>在进行文件创建的时候有一个重要的前提：文件的父路径必须首先存在。<br>获取父路径：<strong>public File getParentFile();</strong><br>创建目录：<strong>public boolean mkdirs();</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        File file = new File(&quot;D:/hello/demo/demo.txt&quot;);</span><br><span class="line">        if (!file.getParentFile().exists()) &#123;</span><br><span class="line">            file.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        if (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(file.createNewFile());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/05/21/Java-File%E7%B1%BB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-单例模式</title>
      <link>http://qiyanan.com/2019/05/12/Java-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <guid>http://qiyanan.com/2019/05/12/Java-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Sun, 12 May 2019 04:08:05 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;单例模式的核心本质在于：类内部的构造方法私有化，在类的内部产生实例化对象之后通过static方法获取实例化对象进行类中的结构调用，单例设计模式一般分为两类：懒汉式，饿汉式。&lt;/p&gt;
&lt;h1 id=&quot;饿汉式&quot;&gt;&lt;a href=&quot;#饿汉式&quot; class=&quot;headerlink&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>单例模式的核心本质在于：类内部的构造方法私有化，在类的内部产生实例化对象之后通过static方法获取实例化对象进行类中的结构调用，单例设计模式一般分为两类：懒汉式，饿汉式。</p><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class SingleTon &#123;</span><br><span class="line">    private SingleTon()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;;</span><br><span class="line">    private static SingleTon instance = new SingleTon();</span><br><span class="line">    public static SingleTon getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;线程执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">// write your code here</span><br><span class="line">        for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">          new Thread(()-&gt;&#123;</span><br><span class="line">              SingleTon.getInstance().print();</span><br><span class="line">          &#125;,&quot;线程&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程0</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br></pre></td></tr></table></figure></p><h2 id="饿汉模式的特点："><a href="#饿汉模式的特点：" class="headerlink" title="饿汉模式的特点："></a>饿汉模式的特点：</h2><p>类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，<br>饿汉式天生是线程安全的，可以直接用于多线程而不会出现问题</p><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><p>简单的懒汉模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class SingleTon &#123;</span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static SingleTon instance = null;</span><br><span class="line"></span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new SingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;线程执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程1</span><br><span class="line">线程执行</span><br><span class="line">线程2</span><br><span class="line">线程执行</span><br><span class="line">线程0</span><br><span class="line">线程执行</span><br></pre></td></tr></table></figure></p><p>该模式下程序是非线程安全的，为了实现线程安全可采用以下三种方式：</p><ol><li>使用synchronized方法进行同步：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class SingleTon &#123;</span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static SingleTon instance = null;</span><br><span class="line"></span><br><span class="line">    public static synchronized SingleTon getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new SingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;线程执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程0</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br></pre></td></tr></table></figure></p><p><strong>该方式虽然实现了延迟加载，但是和饿汉模式相比，它引入了同步关键字，因此，它的时耗要远远大于饿汉模式下实现单例。</strong></p><ol start="2"><li>使用双检锁的方法进行同步处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class SingleTon &#123;</span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static volatile SingleTon instance = null;</span><br><span class="line"></span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SingleTon.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new SingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;线程执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程0</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br></pre></td></tr></table></figure></p><p>该方法虽然实现了线程同步，相比于同步方法的时耗会低一些，但任然不是最佳选择</p><ol start="3"><li>使用内部类维护单例的实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class SingleTon &#123;</span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static SingleTon instance = new SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;线程执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程0</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br><span class="line">线程执行</span><br></pre></td></tr></table></figure></p><p>在这个实现中，当SingleTon类被加载时，其内部类并不会被初始化，而当getInstance()方法被调用时，才会加载SingletonHoder, 从而初始化instance，由于实例的建立是在类加载时完成，故天生对多线程友好，getInstance()方法也不需要使用同步关键字，因此，这种实现方式时比较完美的。</p>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/05/12/Java-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-Class类对象的三种实例化模式</title>
      <link>http://qiyanan.com/2019/05/09/Java-Class%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</link>
      <guid>http://qiyanan.com/2019/05/09/Java-Class%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Thu, 09 May 2019 13:26:57 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;反射之中的所有核心操作都是通过Class类对象展开的，可以说Class类是反射操作的根源所在，如果要获得它的实例化对象，可以采用三种方式完成 &lt;/p&gt;
&lt;h1 id=&quot;【Object类支持】Object类可以根据实例化对象获取Class对象&quot;&gt;&lt;a href=&quot;#【Obje
        
      
      </description>
      
      <content:encoded><![CDATA[<p>反射之中的所有核心操作都是通过Class类对象展开的，可以说Class类是反射操作的根源所在，如果要获得它的实例化对象，可以采用三种方式完成 </p><h1 id="【Object类支持】Object类可以根据实例化对象获取Class对象"><a href="#【Object类支持】Object类可以根据实例化对象获取Class对象" class="headerlink" title="【Object类支持】Object类可以根据实例化对象获取Class对象"></a>【Object类支持】Object类可以根据实例化对象获取Class对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person=new Person();</span><br><span class="line">        Class sr=person.getClass();</span><br><span class="line">        System.out.println(sr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JVM直接支持-类-class的形式实例化"><a href="#JVM直接支持-类-class的形式实例化" class="headerlink" title="JVM直接支持 类.class的形式实例化"></a>JVM直接支持 类.class的形式实例化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class sr=Person.class;</span><br><span class="line">        System.out.println(sr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通过Class-forName-“类名”-实例化"><a href="#通过Class-forName-“类名”-实例化" class="headerlink" title="通过Class.forName(“类名”)实例化"></a>通过Class.forName(“类名”)实例化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;?&gt; sr= null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sr = Class.forName(&quot;Person&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/05/09/Java-Class%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-工厂模式+反射+泛型</title>
      <link>http://qiyanan.com/2019/05/09/Java-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%8F%8D%E5%B0%84-%E6%B3%9B%E5%9E%8B/</link>
      <guid>http://qiyanan.com/2019/05/09/Java-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%8F%8D%E5%B0%84-%E6%B3%9B%E5%9E%8B/</guid>
      <pubDate>Thu, 09 May 2019 13:25:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;如果要想进行对象的实例化处理，除了可以使用关键字new之外，还可以使用反射机制来完成，那么到底是使用关键字new还是使用反射呢？&lt;br&gt;最好的解释方案是通过工厂模式来解决&lt;/p&gt;
&lt;h1 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink
        
      
      </description>
      
      <content:encoded><![CDATA[<p>如果要想进行对象的实例化处理，除了可以使用关键字new之外，还可以使用反射机制来完成，那么到底是使用关键字new还是使用反射呢？<br>最好的解释方案是通过工厂模式来解决</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式最大特点：客户端的一个程序类不直接牵扯到对象的实例化管理，只与接口发生关联，通过工厂类获取指定接口的实例，传统的工厂模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public interface Imessage &#123; //消息接口</span><br><span class="line">     void send();</span><br><span class="line">&#125;</span><br><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class NetMessage implements Imessage &#123;</span><br><span class="line">    @Override //网络消息类</span><br><span class="line">    public void send() &#123;</span><br><span class="line">        System.out.println(&quot;【网络消息发送】&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class CloudMessage implements Imessage &#123;</span><br><span class="line"></span><br><span class="line">    @Override //云消息类</span><br><span class="line">    public void send() &#123;</span><br><span class="line">        System.out.println(&quot;【云消息发送】&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class Factory &#123;//工厂类</span><br><span class="line">    private Factory()&#123;&#125;;</span><br><span class="line">    public static Imessage getInstance(String className)&#123;</span><br><span class="line">        if(&quot;netmessage&quot;.equalsIgnoreCase(className))&#123;</span><br><span class="line">            return new NetMessage();</span><br><span class="line">        &#125;else if(&quot;cloudMessage&quot;.equalsIgnoreCase(className))&#123;</span><br><span class="line">            return new CloudMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">// write your code here</span><br><span class="line">        Imessage netMessage=Factory.getInstance(&quot;netmessage&quot;);</span><br><span class="line">        netMessage.send();</span><br><span class="line">        Imessage cloudmessage=Factory.getInstance(&quot;cloudmessage&quot;);</span><br><span class="line">        cloudmessage.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此种工厂设计模式属于静态工厂设计模式，如果现在需要追加一个子类，那么工厂模式必须修改，如果不追加此种判断是无法获取指定接口对象的，因此，我们通过工厂模式 + 反射机制来解决问题。</p><h1 id="工厂模式-反射"><a href="#工厂模式-反射" class="headerlink" title="工厂模式 + 反射"></a>工厂模式 + 反射</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class Factory &#123;</span><br><span class="line">    private Factory() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Imessage getInstance(String className) &#123;</span><br><span class="line">        Imessage instance = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            instance = (Imessage) Class.forName(className).getDeclaredConstructor().newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">//        if(&quot;netmessage&quot;.equalsIgnoreCase(className))&#123;</span><br><span class="line">//            return new NetMessage();</span><br><span class="line">//        &#125;else if(&quot;cloudMessage&quot;.equalsIgnoreCase(className))&#123;</span><br><span class="line">//            return new CloudMessage();</span><br><span class="line">//        &#125;</span><br><span class="line">//        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">// write your code here</span><br><span class="line">        Imessage netMessage=Factory.getInstance(&quot;com.company.NetMessage&quot;);</span><br><span class="line">        netMessage.send();</span><br><span class="line">        Imessage cloudmessage=Factory.getInstance(&quot;com.company.CloudMessage&quot;);</span><br><span class="line">        cloudmessage.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在开发过程中，可能存在有大量的接口，并且这些接口都可能需要通过工厂类实例化，此时，该工厂既不能只为一个特定的接口服务，而是应该为所有的接口服务，因此，我们采用工厂模式 + 反射 + 泛型来解决</p><h1 id="工厂模式-反射-泛型"><a href="#工厂模式-反射-泛型" class="headerlink" title="工厂模式 + 反射 + 泛型"></a>工厂模式 + 反射 + 泛型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class Factory &#123;</span><br><span class="line">    private Factory() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T getInstance(String className, Class&lt;T&gt; tClass) &#123;</span><br><span class="line">        T instance = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            instance = (T) Class.forName(className).getDeclaredConstructor().newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">// write your code here</span><br><span class="line">        Imessage netMessage=Factory.getInstance(&quot;com.company.NetMessage&quot;,Imessage.class);</span><br><span class="line">        netMessage.send();</span><br><span class="line">        IService houseService=Factory.getInstance(&quot;com.company.HouseService&quot;,IService.class);</span><br><span class="line">        houseService.service();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的工厂设计模式将不再受限指定的接口，可以为所有的接口提供实例化服务</p>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/05/09/Java-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%8F%8D%E5%B0%84-%E6%B3%9B%E5%9E%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-多线程</title>
      <link>http://qiyanan.com/2019/05/02/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <guid>http://qiyanan.com/2019/05/02/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <pubDate>Wed, 01 May 2019 18:21:10 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在Java中，实现多线程一般有三种方式：&lt;/p&gt;
&lt;h1 id=&quot;继承Thread类，实现run-方法，调用start-方法，启动一个线程&quot;&gt;&lt;a href=&quot;#继承Thread类，实现run-方法，调用start-方法，启动一个线程&quot; class=&quot;headerlink&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在Java中，实现多线程一般有三种方式：</p><h1 id="继承Thread类，实现run-方法，调用start-方法，启动一个线程"><a href="#继承Thread类，实现run-方法，调用start-方法，启动一个线程" class="headerlink" title="继承Thread类，实现run()方法，调用start()方法，启动一个线程"></a>继承Thread类，实现run()方法，调用start()方法，启动一个线程</h1><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread myThreadA = new MyThread();</span><br><span class="line">        MyThread myThreadB = new MyThread();</span><br><span class="line">        MyThread myThreadC = new MyThread();</span><br><span class="line">        myThreadA.start();</span><br><span class="line">        myThreadB.start();</span><br><span class="line">        myThreadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实现Runnable接口，重写run-方法，并将此对象以参数的形式传给Thread对象，并调用Thread对象的start-方法，开启线程"><a href="#实现Runnable接口，重写run-方法，并将此对象以参数的形式传给Thread对象，并调用Thread对象的start-方法，开启线程" class="headerlink" title="实现Runnable接口，重写run()方法，并将此对象以参数的形式传给Thread对象，并调用Thread对象的start()方法，开启线程"></a>实现Runnable接口，重写run()方法，并将此对象以参数的形式传给Thread对象，并调用Thread对象的start()方法，开启线程</h1><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;我正在执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread myThread=new MyThread();</span><br><span class="line">        Thread threadA = new Thread(myThread, &quot;线程A&quot;);</span><br><span class="line">        Thread threadB = new Thread(myThread, &quot;线程B&quot;);</span><br><span class="line">        Thread threadC = new Thread(myThread, &quot;线程C&quot;);</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="实现Collable接口，重写Call-方法-并将它传让FutureTask对象内，再将FutureTask对象传入Thread对象内，调用Thread对象的start-方法开启线程"><a href="#实现Collable接口，重写Call-方法-并将它传让FutureTask对象内，再将FutureTask对象传入Thread对象内，调用Thread对象的start-方法开启线程" class="headerlink" title="实现Collable接口，重写Call()方法, 并将它传让FutureTask对象内，再将FutureTask对象传入Thread对象内，调用Thread对象的start()方法开启线程"></a>实现Collable接口，重写Call()方法, 并将它传让FutureTask对象内，再将FutureTask对象传入Thread对象内，调用Thread对象的start()方法开启线程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line">public class MyThread implements Callable&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(&quot;线程执行&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;线程执行完毕&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new MyThread());</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runnable-接口和Callable-的区别："><a href="#Runnable-接口和Callable-的区别：" class="headerlink" title="Runnable 接口和Callable 的区别："></a>Runnable 接口和Callable 的区别：</h2><ol><li>Runnable 是在JDK 1.0 的时候提出的多线程实现接口，而Callable是在JDK1.5 之后提出的；</li><li>java.lang.Runnable 接口之中只提供有一个run()方法，并且没有返回值；</li><li>java.util.concurrent Callable 接口提供有call() 方法，可以有返回值。<br><strong>想要实现多线程的启动，必须使用Thread类的start()方法</strong></li></ol>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/05/02/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-继承与组合</title>
      <link>http://qiyanan.com/2019/04/29/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/</link>
      <guid>http://qiyanan.com/2019/04/29/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/</guid>
      <pubDate>Mon, 29 Apr 2019 06:55:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;继承(inheritance)是指Child类的对象可以使用仅对Father类的对象有效的方法或者属性，它使得这些方法和属性就好像是Chil
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承(inheritance)是指Child类的对象可以使用仅对Father类的对象有效的方法或者属性，它使得这些方法和属性就好像是Child类自己定义的一样，此时Father类是Child类的父类，Child类是Father类的子类。在类结构中，父类的内部对于子类是可见的，所以，通过继承的代码复用是一种“白盒式代码复用”。</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>组合(composition)是指通过对现有的对象进行拼装(组合)产生新的更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以，称这种代码复用是“黑盒式代码复用”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Queue extends Array&#123;</span><br><span class="line">    // 继承</span><br><span class="line">&#125;</span><br><span class="line">class Queue extends Object&#123;</span><br><span class="line">    private Array asArray</span><br><span class="line">    //组合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/04/29/Java-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-OOP</title>
      <link>http://qiyanan.com/2019/04/29/Java-OOP/</link>
      <guid>http://qiyanan.com/2019/04/29/Java-OOP/</guid>
      <pubDate>Mon, 29 Apr 2019 06:33:33 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;什么是面向对象的程序设计？什么是面向过程的程序设计&quot;&gt;&lt;a href=&quot;#什么是面向对象的程序设计？什么是面向过程的程序设计&quot; class=&quot;headerlink&quot; title=&quot;什么是面向对象的程序设计？什么是面向过程的程序设计&quot;&gt;&lt;/a&gt;什么是面向对象的程序设
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="什么是面向对象的程序设计？什么是面向过程的程序设计"><a href="#什么是面向对象的程序设计？什么是面向过程的程序设计" class="headerlink" title="什么是面向对象的程序设计？什么是面向过程的程序设计"></a>什么是面向对象的程序设计？什么是面向过程的程序设计</h1><p>程序设计范型，开发程序发的方法，基于面向过程<br>面向过程：分析出解决问题所需要的步骤，使用函数把这些步骤实现，通过顺序执行一组组语句来实现一个个功能，这些语句的执行过程就是整个程序<br>例如：计算器程序，在main()函数里定义一系列的数据结构，然后开始写加减乘除等函数，实现功能<br>面向对象：抽象度更高，眼光集中在解决问题本身，他的目标是使模块的抽象度更高，实现可复用。<br>计算器创建一个Calculator类，在类里定义必要的数据成员，实现功能。</p><h1 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h1><p>万物皆对象，不但包括具体存在的，还包括抽象的规则，计划等。<br>对象具有状态，可以用数据来描述，例如：一个人，姓名：齐**，年龄：22，体重：65，身高：175等<br>对象具有行为，例如，运动，吃饭，睡觉，敲代码！！！</p><h1 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h1><p>具有相同或相似性质的对象的集合就是类，例如：人，学生，动物。。。<br>类具有属性：是对象的抽象，例如：姓名，年龄，体重。。。<br>类具有行为：是对对象行为的抽象。。。<br>抽象类：一般情况下，除了继承树的叶子节点以外，其他的所有类都是抽象类<br>具体类：继承树的叶子节点一般情况下是具体类</p><h1 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h1><p>通过类产生对象，叫做类的实例化，</p><ol><li>用关键字new<br>语法： 类 实例名 = new   类（）；</li><li>运用反射手段，调用java.long.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法。</li><li>运用对象的clone()方法</li><li>运用反序列化手段，调用java.io.ObjectInputStream 对象的 readObjet()方法。<br><strong>1 和2 都会明确的，显式的调用构造函数；3 是在内存上对已有对象的克隆，所以不会调用构造函数；4 是从文件中还原类的对象，也不会调用构造函数</strong></li></ol><h1 id="继承！！！"><a href="#继承！！！" class="headerlink" title="继承！！！"></a>继承！！！</h1><p>面向对象中类与类之间的一种关系，继承的类称为子类，派生类，而被继承的类称为父类，基类，或者超类，类与类继承之后，除了构造方法，子类具有父类的所有属性和方法，构造方法是调用，不是继承，同时子类可以加入新的属性或者方法。</p><h2 id="继承的设计原则：高内聚，低耦合，类的继承层数不能超过三层。"><a href="#继承的设计原则：高内聚，低耦合，类的继承层数不能超过三层。" class="headerlink" title="继承的设计原则：高内聚，低耦合，类的继承层数不能超过三层。"></a>继承的设计原则：高内聚，低耦合，类的继承层数不能超过三层。</h2><h2 id="如何让对象访问父类有参构造函数？？super"><a href="#如何让对象访问父类有参构造函数？？super" class="headerlink" title="如何让对象访问父类有参构造函数？？super"></a>如何让对象访问父类有参构造函数？？super</h2><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>概念：类将内部数据隐藏，为用户提供对象的属性和行为的接口，用户通过这些接口使用这些类，无需知道这些类内部是如何构成的，不能操作类中的内部数据<br>目的：防止对实现细节的访问<br>封装根据具体的需要，设置使用者的访问权限，并通过 访问修饰符 来实现。<br>一个访问修饰符 定义了一个类成员的范围和可见性。支持的访问修饰符如下所示：<br>Public 完全公开，没有访问限制，；<br>Private 私有成员，在类的内部可以使用，子类，实例都不能访问；<br>Protected 保护成员，该类的内部和继承类中可以访问</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>通过继承实现的不同对象调用相同的方法，表现出不同的行为，称之为多态</p><h1 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h1><p>接口就是一种特别的类。只需要定义函数，函数不用实现，<br>接口内定义的函数必须在子类里面全部得实现<br>可以实现多继承</p>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/04/29/Java-OOP/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-重载与重写</title>
      <link>http://qiyanan.com/2019/04/29/Java-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/</link>
      <guid>http://qiyanan.com/2019/04/29/Java-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/</guid>
      <pubDate>Mon, 29 Apr 2019 06:03:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;重载&quot;&gt;&lt;a href=&quot;#重载&quot; class=&quot;headerlink&quot; title=&quot;重载&quot;&gt;&lt;/a&gt;重载&lt;/h1&gt;&lt;p&gt;重载(overload) 指编写一个与已有函数同名但是函数参数不同的函数，重载不是一种面向对象的编程，而只是一种语法规则，重载与多态没有直接
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>重载(overload) 指编写一个与已有函数同名但是函数参数不同的函数，重载不是一种面向对象的编程，而只是一种语法规则，重载与多态没有直接关系。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol><li>相同的范围（在同一个类中）</li><li>函数名字相同</li><li>参数不同</li><li>virtual关键字可有可无</li></ol><h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><p>重写(override) 指派生类重写基类的虚函数，重写的函数必须有一致的参数表和返回值</p><h2 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h2><ol><li>不同的范围（分别位于派生类与基类）</li><li>函数名字相同</li><li>参数相同</li><li>基类函数必须有virtual关键字</li></ol>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/04/29/Java-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-成员内部类的访问方式</title>
      <link>http://qiyanan.com/2019/04/28/Java-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/</link>
      <guid>http://qiyanan.com/2019/04/28/Java-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/</guid>
      <pubDate>Sun, 28 Apr 2019 12:15:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;方式一：在外部提供一个方法创建内部类的对象进行访问。&quot;&gt;&lt;a href=&quot;#方式一：在外部提供一个方法创建内部类的对象进行访问。&quot; class=&quot;headerlink&quot; title=&quot;方式一：在外部提供一个方法创建内部类的对象进行访问。&quot;&gt;&lt;/a&gt;方式一：在外部提
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="方式一：在外部提供一个方法创建内部类的对象进行访问。"><a href="#方式一：在外部提供一个方法创建内部类的对象进行访问。" class="headerlink" title="方式一：在外部提供一个方法创建内部类的对象进行访问。"></a>方式一：在外部提供一个方法创建内部类的对象进行访问。</h2><h2 id="方式二：在其它类直接创建内部类的对象，格式：-内部类-变量名-new-外部类-内部类"><a href="#方式二：在其它类直接创建内部类的对象，格式：-内部类-变量名-new-外部类-内部类" class="headerlink" title="方式二：在其它类直接创建内部类的对象，格式： 内部类 变量名 = new 外部类().内部类();"></a>方式二：在其它类直接创建内部类的对象，格式： 内部类 变量名 = new 外部类().内部类();</h2><h2 id="内部类需要注意的细节"><a href="#内部类需要注意的细节" class="headerlink" title="内部类需要注意的细节:"></a>内部类需要注意的细节:</h2><ol><li><p>如果在外部类与内部类存在同名的成员变量时，在内部类中默认情况下是访问<strong>内部类中的成员变量</strong>，可以通过外部类.this.成员变量 来访问外部类的成员变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public int a = 1;</span><br><span class="line"></span><br><span class="line">    public class Tes &#123;</span><br><span class="line">        public int a = 3;</span><br><span class="line"></span><br><span class="line">        public void out() &#123;</span><br><span class="line">            System.out.println(&quot;内部类的a值：&quot; + a);</span><br><span class="line">            System.out.println(&quot;外部类的a值：&quot; + Test.this.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Test() &#123;</span><br><span class="line">        new Tes().out();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>私有的成员内部类只能在外部类提供一个方法创建内部类的对象进行访问，不能再其他类创建对象。</p></li><li>成员内部类一旦出现了静态成员，那么该类也必须使用static修饰。<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2>在一个类的方法内部定义了另外一个类，那么方法内的类称为局部内部类<br><strong>注意：如果局部内部类访问了局部变量，那么该变量需要用final修饰</strong></li></ol>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/04/28/Java-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java-Object类的方法</title>
      <link>http://qiyanan.com/2019/04/28/Java-Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <guid>http://qiyanan.com/2019/04/28/Java-Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Sun, 28 Apr 2019 11:51:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Object-基类的方法如下：&quot;&gt;&lt;a href=&quot;#Object-基类的方法如下：&quot; class=&quot;headerlink&quot; title=&quot;Object 基类的方法如下：&quot;&gt;&lt;/a&gt;Object 基类的方法如下：&lt;/h1&gt;&lt;h2 id=&quot;clone-创建并返回此对
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Object-基类的方法如下："><a href="#Object-基类的方法如下：" class="headerlink" title="Object 基类的方法如下："></a>Object 基类的方法如下：</h1><h2 id="clone-创建并返回此对象的一个副本。"><a href="#clone-创建并返回此对象的一个副本。" class="headerlink" title="clone(): 创建并返回此对象的一个副本。"></a>clone(): 创建并返回此对象的一个副本。</h2><h2 id="equals-Object-obj-指示某个其他对象是否和此对象“相等”。"><a href="#equals-Object-obj-指示某个其他对象是否和此对象“相等”。" class="headerlink" title="equals(Object obj): 指示某个其他对象是否和此对象“相等”。"></a>equals(Object obj): 指示某个其他对象是否和此对象“相等”。</h2><h2 id="finalize-当垃圾回收器确定不存在对该对象的的个更多引用时，由对象的垃圾回收器调用此方法。"><a href="#finalize-当垃圾回收器确定不存在对该对象的的个更多引用时，由对象的垃圾回收器调用此方法。" class="headerlink" title="finalize(): 当垃圾回收器确定不存在对该对象的的个更多引用时，由对象的垃圾回收器调用此方法。"></a>finalize(): 当垃圾回收器确定不存在对该对象的的个更多引用时，由对象的垃圾回收器调用此方法。</h2><h2 id="getClass-返回一个对象的运行时类。"><a href="#getClass-返回一个对象的运行时类。" class="headerlink" title="getClass(): 返回一个对象的运行时类。"></a>getClass(): 返回一个对象的运行时类。</h2><h2 id="hashCode-返回对象的哈希值。"><a href="#hashCode-返回对象的哈希值。" class="headerlink" title="hashCode(): 返回对象的哈希值。"></a>hashCode(): 返回对象的哈希值。</h2><h2 id="notify-唤醒在此对象监视器上等待的单个线程。"><a href="#notify-唤醒在此对象监视器上等待的单个线程。" class="headerlink" title="notify(): 唤醒在此对象监视器上等待的单个线程。"></a>notify(): 唤醒在此对象监视器上等待的单个线程。</h2><h2 id="notifyAll-：唤醒在此对象监视器上等待的所有线程。"><a href="#notifyAll-：唤醒在此对象监视器上等待的所有线程。" class="headerlink" title="notifyAll()：唤醒在此对象监视器上等待的所有线程。"></a>notifyAll()：唤醒在此对象监视器上等待的所有线程。</h2><h2 id="toString-返回该对象的字符串表示。"><a href="#toString-返回该对象的字符串表示。" class="headerlink" title="toString(): 返回该对象的字符串表示。"></a>toString(): 返回该对象的字符串表示。</h2><h2 id="wait-导致当前线程等待，直到其他线程调用此对象的notify-或者notifyAll-。"><a href="#wait-导致当前线程等待，直到其他线程调用此对象的notify-或者notifyAll-。" class="headerlink" title="wait(): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll()。"></a>wait(): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll()。</h2><h2 id="wait-long-timeout-导致当前线程等待，直到其他线程调用此对象的notify-或者notifyAll-或者超过指定的时间量。"><a href="#wait-long-timeout-导致当前线程等待，直到其他线程调用此对象的notify-或者notifyAll-或者超过指定的时间量。" class="headerlink" title="wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll(), 或者超过指定的时间量。"></a>wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll(), 或者超过指定的时间量。</h2><h2 id="wait-long-timeout-int-nanos-导致当前线程等待，直到其他线程调用此对象的notify-或者notifyAll-或者其他某个线程中断当前线程，或者超过指定的时间量。"><a href="#wait-long-timeout-int-nanos-导致当前线程等待，直到其他线程调用此对象的notify-或者notifyAll-或者其他某个线程中断当前线程，或者超过指定的时间量。" class="headerlink" title="wait(long timeout , int nanos): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll(), 或者其他某个线程中断当前线程，或者超过指定的时间量。"></a>wait(long timeout , int nanos): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll(), 或者其他某个线程中断当前线程，或者超过指定的时间量。</h2>]]></content:encoded>
      
      <comments>http://qiyanan.com/2019/04/28/Java-Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
