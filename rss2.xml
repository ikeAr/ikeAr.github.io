<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ike&#39;s blog</title>
    <link>https://qiyanan.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 05 Aug 2019 08:48:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C#-static关键字</title>
      <link>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <guid>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <pubDate>Mon, 05 Aug 2019 08:46:49 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-XML</title>
      <link>https://qiyanan.com/2019/08/04/C-XML/</link>
      <guid>https://qiyanan.com/2019/08/04/C-XML/</guid>
      <pubDate>Sun, 04 Aug 2019 06:34:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h1&gt;&lt;h2 id=&quot;XML基础&quot;&gt;&lt;a href=&quot;#XML基础&quot; class=&quot;headerlink&quot; title=&quot;XML基础&quot;&gt;&lt;/a&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="XML基础"><a href="#XML基础" class="headerlink" title="XML基础"></a>XML基础</h2><ol><li>XML是一种标记语言，与HTML很类似</li><li>XML的设计宗旨是持久化或传递数据，而非显示数据</li><li>XML标签没有被预定义，我们可以根据需要自行定义标签，具有自我描述性</li><li>XML本质上仅仅是才纯文本</li></ol><h2 id="XML模式"><a href="#XML模式" class="headerlink" title="XML模式"></a>XML模式</h2><p>XML文档可以用模式来描述，模式是另一个XML文件，描述了允许在一个特定的文档中使用的元素和特性</p><h2 id="XML文档对象模型"><a href="#XML文档对象模型" class="headerlink" title="XML文档对象模型"></a>XML文档对象模型</h2><p>常用的DOM类：<br>XmlNode: 这个类表示文档树中的一个节点，是许多类的基类，如果这个节点表示XML文档的根，就可以从它导航到文档的任意位置<br>XmlDocument: 扩展了XmlNode类，但通常是使用XML的第一个对象，因为这个类用于加载磁盘或其他地方的数据并在这些位置保存数据<br>XmlElement: 表示XML文档中的一个元素，XmlElement派生于XmlLinkedNode，XmlLinkedNode派生于XmlNode<br>XmlAttribute: 表示一个特性，与XmlDocument类一样，派生于XmlNode类<br>XmlText：表示开始标记和结束标记之间的文本<br>XmlNodeList: 标识一个节点集合</p><h3 id="XmlDocument"><a href="#XmlDocument" class="headerlink" title="XmlDocument"></a>XmlDocument</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var document = new XmlDocument();</span><br><span class="line">document.Load(@&quot;C:\地址&quot;);、//文件名是一个绝对路径</span><br></pre></td></tr></table></figure><h3 id="XmlElement"><a href="#XmlElement" class="headerlink" title="XmlElement"></a>XmlElement</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol><li>FirstChild<br>该属性返回当前节点之后的第一个子节点</li><li>LastChild<br>返回当前节点之后的最后一个子节点</li><li>ParentNode<br>返回当前节点的父节点</li><li>NextSibling<br>返回有相同父节点的下一个节点</li><li>HasChildNodes<br>检查当前元素是否有子元素，而不是必须获取FirstChild的值并检查是否为null</li></ol><h3 id="获取节点值"><a href="#获取节点值" class="headerlink" title="获取节点值"></a>获取节点值</h3><ol><li>InnerText 获取当前节点中所有子节点的文本，把它作为一个串联字符串返回</li><li>InnerXml 返回类似于InnerText的文本</li><li>Value Value属性是操作文档中信息的最精炼方式</li></ol><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ol><li>CreateNode<br>创建任意类型的节点，该方法有三个重载，两个允许创建XmlNodeType 枚举中所列出的类型，另一个允许把要使用的节点类型指定为字符串，</li><li>CreateElement<br>只能创建XmlElement类型的节点</li><li>CreateAttribute<br>只能创建XmlAttribute类型的节点</li><li>CreateTextNode<br>创建XmlTextNode类型的节点</li><li>CreatCommen<br>创建注释</li></ol><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><ol><li>AppendChild<br>把一个节点追加到XmlNode类型或派生类型的节点上</li><li>InsertAfter<br>可以控制插入新节点的位置，该方法有两个参数，第一个是新节点，第二个是在其后插入新节点的节点</li><li>InsertBefour<br>新节点在参考节点之后</li></ol><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ol><li>RemoveAll<br>删除节点之上的所有子节点，并且删除字典的特性</li><li>RemoveChild<br>删除节点上的一个子节点，返回从文档中删除的节点</li></ol><h3 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h3><ol><li>SelectSingleNode<br>选择一个节点</li><li>SelectNodes<br>以XmlNodeList类的形式返回一个节点集合</li></ol><h2 id="XML转换为JSON"><a href="#XML转换为JSON" class="headerlink" title="XML转换为JSON"></a>XML转换为JSON</h2><p>C# 系统库有限的支持JSON. 但是可以使用免费的第三方类库将XMl转换为JSON.</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/C-XML/#disqus_thread</comments>
    </item>
    
    <item>
      <title>GitHub使用技巧</title>
      <link>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <guid>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <pubDate>Sun, 04 Aug 2019 06:31:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;Git两大特点&quot;&gt;&lt;a href=&quot;#Git两大特点&quot; class=&quot;headerlink&quot; title=&quot;Git两大特点
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git两大特点"><a href="#Git两大特点" class="headerlink" title="Git两大特点"></a>Git两大特点</h2><ol><li>版本控制</li><li>分布式</li></ol><h2 id="git最基本操作"><a href="#git最基本操作" class="headerlink" title="git最基本操作"></a>git最基本操作</h2><p>初始化仓库：<br><code>git init</code><br>将一个文件添加到暂存区<br><code>git add code.txt</code><br>创建一个版本记录<br><code>git commit -m &#39;verson1&#39;(版本的说明信息)</code><br>查看版本记录<br><code>git log</code><br>版本回退<br><code>git reset --hard head^ /hard head~1-100</code><br>再次返回<br><code>git reset --hard 版本号</code><br>查看之前的操作记录<br><code>git reflog</code><br>查看当前文件状态<br><code>git status</code><br>未添加到暂存区之前撤销改动(增删改)<br><code>git checkout -- 文件名</code><br>撤销暂存区的修改<br><code>git reset HEAD file</code><br>对比文件不同</p><ol><li>工作区文件与版本文件对比<br>git diff HEAD – code.txt<br>–代表版本文件<br>++代表工作区文件</li><li>对比两个版本之间某个文件的不同<br>git diff HEAD HEAD^ – code.txt</li></ol><p>删除文件</p><ol><li>不放在暂存区<br>rm 文件名</li><li>放在暂存区<br>git rm 文件名</li></ol><h2 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h2><p>查看分支<br><code>git branch</code><br>创建分支<br><code>git branch 分支名</code><br>创建并切换一个新的分支<br><code>git checkout -b 分支名</code><br>切换分支<br><code>git checkout master</code><br>合并<br><code>git merge 分支名</code><br>删除分支<br><code>git branch -d 分支名</code><br>合并冲突(两个分支上同时提交且编辑同一个文件)</p><p><strong><em>每次操作暂存区内容都必须git commit 创建版本记录</em></strong></p><h2 id="工作区-Working-Directory"><a href="#工作区-Working-Directory" class="headerlink" title="工作区(Working Directory)"></a>工作区(Working Directory)</h2><p>电脑中的目录，就是一个工作区</p><h2 id="版本库-Repository"><a href="#版本库-Repository" class="headerlink" title="版本库(Repository)"></a>版本库(Repository)</h2><p>工作区有一个隐藏目录.git, 这个不是工作区，而是git的版本库<br>git的版本库里存了很多东西，其中最重要的就是称为stage的暂存区，还有git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-Lambda表达式</title>
      <link>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <guid>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <pubDate>Sun, 04 Aug 2019 06:26:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;p&gt;“Lambda表达式”是一个匿名函数，是一种高效的类似于函数式编程的表达式，Lamb
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>“Lambda表达式”是一个匿名函数，是一种高效的类似于函数式编程的表达式，Lambda简化了了开发中需要编写的代码量，它可以包含表达式和语句，并且可用于创建委托或表达式目录树类型，支持带有可绑定到委托或表达式树的输入参数的内联表达式。lambda表达式使用=&gt;运算符，该运算符读作”goes to”。Lambda运算符的左边是输入参数，右边是表达式或语句块。<br><code>x =&gt; x*x</code><br>可以将此表达式分配给委托类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delegate int del(int i);</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    del myDelegate = x =&gt; x * x;</span><br><span class="line">    int j = myDelegate(5); //j = 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目录树类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Linq.Expressions;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApplication1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Expression&lt;del&gt; myET = x =&gt; x * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表达式位于=&gt;运算符右侧的lambda表达式称为”表达式lambada”,表达式Lambda会返回表达式的结果，并采用以下基本形式<br><code>(input parameters) =&gt; expression</code><br>仅当lambda只有一个输入参数时，括号才是可选的；否则括号是必须的，括号内的两个或更多个输入参数使用逗号加以分隔；<br><code>(x, y) =&gt; x == y</code><br>有时，编译器难以或无法推断输入类型。如果出现这种情况，你可以显示指定类型<br><code>(int x, string s) =&gt; s.Length &gt; x</code><br>使用空括号指定零个输入参数：<br><code>() =&gt; SomeMethod()</code><br>当Lambada表达式中有多个语句时<br><code>(input paramenters) =&gt; {statement;}</code></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-LINQ</title>
      <link>https://qiyanan.com/2019/07/28/C-LINQ/</link>
      <guid>https://qiyanan.com/2019/07/28/C-LINQ/</guid>
      <pubDate>Sun, 28 Jul 2019 10:08:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;LINQ&lt;/strong&gt;&lt;br&gt;定义一个匿名类型对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = new {myTitle = &amp;quot;anonymous type&amp;quot;, myOtherParam = new int[] { 1, 2,
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>LINQ</strong><br>定义一个匿名类型对象：</p><pre><code>var obj = new {myTitle = &quot;anonymous type&quot;, myOtherParam = new int[] { 1, 2, 3, 4 } };</code></pre><p><strong>扩展函数：</strong></p><ol><li>扩展方法必须在一个非嵌套、非泛型的静态类中定义</li><li>扩展方法必须是一个静态方法</li><li>扩展方法至少要有一个参数</li><li>第一个参数必须附加this关键字作为前缀</li><li>第一个参数不能有其他修饰符（比如ref或者out）</li><li>第一个参数不能是指针类型</li></ol><p><strong>LINQ 查询操作符</strong><br>.net的设计者在类库中定义了一系列的扩展方法来方便用户操作集合对象，这些扩展方法构成了LINQ的查询操作符<br>扩展方法有Where, Max, Select, Sum, Any, Average, All, Concat等都是针对IEnumberable的对象进行扩展<br>基本LINQ查询操作</p><ol><li>获取数据源<br>在LINQ查询中，第一步是指定数据源，在LINQ查询中，先使用from子句引入数据源和范围变量</li><li>筛选<br>使用where子句生成结果，查询仅返回表达式为true的元素</li><li>中间件排序<br>orederby子句根据要排序类型的默认比较器，对返回序列中的元素排序，字符串比较顺序默认从A到Z进行排序，逆序使用orderby…descendingz子句</li><li>分组<br>group 子句用于对所获得的结果进行分组，使用group子句结束查询时，结果将以列表的形式列出，列表中的每个元素都是具有key成员的对象，列表中的元素根据该键杯分组，在循环访问生成组序列的查询时，必须使用嵌套foreach循环，外层循环访问每个组，内层循环访问每个组的成员，<br>如果必须引用某个组操作的结果，可使用into关键字创建能被进一步查询的标识符</li><li>联接<br>联接操作在不同序列间创建关联</li><li>选择(投影)<br>Select子句指定在执行查询时产生的值的类型，查询表达式必须以select子句或group子句结尾</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Customers&gt; customers = new List&lt;Customers&gt;() &#123;</span><br><span class="line">    new Customers&#123; Name = &quot;QIyanan&quot;, City = &quot;Gansu&quot;, Age = 16 &#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;IkeQi&quot;,City=&quot;USA&quot;,Age=18&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingQi&quot;,City=&quot;London&quot;,Age=20&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingZhang&quot;,City=&quot;London&quot;,Age=22&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingWang&quot;,City=&quot;London&quot;,Age=24&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingSun&quot;,City=&quot;London&quot;,Age=25&#125;&#125;;</span><br><span class="line">var result = from customer in customers</span><br><span class="line">             where customer.City == &quot;London&quot; &amp;&amp; customer.Name == &quot;kingQi&quot;</span><br><span class="line">             orderby customer.Age descending</span><br><span class="line">             select customer;</span><br><span class="line">var queryCustomersByCity = from cust in customers</span><br><span class="line">                           group cust by cust.City;</span><br><span class="line">foreach(var customerGroup in queryCustomersByCity)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(customerGroup.Key);</span><br><span class="line">    foreach(var customer in customerGroup)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;       &#123;customer.Name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foreach (var customer in result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(customer.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var studentQuery = from student in students</span><br><span class="line">                       where student.Scores[0] &gt; 90 &amp;&amp; student.Scores[3] &lt; 80</span><br><span class="line">                       orderby student.Scores[0] descending</span><br><span class="line">                       select student;</span><br><span class="line">    foreach (var student in studentQuery)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;    &#123;student.Last&#125;,     &#123;student.First&#125;,     &#123;student.Scores[0]&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery2 = from student in students</span><br><span class="line">                        group student by student.Last[0];</span><br><span class="line">    foreach (var studentGroup in studentQuery2)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(studentGroup.Key);</span><br><span class="line">        foreach (var student in studentGroup)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;        &#123;student.Last&#125;,   &#123;student.First&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery3 = from student in students</span><br><span class="line">                        group student by student.Last[0] into studentGroup</span><br><span class="line">                        orderby studentGroup.Key</span><br><span class="line">                        select studentGroup;</span><br><span class="line">    foreach (var groupOfStudents in studentQuery3)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(groupOfStudents.Key);</span><br><span class="line">        foreach (var student in groupOfStudents)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;     &#123;0&#125;,    &#123;1&#125;&quot;, student.Last, student.First);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery5 = from student in students</span><br><span class="line">                        let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3]</span><br><span class="line">                        where totalScore / 4 &lt; student.Scores[0]</span><br><span class="line">                        select student.Last + &quot;     &quot; + student.First;</span><br><span class="line">    foreach (string s in studentQuery5)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery6 = from student in students</span><br><span class="line">                        let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3]</span><br><span class="line">                        select totalScore;</span><br><span class="line">    double averageScore = studentQuery6.Average();</span><br><span class="line">    Console.WriteLine($&quot;Classaverage score = &#123;averageScore&#125;&quot;);</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery7 = from student in students</span><br><span class="line">                        where student.Last == &quot;Garcia&quot;</span><br><span class="line">                        select student.First;</span><br><span class="line">    Console.WriteLine(&quot;The garcias in the class are:&quot;);</span><br><span class="line">    foreach (string s in studentQuery7)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LINQ查询函数<br><strong>Where(); 查询结果过滤</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list0 = new List&lt;int&gt; &#123; 6, 4, 2, 7, 9, 0 &#125;;</span><br><span class="line">list0.Where(x =&gt; x &gt; 5);</span><br><span class="line">list0.Where(x =&gt; x &gt;= 1).Where(x =&gt; x &lt;= 5);</span><br><span class="line">list0.Where(x =&gt; x &gt;= 1 &amp;&amp; x &lt;= 5);</span><br></pre></td></tr></table></figure></p><p><strong>Select(), SelectMany();</strong><br>处理结果会传回一个对象，这个对象可以是现在对象，也可以是匿名类型<br>在LINQ语句中的select new语句，会自动被编译器转换Select()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Num = from a in list0</span><br><span class="line">          where a &gt; 3</span><br><span class="line">          select new</span><br><span class="line">          &#123;</span><br><span class="line">             Number = a</span><br><span class="line">          &#125;;</span><br><span class="line">Console.WriteLine(Num.FirstOrDefault().Number);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var selectNum = list0.Where(x =&gt; x &gt; 3).Select(x =&gt; new &#123; Number = x &#125;);</span><br></pre></td></tr></table></figure><p>SelectMany()类似于数据库中的CrossJoin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">List&lt;int&gt; list2 = new List&lt;int&gt;() &#123; 6, 4, 5, 7, 9, 0 &#125;;</span><br><span class="line">var query = list1.SelectMany(x =&gt; list2);</span><br><span class="line">foreach (var iterm in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(iterm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>GroupBy()</strong><br>会按照给定的key(keySelector)以及内容elementSelector,产生群组后的结果GroupBy()设置了使用数列本身作为Key值，并且利用这个Key分组产生分组的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5, 1, 5, 4, 3, 2, 5, 5, 5, 6, 2, 3, 6 &#125;;</span><br><span class="line">var query = list.GroupBy(x =&gt; x);</span><br><span class="line">foreach (var item in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;numer is  &#123;item.Key&#125;, numer has &#123;item.Count()&#125;&quot;);</span><br><span class="line">    foreach (var x in item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;           &#123;x&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ToLookUp()</strong><br>返回值是一个泛型Lookup&lt;TKey, TElement&gt;, 看起来和GroupBy()类似，但是Yolookup是立即执行，GroupBy是延迟执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var marrks = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123; Mark = 90, Group = &quot;A&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 80, Group = &quot;B&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 70, Group = &quot;C&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 60, Group = &quot;D&quot;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">var lookUpValue = marrks.ToLookup(x =&gt; x.Group);</span><br><span class="line">foreach(var item in lookUpValue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;=========Group:&#123;0&#125;===========&quot;,item.Key);</span><br><span class="line">    foreach(var result in item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(result.Group+&quot;   &quot;+result.Mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Join</strong><br>将两个集合进行连接，即数据库中的Inner Join<br>使用LINQ语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var Mark = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123;Name = &quot;C&quot; , Mark = 65&#125;,</span><br><span class="line">    new &#123;Name = &quot;A&quot; , Mark = 70&#125;,</span><br><span class="line">    new &#123;Name = &quot;B&quot; , Mark = 80&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">var Age = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123;Name = &quot;B&quot; , Age = 18&#125;,</span><br><span class="line">    new &#123;Name = &quot;C&quot; , Age = 17&#125;,</span><br><span class="line">    new &#123;Name = &quot;A&quot; , Age = 20&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var query = from mk in Mark</span><br><span class="line">            join ee in Age on mk.Name equals ee.Name</span><br><span class="line">            select new</span><br><span class="line">            &#123;</span><br><span class="line">                name = mk.Name,</span><br><span class="line">                mark = mk.Mark,</span><br><span class="line">                age = ee.Age</span><br><span class="line">            &#125;;</span><br><span class="line">foreach(var item in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;name &#123;item.name&#125;, Score &#123;item.mark&#125;, Age &#123;item.age&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用LINQ函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var quer1 = Mark.Join(Age, mk =&gt; mk.Name, ae =&gt; ae.Name, (mk, ae) =&gt; new &#123; name = mk.Name, mark = mk.Mark, age = ae.Age &#125;);</span><br><span class="line">foreach (var item in quer1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;name &#123;item.name&#125;,  score&#123; item.mark&#125;,  age&#123;item.age&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中Mark是第一个集合，Join方法的第一个参数Age是第二个集合，mk =&gt; mk.name 是 第一个集合的外键，ae=&gt;ae.Name是第二个集合的外键。<br><strong>GroupJoin;</strong><br>将两个集合进行联接，并对结果进行分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义国家类</span><br><span class="line">class Country</span><br><span class="line">&#123;</span><br><span class="line">    public string CountryName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义省类</span><br><span class="line">class Province</span><br><span class="line">&#123;</span><br><span class="line">    public Country OwnerCountry &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceName &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceSize &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceSpot &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//对国家类进行实例化</span><br><span class="line">Country c1 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;China&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c2 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;America&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c3 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;Korea&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c4 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;Russian&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//对省实例化</span><br><span class="line">Province p1 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Hunan&quot;,</span><br><span class="line">    ProvinceSize = &quot;200&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Old City&quot;,</span><br><span class="line">    OwnerCountry = c1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p2 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Chicago&quot;,</span><br><span class="line">    ProvinceSize = &quot;150&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Linkin Park&quot;,</span><br><span class="line">    OwnerCountry = c2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p3 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Seoul&quot;,</span><br><span class="line">    ProvinceSize = &quot;100&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Tian Tian World&quot;,</span><br><span class="line">    OwnerCountry = c3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p4 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Hunan&quot;,</span><br><span class="line">    ProvinceSize = &quot;200&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Tian Meng Mountain&quot;,</span><br><span class="line">    OwnerCountry = c1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p5 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Moscow&quot;,</span><br><span class="line">    ProvinceSize = &quot;80&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Moscow University&quot;,</span><br><span class="line">    OwnerCountry = c4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p6 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Moscow&quot;,</span><br><span class="line">    ProvinceSize = &quot;80&quot;,</span><br><span class="line">    ProvinceSpot = &quot;HelloWorld&quot;,</span><br><span class="line">    OwnerCountry = c4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义省集合</span><br><span class="line">List&lt;Province&gt; provinces = new List&lt;Province&gt;</span><br><span class="line">&#123;</span><br><span class="line">    p1,p2,p3,p4,p5,p6</span><br><span class="line">&#125;;</span><br><span class="line">//定义国家集合</span><br><span class="line">var countries = new List&lt;Country&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c1,c2,c3,c4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用Join连接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    //使用Join连接</span><br><span class="line">    var joinResult = countries.Join(provinces, country =&gt; country, province =&gt; province.OwnerCountry, (country, province) =&gt;</span><br><span class="line">    new</span><br><span class="line">    &#123;</span><br><span class="line">        countryName = country.CountryName,</span><br><span class="line">        provinceName = province.ProvinceName,</span><br><span class="line">        size = province.ProvinceSize,</span><br><span class="line">        spot = province.ProvinceSpot</span><br><span class="line">    &#125;);</span><br><span class="line">    foreach(var item in joinResult)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;countryName is &#123;item.countryName&#125; , provinceName is &#123;item.provinceName&#125; , size is &#123;item.size&#125;, spot is &#123;item.spot&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用GroupJoin</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var groupJoinResult = countries.GroupJoin(provinces, country=&gt;country, province =&gt; province.OwnerCountry, (country,province) =&gt; new</span><br><span class="line">&#123;</span><br><span class="line">    Name=country.CountryName,</span><br><span class="line">    ProvinceSet=province.Select(x=&gt;x)</span><br><span class="line">&#125;);</span><br><span class="line">foreach (var item in groupJoinResult)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Name);</span><br><span class="line">    foreach(var p in item.ProvinceSet)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(p.ProvinceName + &quot;  &quot; + p.ProvinceSize + &quot;  &quot; + p.ProvinceSpot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-LINQ/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-多线程</title>
      <link>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <pubDate>Sun, 28 Jul 2019 09:05:30 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;p&gt;什么是进程？&lt;br&gt;狭义定义：进程就是一段程序的执行过程&lt;br&gt;广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>什么是进程？<br>狭义定义：进程就是一段程序的执行过程<br>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，他是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元<br>进程的特点<br>动态性，并发性，独立性，异步性<br>进程的基本操作<br>获取进程<br><code>Process[] processes = Process.GetProcesses()；</code><br>启动进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProcessStartInfo psi = newProcessStartInfo();</span><br><span class="line">//设置psi属性</span><br><span class="line">//命令行参数</span><br><span class="line">Process newProcess = Process.Start(psi);</span><br></pre></td></tr></table></figure></p><p>杀掉进程：<br><code>Process.Close()//并非真正结束进程，释放进程所占用的资源</code><br><code>Process.Kill()//不建议使用</code><br><strong>什么是线程？</strong><br>线程，称为轻量级进程，是程序执行流的最小单元，一个标准的线程是由线程ID, 当前指令指针(PC), 寄存器集合和堆栈组成，线程是进程的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源<br><strong>多线程编程</strong><br><strong>.NET程序中基本的线程</strong></p><ol><li>Garbage collector 线程：用于垃圾回收</li><li>Finalizer线程：用于调度对象的Finalize方法</li><li>Main线程：程序的额入口线程</li><li>UI线程：用于更新渲染用户界面，存在于Windows Form, WPF, Windows Store类型的程序中</li></ol><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new Thread(Run); //创建</span><br><span class="line">t.Start(); //启动</span><br><span class="line">t.Name = &quot;Hello World&quot;; //设置线程名</span><br><span class="line">t.isBackground = true;//设置为后台进程, 随着进程的退出线程也退出</span><br><span class="line">Thread.Sleep(1000);//挂起当前线程</span><br><span class="line">t.Join();//阻塞当前线程，直到t线程结束</span><br><span class="line">t.Abort();终止t，无条件退出，报一个异常</span><br><span class="line">t.Interrupt();//当t处于Wait，Sleep或Join时，终止t，且会报一个异常</span><br><span class="line">Thread类构造函数可使用下面的delegate作为参数：</span><br><span class="line">ThreadStart:</span><br><span class="line">public delegate void ThreadStart();</span><br></pre></td></tr></table></figure><h2 id="线程池-ThreadPool"><a href="#线程池-ThreadPool" class="headerlink" title="线程池(ThreadPool)"></a>线程池(ThreadPool)</h2><p>创建线程需要时间和资源，如果有很多不同的小任务要起线程来完成，可以使用ThreaPool创建和管理这些线程，ThreadPool管理着一个线程列表，可以在需要时增减线程的数量，这个数量的上限和下限都是可匹配的，也可以重复利用线程。<br>和使用Thread类创建线程的方式不同，使用ThreadPool时，线程的创建，销毁以及并发线程数等因素皆有ThreadPool统一控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(WaitCallback callBack);</span><br><span class="line">ThreadPool.QueueUserWorkItem(WaitCallback callback, Object state);</span><br></pre></td></tr></table></figure></p><p><strong>使用ThreadPool时应注意</strong></p><ol><li>ThreadPool中的线程均为后台线程，不能改成前台线程</li><li>ThreadPool中的线程不能被显式退出或暂停</li><li>ThreadPool中的线程不能被显式的修改线程明和控制优先级</li><li>ThreadPool中的线程不能被显式Join，必须使用其他的同步资源手段达到这个目的</li><li>正常的线程运行结束后会被销毁，而ThreadPool中的线程会被重复利用</li><li>ThreadPool中线程不应该用于管理常驻线程或其他需要一直运行的线程，这种情况应该是使用Thread类穿件一个新的线程</li></ol><h2 id="Task类"><a href="#Task类" class="headerlink" title="Task类"></a>Task类</h2><p>Task是对ThreadPool进行一层抽象封装，旨在是开发专注于上层操作，不用关心底层Thread的控制</p><ol><li>Task具有很强的灵活性</li><li>可以指定连续的工作</li><li>可以区分执行任务的成功与否</li><li>可以创建依赖关系，将任务层次化<br><strong>两种表现形式：</strong><br>Task, Task<tresult>, 后者表示可以返回结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var tf = new TaskFactory();</span><br><span class="line">var t1 = tf.StartNew();</span><br></pre></td></tr></table></figure></tresult></li></ol><p><code>var t2 = Task.Factory.StartNew(TaskMethod);</code><br><code>var t3 = new Task(TaskMethod);</code><br><code>t3.Start();//表示异步启动</code><br><strong>Task连续执行</strong><br>Task t1 = new Task(DoOnFirst);<br>Task t2 = t1.ContinueWith(DoOnSecond);<br>Task t3 = t1.ContinueWith(DoOnSecond);<br>Task t4 = t2.ContinueWith(DoOnSecond);<br>Task t5 = t1.ContinueWith(DoOnError,TaskContinuationOptions,OnlyOnfaulted);<br>TaskContinuationOptions枚举参数：<br>OnlyOnFaulted, NotOnFaulted, OnlyOnCancled, NotOnCanceled,OnlyOnRanToToCompletion, ExcuteSynchronously…<br><strong>Task层次执行</strong><br>在父Task中创建一个子Task，就形成了层次依赖关系，父Task结束，则子Task也随着结束<br><strong>Task类常用方法</strong><br>ContinueWith: 创建一个在当前task执行结束后开始执行的新Task<br>Delay：创建一个在指定Delay时间后完成的Task<br>Run：返回一个压入ThreadPool的新Task<br>Start：开始一个Task<br>Wait：等待当前实例Task结束<br>WaitAll：等待所有Task结束<br>WaitAny：等待任意Task结束<br>WhenAll: 创建一个新的Task, 当被传作参数的所有Task都结束后，这个Task会被标识为结束<br>WhenAny: 创建一个新Task, 当被传作参数的任意Task结束后，这个Task会被标识为结束<br>CurrentId：获取当前正在执行的task ID<br><strong>Task类常用属性</strong><br>isCompleted: 判断当前task实例是否已经结束<br>isFaulted：判断当前task实例是否由于一个未捕获的异常而结束<br>Status：获取当前task实例的状态<br>IsCanceled: 判断当前task实例是否被取消<br>Exception：获取导致当前task结束的异常<br>Factory：返回一个Task的工厂用来创建新task<br>ID: 获取当前task实例ID</p><h2 id="异步委托"><a href="#异步委托" class="headerlink" title="异步委托"></a>异步委托</h2><p>如果要创建一个轻量级的线程，一种简单的办法是使用委托(Delegate), 并异步调用它。<br>委托通过线程池来完成异步任务<br><strong>可以使用不同的技术异步调用委托</strong></p><ol><li>Poll</li><li>AsyncWaitHandle</li><li>AsyncCallback</li></ol><p><strong>基本模型：</strong><br>IAsyncResult ar=delegate.BeginInvoke(…, AsyncCallback, …);<br>object obj = delegaye.EndInvoke(ar);<br>async和await关键字<br>async关键字：标识一个方法是异步的。<br>await关键字：用来等待一个异步方法的结果</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="进程内部的同步"><a href="#进程内部的同步" class="headerlink" title="进程内部的同步"></a>进程内部的同步</h3><ol><li><p>Lock //区域性加锁，内部实现基于Monitor </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Counter</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    private object thisLock = new object();</span><br><span class="line">    public void Increase()</span><br><span class="line">    &#123;</span><br><span class="line">        lock (thisLock)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Monitor<br>锁<br><code>Monitor.Enter(thisLock)</code><br>释放锁<br><code>Monitor.Exit(this.Lock);//建议写在finally块中</code></p></li><li>InterLocked //</li><li>AutoResetEvent类 //允许线程通过发信号互相通信<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AutoResetEvent are = new AutoResetEvent(false);</span><br><span class="line">are.WaitOne();//阻塞当前线程，等待信号量</span><br><span class="line">are.Set();//设置信号量，唤醒一个等待信号量的线程</span><br></pre></td></tr></table></figure></li></ol><h3 id="多个进程中线程的同步"><a href="#多个进程中线程的同步" class="headerlink" title="多个进程中线程的同步"></a>多个进程中线程的同步</h3><ol><li>WaitHandle</li><li>Mutex</li><li>Semaphore</li><li>Event</li><li>ReaderWriterLockSlim</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>所谓死锁是指两个或以上的进程在执行过程中，因正度资源而造成的一种互相等待的现象，若无外力作用，他们都无法推进下去。</p><h1 id="NET程序集"><a href="#NET程序集" class="headerlink" title=".NET程序集"></a>.NET程序集</h1><p>程序集，简单来说就是一个公共语言运行库(CLR)为宿主的，版本化的，自描述的二进制文件，<br><strong>程序集的构成：</strong></p><ol><li>程序集清单</li><li>元数据</li><li>实现这些类型的MSIL代码</li><li>资源集，诸如位图，指针，静态文本等。</li></ol><p><strong>程序集分类：</strong></p><ol><li>私有程序集（部署在本地）</li><li>共享程序集（部署在全局应用缓存——GAC)<h1 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h1>类库是一个综合性的面向对象的可重用类型集合，这些类库包括：接口，抽象类和具体类<br>类库不等于框架（Franework）<br>类库会在编译之后生成一个dll文件，其他项目可以引用 </li></ol><p>创建多线程的步骤：</p><ol><li>编写线程所要执行的方法</li><li>例化Thread类，并传入一个指向线程所要执行方法的委托。（这时线程已经产生，但还没有运行）</li><li>调用Thread实例的Start方法，标记该线程可以被CPU执行了，但具体执行时间由CPU决定</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">namespace ConsoleApp2</span><br><span class="line">&#123;</span><br><span class="line">    using System;</span><br><span class="line">    using System.Collections.Generic;</span><br><span class="line">    using System.Linq;</span><br><span class="line">    using System.Text;</span><br><span class="line">    using System.Threading;</span><br><span class="line">    using System.Threading.Tasks;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            var p1 = new ThreadTest();</span><br><span class="line">            var thread1 = new Thread(new ThreadStart(p1.Thread1)); //该代码可改写为var thread1 = new Thread(p1.Thread1);</span><br><span class="line">            var thread2 = new Thread(delegate () &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(&quot;I am created by anonymous function&quot;); &#125; &#125;);</span><br><span class="line">            var thread3 = new Thread(() =&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(&quot;i am created by Lambda expression&quot;); &#125; &#125;);</span><br><span class="line">            thread1.Start();</span><br><span class="line">            thread2.Start();</span><br><span class="line">            thread3.Start();</span><br><span class="line">            Console.ReadKey(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class ThreadTest</span><br><span class="line">    &#123;</span><br><span class="line">        public void Thread1()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;this is no parms function&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-多线程与Java-多线程异同："><a href="#C-多线程与Java-多线程异同：" class="headerlink" title="C# 多线程与Java 多线程异同："></a>C# 多线程与Java 多线程异同：</h1><p>都是通过Thread类来实现多线程<br>都是调用start方法来开启一个线程</p><h2 id="Java实现多线程一般有三种方法："><a href="#Java实现多线程一般有三种方法：" class="headerlink" title="Java实现多线程一般有三种方法："></a>Java实现多线程一般有三种方法：</h2><ol><li>继承Thread类,实现thread类里的run()方法</li><li>实现Runnable接口，重写run()方法，并将此对象以参数的形式传给Thread对象</li><li>实现Callable接口，重写Call()方法，并将此对象传给futureTask对象内，再将FutureTask对象作为参数传入Thread对象内。</li></ol><h2 id="C-实现多线程："><a href="#C-实现多线程：" class="headerlink" title="C# 实现多线程："></a>C# 实现多线程：</h2><ol><li>通过ThreadStart委托来实现多线程</li><li>使用匿名方法来实现多线程</li><li>使用Lambda表达式实现多线程</li><li>ThreeadPool实现多线程，只要执行完毕，自动退出<br><code>ThreadPool.QueueUserWorkItem(p1.Thread1);//委托的方法必须有一个Object类型的参数</code></li><li>Task实现多线程</li></ol>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-委托</title>
      <link>https://qiyanan.com/2019/07/28/C-%E5%A7%94%E6%89%98/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E5%A7%94%E6%89%98/</guid>
      <pubDate>Sun, 28 Jul 2019 03:14:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;委托&quot;&gt;&lt;a href=&quot;#委托&quot; class=&quot;headerlink&quot; title=&quot;委托:&quot;&gt;&lt;/a&gt;委托:&lt;/h1&gt;&lt;p&gt;委托就是具有相同返回值类型和参数的方法的抽象&lt;/p&gt;
&lt;h2 id=&quot;声明委托：&quot;&gt;&lt;a href=&quot;#声明委托：&quot; class=&quot;he
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="委托"><a href="#委托" class="headerlink" title="委托:"></a>委托:</h1><p>委托就是具有相同返回值类型和参数的方法的抽象</p><h2 id="声明委托："><a href="#声明委托：" class="headerlink" title="声明委托："></a>声明委托：</h2><p><code>delegate &lt;retutrn type&gt; 委托名(参数类型)</code><br>委托是一个特殊的类，需要实例化，凡是可以声明类的地方，都可以声明委托</p><h1 id="泛型委托："><a href="#泛型委托：" class="headerlink" title="泛型委托："></a>泛型委托：</h1><h2 id="Predicate-泛型委托"><a href="#Predicate-泛型委托" class="headerlink" title="Predicate 泛型委托"></a>Predicate 泛型委托</h2><p>表示的方法需要传入一个T类型的参数，并且返回一个bool类型的返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Predicate&lt;int&gt;(Compare);</span><br><span class="line">static bool Compare(int a)</span><br><span class="line">&#123;</span><br><span class="line">    var flag = false;</span><br><span class="line">    if (a &gt; 5)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = true;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Action-泛型委托"><a href="#Action-泛型委托" class="headerlink" title="Action 泛型委托"></a>Action 泛型委托</h2><p>参数0-16个，类型不确定。不能有返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Action&lt;int,string&gt;(Compare);</span><br><span class="line">static void Compare(int a,string b)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Func-泛型委托"><a href="#Func-泛型委托" class="headerlink" title="Func 泛型委托"></a>Func 泛型委托</h2><p>参数0-16个，类型不确定，必须有一个返回值，返回值为最后一个参数类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d1 = new Func&lt;int,string&gt;(Compare);</span><br><span class="line">static string Compare(int a)</span><br><span class="line">&#123;</span><br><span class="line">    return &quot;test Func&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h1><p>委托对象可使用“+”运算符进行合并，只有两个相同类型的委托可被合并<br>“-”运算符可用于从合并的委托中移除组件委托<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NumberChanger nc;</span><br><span class="line">var nc1 = new NumberChanger(AddNum);</span><br><span class="line">var nc2 = new NumberChanger(MultNum);</span><br><span class="line">nc = nc1;</span><br><span class="line">nc += nc2;</span><br><span class="line">nc(5);</span><br><span class="line">Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><code>Value of Num: 75</code><br>程序执行过程：<br>初始化两个委托nc1，nc2，实现委托的合并操作，执行nc(5)时，实际先执行AddNum(),执行之后紧接着执行MultNum()，因此，结果为75.</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E5%A7%94%E6%89%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-集合</title>
      <link>https://qiyanan.com/2019/07/28/C-%E9%9B%86%E5%90%88/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E9%9B%86%E5%90%88/</guid>
      <pubDate>Sun, 28 Jul 2019 02:59:19 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;集合-Collection&quot;&gt;&lt;a href=&quot;#集合-Collection&quot; class=&quot;headerlink&quot; title=&quot;集合(Collection)&quot;&gt;&lt;/a&gt;集合(Collection)&lt;/h1&gt;&lt;p&gt;ArrayList: 动态数组，需要装箱与拆箱&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合(Collection)"></a>集合(Collection)</h1><p>ArrayList: 动态数组，需要装箱与拆箱<br>List<t>: 与ArrayList类的泛型等效，性能提高</t></p><h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><h2 id="添加元素："><a href="#添加元素：" class="headerlink" title="添加元素："></a>添加元素：</h2><p>List.Add(T item); 添加一个元素<br>List.AddRange(IEnumerable<t> Collection); 添加一组元素<br>Insert(int index, T item); 在index位置添加一个元素<br>遍历List元素; 使用foreach进行遍历</t></p><h2 id="删除元素："><a href="#删除元素：" class="headerlink" title="删除元素："></a>删除元素：</h2><p>List.Remove(T item); 删除一个值<br>List.RemoveAt(int index); 删除下标为index的元素<br>List.RemoveRange(int index , int count); 从下标index开始，删除count个元素<br>List.Contains(T item); 判断某个元素是否在该List中<br>List.Sort(); 在List里面元素排序,默认是元素第一个字母按升序<br>List.Reverse(); 给List里面元素顺序反转<br>List.Clear(); 清空List<br>List.Count(); 获取元素数目：<br>List.Find(Predicate<t>match);搜索与指定谓词所定义的条件相匹配的元素，并返回整个List中的第一个匹配元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var list = new List&lt;string&gt;();</span><br><span class="line">string[] temArr = &#123; &quot;aq&quot;, &quot;qwe&quot;, &quot;qweqwr&quot;, &quot;wqeqw&quot;, &quot;ewq&quot;, &quot;aeqw&quot;, &quot;dad&quot;, &quot;a&quot; &#125;;</span><br><span class="line">list.AddRange(temArr);</span><br><span class="line">var str = list.Find(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        if (x.Length == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">Console.WriteLine(str);</span><br></pre></td></tr></table></figure></t></p><p>List.FindLast();搜索与指定谓词所定义的条件相匹配的元素，并返回整个List中的最后一个匹配元素<br>List.TrueForAll();确定是否List中的每个元素都与指定的谓词所定义的条件相匹配<br>List.FindAll();检查与指定谓词所定义的条件相匹配的所有元素<br>List.Take(n);获得前n行 返回值为IEnumetable<t>,T的类型与List<t>的类型一样<br>List.RemoveAll();移除与指定谓词所定义的条件相匹配的所有元素，返回删除的个数<br>Dictionary&lt;[key],[value]&gt;;提供快速的基于键值的元素查找,必须对键值类型进行说明<br>创建及初始化：<br><code>var myDictonary = new Dictionary&lt;int,string&gt;();</code><br>添加一个元素：<br><code>myDictonary.Add(1, &quot;C#&quot;);</code><br>通过Key查找元素：<br><code>myDictonary[1];</code></t></t></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E9%9B%86%E5%90%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-运算符重载</title>
      <link>https://qiyanan.com/2019/07/28/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
      <pubDate>Sun, 28 Jul 2019 02:49:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;运算符重载：重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。&lt;br&gt;&lt;figure class=&quot;hi
        
      
      </description>
      
      <content:encoded><![CDATA[<p>运算符重载：重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">    public double Length &#123; get; set; &#125;</span><br><span class="line">    public double Width &#123; get; set; &#125;</span><br><span class="line">    public double Heigth &#123; get; set; &#125;</span><br><span class="line">    public double GetVolume()</span><br><span class="line">    &#123;</span><br><span class="line">         return this.Length * this.Width * this.Heigth;</span><br><span class="line">    &#125;</span><br><span class="line">     public static Box operator +(Box b, Box c)</span><br><span class="line">    &#123;</span><br><span class="line">        var box = new Box();</span><br><span class="line">        box.Length = b.Length + c.Length;</span><br><span class="line">        box.Width = b.Width + c.Width;</span><br><span class="line">        box.Heigth = b.Heigth + c.Heigth;</span><br><span class="line">        return box;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var box1 = new Box();</span><br><span class="line">    box1.Length = 10;</span><br><span class="line">    box1.Width = 20;</span><br><span class="line">    box1.Heigth = 30;</span><br><span class="line">    var box2 = new Box();</span><br><span class="line">    box2.Length = 30;</span><br><span class="line">    box2.Width = 40;</span><br><span class="line">    box2.Heigth = 50;</span><br><span class="line">    var box3 = box1 + box2;</span><br><span class="line">    Console.WriteLine(box1.GetVolume());</span><br><span class="line">    Console.WriteLine(box2.GetVolume());</span><br><span class="line">    Console.WriteLine(box3.GetVolume());</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-文件操作</title>
      <link>https://qiyanan.com/2019/07/28/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <guid>https://qiyanan.com/2019/07/28/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Sun, 28 Jul 2019 02:37:48 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;File-I-O&quot;&gt;&lt;a href=&quot;#File-I-O&quot; class=&quot;headerlink&quot; title=&quot;File I/O&quot;&gt;&lt;/a&gt;File I/O&lt;/h1&gt;&lt;h2 id=&quot;Directory-类的常用属性&quot;&gt;&lt;a href=&quot;#Directory-类的常
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="File-I-O"><a href="#File-I-O" class="headerlink" title="File I/O"></a>File I/O</h1><h2 id="Directory-类的常用属性"><a href="#Directory-类的常用属性" class="headerlink" title="Directory 类的常用属性"></a>Directory 类的常用属性</h2><p><code>public System.IO.DirectoryInfo Directory { get; }</code><br><code>DirectoryName, Exists, isReadOnly, length(当前文件的的大小), Name</code></p><h2 id="Directory-类的常用方法"><a href="#Directory-类的常用方法" class="headerlink" title="Directory 类的常用方法:"></a>Directory 类的常用方法:</h2><p><strong>CreateDirectory()</strong><br>在指定路径中创建所有目录和子目录，除非他们已经存在， 如果该目录已存在，此方法不会创建一个新目录，但它将返回DirectoryInfo现有目录的对象。<br><strong>Delete()</strong><br>从指定路径删除空目录<br><strong>Delete(String, Boolean)</strong><br>删除指定的目录，并删除该目录所有的子目录和文件<br><strong>Move()</strong><br>移动目录<br><code>public static void Move (string sourceDirName, string destDirName)</code><br><strong>GetDirectories()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static string[] GetDirectories (string path);//返回路径中子目录的完整名称的数组, 如果未找到任何目录，则为空数组</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static string[] GetDirectories (string path, string searchPattern)</span><br></pre></td></tr></table></figure><p>string path: 相对路径或者绝对路径，此字符串不区分大小写<br>string searchPattern:  与path中的子目录的名称匹配的搜索字符串，此参数可以包含有效文本个通配符的组合，不支持正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var directory = Directory.GetDirectories(@&quot;c:\&quot;);</span><br><span class="line">foreach (var d in directory)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GetFiles()</strong><br>得到当前目录下所有文件<br><code>public static string[] GetFiles (string path)</code><br><strong>Exists()</strong><br>指向现有目录，则为true，如果该目录不存在或者在尝试确定指定目录是否存在时出错，则为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var directoryPath = @&quot;c:\test&quot;;</span><br><span class="line">var filePath = @&quot;MyTest.txt&quot;;</span><br><span class="line">if (!Directory.Exists(directoryPath))//尝试确定指定目录是否存在时，则为false</span><br><span class="line">&#123;</span><br><span class="line">    Directory.CreateDirectory(directoryPath);</span><br><span class="line">&#125;</span><br><span class="line">if (!File.Exists(Path.Combine(directoryPath,filePath)))</span><br><span class="line">&#123;</span><br><span class="line">    using (StreamWriter sw = File.CreateText(Path.Combine(directoryPath, filePath)))//文件夹路径必须存在，</span><br><span class="line">    &#123;</span><br><span class="line">        sw.WriteLine(&quot;hello&quot;);</span><br><span class="line">        sw.WriteLine(&quot;and&quot;);</span><br><span class="line">        sw.WriteLine(&quot;welcome&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">using (StreamReader sr = File.OpenText(Path.Combine(directoryPath, filePath)))</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    while ((s = sr.ReadLine()) != null)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DirectoryInfo类的常用属性"><a href="#DirectoryInfo类的常用属性" class="headerlink" title="DirectoryInfo类的常用属性:"></a>DirectoryInfo类的常用属性:</h2><p>Exists; FullNam; Name; Parent; Root;</p><h2 id="DirectoryInfo类的常用方法"><a href="#DirectoryInfo类的常用方法" class="headerlink" title="DirectoryInfo类的常用方法:"></a>DirectoryInfo类的常用方法:</h2><p>初始化：<br><code>var dir = new DirectoryInfo(Path);</code><br><strong>Create()</strong><br>创建一个空目录<br><strong>Delete()</strong><br><code>public override void Delete ();//若当前目录为空则删除</code><br><code>public void Delete (bool recursive);//指定是否删除子目录和文件</code><br><strong>CreateSubdirectory()</strong><br>在指定路径的基础上创建一个或多个子目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var direcotaryInfo = new DirectoryInfo(@&quot;c:\test\test\test&quot;);</span><br><span class="line">direcotaryInfo.CreateSubdirectory(&quot;text&quot;);</span><br></pre></td></tr></table></figure></p><p><strong>GetDirectories()</strong><br><code>public System.IO.DirectoryInfo[] GetDirectories ()</code><br><strong>GetFiles()</strong><br><code>public System.IO.FileInfo[] GetFiles ()</code><br><code>public System.IO.FileInfo[] GetFiles (string searchPattern);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach (var fi in di.GetFiles(&quot;*2*&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fi.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>MoveTo()</strong><br><code>public void MoveTo (string destDirName)</code></p><h2 id="File与FileInfo的区别："><a href="#File与FileInfo的区别：" class="headerlink" title="File与FileInfo的区别："></a>File与FileInfo的区别：</h2><p>File是静态类，所有方法都是静态的，可以通过类名直接调用，不需要实例化，如果对文件进行少量操作，或者对很多文件进行操作，建议使用<br>FileInfo是普通类，只有实例化对象之后才可以调用其中的方法，如果需要对一个文件进行大量操作，建议使用FileInfo</p><h2 id="File常用方法："><a href="#File常用方法：" class="headerlink" title="File常用方法："></a>File常用方法：</h2><p><strong>Create(string path)</strong><br><code>Delete(string path)// 删除文件应先判空</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (File.Exists(filePath))</span><br><span class="line">&#123;</span><br><span class="line">  File.Delete(filePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Move()</strong><br><code>public static void Move (string sourceFileName, string destFileName)</code><br><strong>Copy()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void Copy (string sourceFileName, string destFileName)//复制以后不允许覆盖同名文件</span><br></pre></td></tr></table></figure></p><p><strong>ReadAllText(string path)</strong><br><code>public static string ReadAllText(string path)//打开一个文件，读取所有的行，然后关闭文件</code><br><strong>ReadAllLines(string path)</strong><br><code>public static string[] ReadAllLines(string path)</code><br><strong>ReadLines(string path)</strong><br><code>public static IEnumerable&lt;string&gt; ReadLines(string path)</code><br><strong>ReadAllBytes(string path)</strong><br><code>public static byte[] ReadAllBytes(string path)</code></p><h2 id="FileInfo类常用属性"><a href="#FileInfo类常用属性" class="headerlink" title="FileInfo类常用属性"></a>FileInfo类常用属性</h2><p>初始化：<br><code>var fileinfo = new FileInfo(@&quot;C:\test\test\test.txt&quot;);//路径必须是文件</code></p><h2 id="FileInfo类的常用方法"><a href="#FileInfo类的常用方法" class="headerlink" title="FileInfo类的常用方法"></a>FileInfo类的常用方法</h2><p><strong>Create()</strong><br><code>public System.IO.FileStream Create ()</code><br><strong>Delete()</strong><br><code>public override void Delete ()</code><br><strong>MoveTo()</strong><br><code>public void MoveTo (string destFileName)    //将指定文件移到新位置，提供要指定新文件名的选项</code><br><strong>CopyTo()</strong><br><code>public System.IO.FileInfo CopyTo (string destFileName)//不允许覆盖源文件</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public System.IO.FileInfo CopyTo (string destFileName, bool overwrite)//可以覆盖源文件</span><br></pre></td></tr></table></figure></p><p>遍历一个目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void GetAllFiles(string directoryPath)</span><br><span class="line">&#123;</span><br><span class="line">    var rootDirectory = new DirectoryInfo(directoryPath);</span><br><span class="line">    foreach (var file in rootDirectory.GetFiles())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;File Name is &#123;file.Name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (var directory in rootDirectory.GetDirectories())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(directory.Name);</span><br><span class="line">        this.GetAllFiles(directory.FullName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="文件内容操作"></a>文件内容操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object——&gt;MarshalByRefObject——&gt;Stream——&gt;FileStream</span><br><span class="line">Object——&gt;MarshalByRefObject——&gt;TextReader——&gt;StreramReader</span><br><span class="line">Object——&gt;MarshalByRefObject——&gt;TextWriter——&gt;StreamWriter</span><br><span class="line">Object——&gt;MarshalByRefObject——&gt;TextReader——&gt;StringReader</span><br><span class="line">Object——&gt;MarshalByRefObject——&gt;TextWriter——&gt;StringWriter</span><br></pre></td></tr></table></figure><h2 id="Strean"><a href="#Strean" class="headerlink" title="Strean"></a>Strean</h2><p>流，提供了读写的方法是以字节码的形式从流中读取内容</p><h2 id="FileStream"><a href="#FileStream" class="headerlink" title="FileStream"></a>FileStream</h2><p>处理的是字节，继承Stream，一个FileStream类的实例实际代表一个文件流，使用FileStream类可以对文件系统上的文件 进行读取，写入，打开和关闭操作<br><code>public FileStream(string path, FileMode mode, FileAccess access);</code><br><strong>path</strong>指明文件搜所在路径信息<br><strong>mode</strong>是FileMode的枚举值，表示打开或者创建的方式<br>CreateNew 创建新文件，如果文件已存在，则IOExcepption<br>Create 创建新文件，文件已存在，源文件将被覆盖<br>Open 打开文件，如果文件不存在则报FileNoFoundException<br>OpenOrCreate 打开文件，文件不存在则创建文件<br>Truncate 打开已经存在的文件，清楚文件中的内容，保留文件的创建日期，如果文件不存在，则会跑出异常<br>Append 打开先有文件并把Position设置在文档尾部，如果文件不存在将创建新文件，Append只能同FileAccess.Writer 一起使用<br><strong>access</strong> 是FileAccess的枚举值，它控制对文件的访问权限<br>Read 打开文件用于只读<br>Write 打开文件用于读写<br>ReadWrite 打开文件用于读写<br>创建文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Create, FileAccess.Write);</span><br></pre></td></tr></table></figure></p><h2 id="FileStream-类中常用属性"><a href="#FileStream-类中常用属性" class="headerlink" title="FileStream 类中常用属性"></a>FileStream 类中常用属性</h2><p><strong>bool CanRead</strong> 表示是否可以读取<br><strong>bool CanSeek</strong> 表示是否支持查找<br><strong>bool CanWrite</strong> 表示是否可以写入<br><strong>bool IsAsync</strong> 表示是异步还是同步打开<br><strong>bool Length</strong> 获取用字节表示的流长度<br><strong>string Name</strong> 获取文件的全路径<br><code>int Read(byte[] array,int offset,int count) //从流中读取字节块并将数据写入给定缓冲区中</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Open, FileAccess.Read))</span><br><span class="line">&#123;</span><br><span class="line">    var array = new byte[fileStream.Length];</span><br><span class="line">    fileStream.Read(array, 0, array.Length);</span><br><span class="line">    var c = Encoding.UTF8.GetChars(array);</span><br><span class="line">    Console.WriteLine(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>void Write(byte[] array,int offset,int count) //将字节块写入文件流</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))</span><br><span class="line">&#123;</span><br><span class="line">    var name = &quot;qiyanan&quot;;</span><br><span class="line">    var arrayWrite = Encoding.UTF8.GetBytes(name);</span><br><span class="line">    fileStream.Write(arrayWrite, 0, arrayWrite.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StreamReader"><a href="#StreamReader" class="headerlink" title="StreamReader"></a>StreamReader</h2><p>处理的是字符，从流中读取字符<br><strong>构造函数</strong>：<br><code>StreamReader(Stream) //为指定的流初始化StreamReader类的新实例</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))</span><br><span class="line">&#123;</span><br><span class="line">    using (var streanReader = new StreamReader(fileStream))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StreamReader-String"><a href="#StreamReader-String" class="headerlink" title="StreamReader(String)"></a>StreamReader(String)</h2><p>为指定的文件名初始化StreamReader类的新实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using (var streamReader=new StreamReader(@&quot;c:\test\a.txt&quot;))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StreamReader-Stream-Encoding"><a href="#StreamReader-Stream-Encoding" class="headerlink" title="StreamReader(Stream, Encoding)"></a>StreamReader(Stream, Encoding)</h2><p>默认编码是Unicode, UTF-8是其子集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))</span><br><span class="line">&#123;</span><br><span class="line">    using (var streanReader = new StreamReader(fileStream, Encoding.GetEncoding(&quot;GB2312&quot;)))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>常用方法</strong><br><strong>Read()</strong><br>单字符读入<br><code>public override int Read (); //返回值为ascll码</code><br><strong>ReadLine()</strong><br>行读入<br><code>public override string ReadLine ()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using (var streanReader = new StreamReader(@&quot;C:\test\a.txt&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    string Ichar = null;</span><br><span class="line">    while ((Ichar=streanReader.ReadLine() )!= null)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Ichar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h2><p>从字符串读取字符</p><h2 id="StreamWriter"><a href="#StreamWriter" class="headerlink" title="StreamWriter"></a>StreamWriter</h2><p><code>public override void Write(string value)//字符串写入</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using (var streamWriter=new StreamWriter(@&quot;c:\test\a.txt&quot;,true))</span><br><span class="line">&#123;</span><br><span class="line">    var str = &quot;qi yanan is good  &quot;;</span><br><span class="line">    streamWriter.Write(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>public override void Write(char value) //字符写入</code><br><code>public override void Write(char[] buffer)//字符数组写入</code><br>public virtual void WriteLine () //写入空行，等同于跳到下一行<br>`</p><h2 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h2><p>字符串写入</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream:"></a>Stream:</h2><p>BufferedStream //提供针对Stream的包装功能，使Stream支持缓存读写功能<br>MemoryStream   //提供对内存中一块数据的读写<br>FileStream     //提供基本的对文件进行二进制流读写的功能，与文件的类型无关<br>UnmanagedMemoryStream //提供从托管代码访问非托管内存块的能力</p><h2 id="文件操作注意事项："><a href="#文件操作注意事项：" class="headerlink" title="文件操作注意事项："></a>文件操作注意事项：</h2><p>不要将文件流一次性读取到内存中，这样很容易造成内存泄漏<br>一定要保证文件流被关闭，可以使用using和try…finallya两种方式<br>用流读写数据时需要注意读写的长度是否准确，避免读写空字符<br>判断StreamReader是否读写结束不可直接判断读取string是否为空<br>StreamReader和StteramWriter是对文本的操作，应注明编码格式</p><h2 id="对内存中一块数据的读写"><a href="#对内存中一块数据的读写" class="headerlink" title="对内存中一块数据的读写"></a>对内存中一块数据的读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void ShowMemoryString(string testString)</span><br><span class="line">&#123;</span><br><span class="line">    using (MemoryStream stream = new MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        if (stream.CanWrite)</span><br><span class="line">        &#123;</span><br><span class="line">            byte[] buffer = Encoding.Default.GetBytes(testString);</span><br><span class="line">            stream.Write(buffer, 0, buffer.Length);</span><br><span class="line">            byte[] resultBuffer = stream.ToArray();</span><br><span class="line">            string resultString = Encoding.UTF8.GetString(resultBuffer);</span><br><span class="line">            Console.WriteLine(resultString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileStream对文件进行字节流读写的功能，与文件的类型无关"><a href="#FileStream对文件进行字节流读写的功能，与文件的类型无关" class="headerlink" title="FileStream对文件进行字节流读写的功能，与文件的类型无关"></a>FileStream对文件进行字节流读写的功能，与文件的类型无关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void ShowFileContent(string filePath)</span><br><span class="line">&#123;</span><br><span class="line">    FileStream fileStream = File.Open(filePath, FileMode.Open);</span><br><span class="line">    byte[] fileContentBuffer = new byte[fileStream.Length];</span><br><span class="line">    fileStream.Read(fileContentBuffer, 0, fileContentBuffer.Length);</span><br><span class="line">    fileStream.Close();</span><br><span class="line">    string fileContent = Encoding.Default.GetString(fileContentBuffer);</span><br><span class="line">    Console.WriteLine(fileContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用using语法糖省略文件流关闭操作"><a href="#使用using语法糖省略文件流关闭操作" class="headerlink" title="使用using语法糖省略文件流关闭操作"></a>使用using语法糖省略文件流关闭操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void ShowFileContent(string filePath)</span><br><span class="line">&#123;</span><br><span class="line">    byte[] fileContentBuffer;</span><br><span class="line">    using(FileStream fileStream = File.Open(filePath, FileMode.OpenOrCreate))</span><br><span class="line">    &#123;</span><br><span class="line">        fileContentBuffer = new byte[fileStream.Length];</span><br><span class="line">        fileStream.Read(fileContentBuffer,0,fileContentBuffer.Length);</span><br><span class="line">    &#125;</span><br><span class="line">    string fileContent = Encoding.Default.GetString(fileContentBuffer);</span><br><span class="line">    Console.WriteLine(fileContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分批次读入文件的内容"><a href="#分批次读入文件的内容" class="headerlink" title="分批次读入文件的内容"></a>分批次读入文件的内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void CopyFileContent(string sourceFilePath, string destinationFilePath)</span><br><span class="line">&#123;</span><br><span class="line">    using (FileStream destinationFileStream = File.Open(destinationFilePath, FileMode.Create, FileAccess.Write))</span><br><span class="line">    &#123;</span><br><span class="line">        const int bufferSize = 4 * 1024 * 1024;</span><br><span class="line">        byte[] fileContentBuffer = new byte[bufferSize];</span><br><span class="line">        using (FileStream sourceFileStream = File.Open(sourceFilePath, FileMode.Open, FileAccess.Read))</span><br><span class="line">        &#123;</span><br><span class="line">            int data;</span><br><span class="line">            do</span><br><span class="line">            &#123;</span><br><span class="line">                data = sourceFileStream.Read(fileContentBuffer, 0, fileContentBuffer.Length);</span><br><span class="line">                destinationFileStream.Write(fileContentBuffer, 0, data);</span><br><span class="line">            &#125; while (data &gt; 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileMode-定义了四种打开文件的方法："><a href="#FileMode-定义了四种打开文件的方法：" class="headerlink" title="FileMode 定义了四种打开文件的方法："></a>FileMode 定义了四种打开文件的方法：</h2><p>Append: 打开一个已有文件，并将光标放置在文件的末尾，如果文件不存在，则创建文件<br>Create: 创建一个新的文件，如果文件已存在，则删除旧文件，然后创建新文件<br>CreateNew：创建一个新文件，如果文件已存在，则抛出异常<br>Open：打开一个已有的文件，如果文件不存在，则抛出异常<br>FileAccess成员有Read, ReadWrite 和Write</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
