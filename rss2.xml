<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ike&#39;s blog</title>
    <link>https://qiyanan.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 09 Aug 2019 13:48:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>TypeScript-Basic Type</title>
      <link>https://qiyanan.com/2019/08/09/TypeScript-Basic%20Type/</link>
      <guid>https://qiyanan.com/2019/08/09/TypeScript-Basic%20Type/</guid>
      <pubDate>Fri, 09 Aug 2019 02:42:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Basic-Types&quot;&gt;&lt;a href=&quot;#Basic-Types&quot; class=&quot;headerlink&quot; title=&quot;Basic Types&quot;&gt;&lt;/a&gt;Basic Types&lt;/h1&gt;&lt;h2 id=&quot;布尔值&quot;&gt;&lt;a href=&quot;#布尔值&quot; class=&quot;he
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h1><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p><code>let isDone:boolean = false;</code></p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>(和JavaScript一样，TypeScript里的所有数字都是浮点型的，这些浮点类型是number)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0Xf00d;</span><br><span class="line">let binaryLiteral: number = 0b1010；</span><br><span class="line">let octaliteral: number = 0o744;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>(使用单引号或者双引号表示字符串)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name； string = &quot; bob&quot;;</span><br><span class="line">name = &quot;smith&quot;;</span><br></pre></td></tr></table></figure><p>可以使用模板字符串，也可以定义多行文本和内嵌表达式，这种字符串是被反引号包围( ` ), 并且以$( expr )这种形式嵌入表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name: string = `Gene` ;</span><br><span class="line">let age: number = 37;</span><br><span class="line">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class="line">I &apos;ll be $&#123; age+1 &#125; years old next month.`;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>在元素类型后面接上[],表示此类型组成的一个数组：<br><code>let list: number[] = {1,2,3};</code></p></li><li><p>使用数据泛型，Array&lt;元素类型&gt;<br><code>let list: Array&lt; number &gt; = {1,2,3};</code></p></li></ol><h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>(允许表示一个已知元素数量和类型的数组，各元素的类型不必相同)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Declare a tuple type</span><br><span class="line">let x: [string , number];</span><br><span class="line">//Initialize</span><br><span class="line">x = [&quot;hello&quot;, 10];//OK</span><br><span class="line">//Initialize it incorrectly</span><br><span class="line">x = [10,&apos;hello&apos;];//Error</span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log( x[0].substr(1));// OK</span><br><span class="line">console.log( x[1].substr(1));// Error,&apos;numbers&apos; does not have &apos;substr&apos;</span><br></pre></td></tr></table></figure><p><strong><em>当访问一个越界的元素，会使用联合类型替代：（联合类型是高级主题）</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[3] = &quot;world&quot;; // OK，字符串可以赋值给(string | sumber)类型</span><br><span class="line">console.log(x[5].toString());//OK，&apos;string&apos; 和&apos;number&apos;都有toString</span><br><span class="line">x[6] =true ;//Error,布尔不是(string | number)类型</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123; Red, Green,Blue&#125;</span><br><span class="line">let c: Coloe = Coleo.Green;</span><br></pre></td></tr></table></figure><p>默认情况下，从0开始为元素编号，也可以手动设置</p><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>(使类型检查器不对这些值检查直接让他们通过编译阶段)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any = 4; </span><br><span class="line">notSure = &quot;maybe a string instead&quot;; </span><br><span class="line">notSure = false;</span><br></pre></td></tr></table></figure><p>the <strong>any</strong> type is powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. you might expect Object to play a similar role, as it does in other languages. However, variables of type Object only allow you to assign any value to them. You can’tcall arbitrary methods on them, even ones that actually exist:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any = 4;</span><br><span class="line">notSure.ifitExists();//okay, ifitExists might exist at runtime</span><br><span class="line">notSure.toFixed();//Okay, toFixed exists</span><br></pre></td></tr></table></figure><p><img src="/2019/08/09/TypeScript-Basic Type/Any.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let prettySure: Object = 4;</span><br><span class="line">prettySure.ToFixed();//Error:Property &quot;toFind&quot; doesn&apos;t exist on type &apos;Object&apos;.</span><br></pre></td></tr></table></figure><p><img src="/2019/08/09/TypeScript-Basic Type/Object.png" alt="avatar"></p><p>The <strong>any</strong> type is also handy if you know some part of the type, You nay have an array but the array has a mix of different type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [1, true, &quot;free&quot;];</span><br><span class="line">list[1] = 100;</span><br></pre></td></tr></table></figure><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>void is a little like the opposite of any: the absence of having any type at all. You may commonly see this as the return type of function that do not return a value.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">    console.log(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Declaring variables of type void is not useful because you can only assign undefined or null them.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br><span class="line">let unKnow: void = null;</span><br></pre></td></tr></table></figure><h2 id="Null-and-Underfined"><a href="#Null-and-Underfined" class="headerlink" title="Null and Underfined"></a>Null and Underfined</h2><p>In TypeScript both undefined and null actually have thier own types named undefined and null respectively. Much like void, they’re not extremely useful on their own.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure><p>By default <strong>null</strong> and <strong>undefined</strong> are subtypespf all other types, that means you can assign <strong>null</strong> and <strong>undefined</strong> to something like number.<br>However when using the <strong>–strictNullChecks</strong> flag, <strong>null</strong> and <strong>undefined</strong> are only assignable to any and their respective type<br>(the one exception being that <strong>undefine</strong> is also assignabe to <strong>void</strong> ), this helps avoid many common errors. In case where you want to paa in either a string or null or undefined, you can use the union type string | null | undefined.<br><strong><em>As a note: we encourage the use of –strictNullChecks</em></strong></p><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>The <strong>never</strong> type represents the type of values that never occur. For instance, never is the return type for a function expression or arrow function expression that always throws an exception or one that never returns, Variables also acquire the type never when narrowed by any type guards that can never be true.<br>The never type is a subtype of , and assignable to, every type; however, no type is a subtype of or assignable to never(except never itself), Even any isn’t assignable to never </p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>object is a type that represents the non-primitive type, anything  that is not number, string, boolean, symbol, null, or undefined.<br>With object type, APIs like object.create can be better represnted. for ecample:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line">create(&#123; prop: 0 &#125;);OK</span><br><span class="line">create(null);OK</span><br><span class="line">create(42);//Error</span><br><span class="line">create(&quot;string&quot;);//Error</span><br><span class="line">create(false);//error</span><br><span class="line">create(undefined);//Error</span><br></pre></td></tr></table></figure><h2 id="Type-assertions"><a href="#Type-assertions" class="headerlink" title="Type assertions"></a>Type assertions</h2><pre><code>- Type assertions have two forms. One is the &quot;angle-bracket&quot;syntax:</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string &quot;;</span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br></pre></td></tr></table></figure><pre><code>- The other is the as -syntax:</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let somevalue: any=&quot;this is a string&quot;; </span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure><p><strong>when using typeScript with JSX, only as -style assertions are allowed.</strong></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/09/TypeScript-Basic%20Type/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-浅度复制与深度复制</title>
      <link>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/</guid>
      <pubDate>Tue, 06 Aug 2019 08:14:26 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;浅度复制和深度复制&quot;&gt;&lt;a href=&quot;#浅度复制和深度复制&quot; class=&quot;headerlink&quot; title=&quot;浅度复制和深度复制&quot;&gt;&lt;/a&gt;浅度复制和深度复制&lt;/h1&gt;&lt;h2 id=&quot;浅度复制&quot;&gt;&lt;a href=&quot;#浅度复制&quot; class=&quot;headerli
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="浅度复制和深度复制"><a href="#浅度复制和深度复制" class="headerlink" title="浅度复制和深度复制"></a>浅度复制和深度复制</h1><h2 id="浅度复制"><a href="#浅度复制" class="headerlink" title="浅度复制"></a>浅度复制</h2><p>浅度复制指按照引用复制对象<br>简单的按照成员复制对象可以通过派生于System. Object的MemberwiseClone()方法来完成，这是一个受保护的方法，这个方法提供的复制功能称为浅度复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Content </span><br><span class="line">&#123;</span><br><span class="line">    public int val;</span><br><span class="line">&#125;</span><br><span class="line">public class Cloner </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public Cloner(int newVal) =&gt; MyContent.val = newVal;</span><br><span class="line">    public object GetCopy() =&gt; MemberwiseClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cloner mySource = new Cloner(5);</span><br><span class="line">Cloner myTarget = (Cloner) mySource.GetCopy();</span><br><span class="line">Console.WriteLine($ &quot;myTarget.MyContent.Val=&#123;myTarget.MyContent.val&#125;&quot;);</span><br><span class="line">mySource.MyContent.val = 2;</span><br><span class="line">Console.WriteLine($ &quot;myTarget.MyContent.Val=&#123;myTarget.MyContent.val&#125;&quot;);</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><h2 id="深度复制"><a href="#深度复制" class="headerlink" title="深度复制"></a>深度复制</h2><p>复制的是一个对象的值<br>可以实现一个ICloneable接口，以标准方式进行深度复制，如果使用这个接口，就必须实现它包含的Clone()方法，这个方法返回一个System. Object的值，我们可以采用各种处理方式，实现所选的任何一个方法体来得到这个对象，如果愿意就可以进行深度复制，但不是必须的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Cloner: ICloneable </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public Cloner(int newVal) =&gt; MyContent.val = newVal;</span><br><span class="line"></span><br><span class="line">    public object Clone() </span><br><span class="line">    &#123;</span><br><span class="line">        Cloner clonedCloner = new Cloner(MyContent.val);</span><br><span class="line">        return clonedCloner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //public object GetCopy() =&gt; MemberwiseClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意在比较复杂的对象系统中，调用Clone是一个递归过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Cloner: ICloneable </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public object Clone() </span><br><span class="line">    &#123;</span><br><span class="line">        Cloner clonedCloner = new Cloner();</span><br><span class="line">        clonedCloner.MyContent = MyContent.Clone();</span><br><span class="line">        return clonedCloner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-迭代器</title>
      <link>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <pubDate>Tue, 06 Aug 2019 08:11:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;p&gt;只要实现了IEnumerable接口，就可以使用foreach循环&lt;br&gt;在foreach循环中，迭代一个collectionObj
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>只要实现了IEnumerable接口，就可以使用foreach循环<br>在foreach循环中，迭代一个collectionObject集合的过程如下：</p><ol><li>调用collectionObject. GetEnumerator(), 返回一个IEnumerator引用，这个方法可通过IEnumerable接口的实现代码来获得，但这是可选的。</li><li>调用所返回的IEnumerator接口的MoveNext()方法。</li><li>如果MoveNext() 方法返回true，就使用IEnumerator接口的Current属性来获取对象的一个引用，用于foreach循环</li><li>重复前面两步，直到MoveNext()方法返回false为止，此时循环停止</li></ol><h2 id="IEnumerable和IEnumerator使用场景："><a href="#IEnumerable和IEnumerator使用场景：" class="headerlink" title="IEnumerable和IEnumerator使用场景："></a>IEnumerable和IEnumerator使用场景：</h2><ol><li>如果要迭代一个类，则使用方法GetEnumerator(), 其返回类型是IEnumerator。</li><li>如果要迭代一个类成员，例如一个方法，则使用IEnumerable。</li></ol><p><strong>在迭代器块中，使用yield关键字选择要在foreach循环中使用的值</strong><br><code>yield return &lt; value &gt;;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Program </span><br><span class="line">&#123;</span><br><span class="line">    public static IEnumerable SimpleList() </span><br><span class="line">    &#123;</span><br><span class="line">        yield return &quot;string 1&quot;;</span><br><span class="line">        yield return &quot;string 2&quot;;</span><br><span class="line">        yield return &quot;string 3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args) </span><br><span class="line">    &#123;</span><br><span class="line">        foreach(var x in SimpleList()) </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Program </span><br><span class="line">&#123;</span><br><span class="line">    private long min;</span><br><span class="line">    private long max;</span><br><span class="line">    public Program(): this(2, 100) &#123;&#125;</span><br><span class="line">    public Program(long minimum, long maxinum) </span><br><span class="line">    &#123;</span><br><span class="line">        if (minimum &lt; 2) </span><br><span class="line">        &#123;</span><br><span class="line">            min = 2;</span><br><span class="line">        &#125; else </span><br><span class="line">        &#123;</span><br><span class="line">            min = minimum;</span><br><span class="line">        &#125;</span><br><span class="line">        max = maxinum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IEnumerator GetEnumerator() </span><br><span class="line">    &#123;</span><br><span class="line">        for (var possiblePrime = min; possiblePrime &lt;= max; possiblePrime++) </span><br><span class="line">        &#123;</span><br><span class="line">            bool isPrime = true;</span><br><span class="line">            for (var possibleFactor = 2; possibleFactor &lt;= (long) Math.Floor(Math.Sqrt(possiblePrime)); possibleFactor++) </span><br><span class="line">            &#123;</span><br><span class="line">                var remainderAfterDivision = possiblePrime % possibleFactor;</span><br><span class="line">                if (remainderAfterDivision == 0) </span><br><span class="line">                &#123;</span><br><span class="line">                    isPrime = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (isPrime) </span><br><span class="line">            &#123;</span><br><span class="line">                yield</span><br><span class="line">                return possiblePrime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void Main(string[] args) </span><br><span class="line">    &#123;</span><br><span class="line">        var primeFrom2to1000 = new Program(55, 100);</span><br><span class="line">        foreach(long i in primeFrom2to1000) </span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write($ &quot;&#123;i&#125;   &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器和集合"><a href="#迭代器和集合" class="headerlink" title="迭代器和集合"></a>迭代器和集合</h2><p>在字典类型的集合中的对象使用迭代器进行迭代存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Animal: DictionaryBase </span><br><span class="line">&#123;</span><br><span class="line">    public void Add(string newID, Animal newAnimal) </span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary.Add(newID, newAnimal);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Delete(string animalID) </span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary.Remove(animalID);</span><br><span class="line">    &#125;</span><br><span class="line">    public Animal this[string animalID] //声明索引器</span><br><span class="line">    &#123;</span><br><span class="line">        get </span><br><span class="line">        &#123;</span><br><span class="line">            return (Animal) Dictionary[animalID];</span><br><span class="line">        &#125;</span><br><span class="line">        set </span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary[animalID] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可在这段代码中添加如下的简单迭代器，以便执行预期操作(对子类特有的操作)：//<strong>不加此方法，程序在编译的时候可以编译过去，但是会在运行时报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public new IEnumerator GetEnumerator() </span><br><span class="line">&#123;</span><br><span class="line">    foreach(object animal in Dictionary.Values) </span><br><span class="line">    &#123;</span><br><span class="line">        yield</span><br><span class="line">        return (Animal) animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可使用下面的代码来迭代集合中的Animal对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var animal1 = new Animal();</span><br><span class="line">animal1.Add(&quot;01&quot;, new Animal() </span><br><span class="line">&#123;</span><br><span class="line">    Name = &quot;dog&quot;</span><br><span class="line">&#125;);</span><br><span class="line">animal1.Add(&quot;02&quot;, new Animal());</span><br><span class="line">animal1.Add(&quot;03&quot;, new Animal());</span><br><span class="line">animal1.Add(&quot;04&quot;, new Animal());</span><br><span class="line">foreach(Animal a in animal1) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-特性和预编译指令</title>
      <link>https://qiyanan.com/2019/08/06/C-%E7%89%B9%E6%80%A7%E5%92%8C%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E7%89%B9%E6%80%A7%E5%92%8C%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/</guid>
      <pubDate>Tue, 06 Aug 2019 08:09:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;特性-Attribute&quot;&gt;&lt;a href=&quot;#特性-Attribute&quot; class=&quot;headerlink&quot; title=&quot;特性(Attribute)&quot;&gt;&lt;/a&gt;特性(Attribute)&lt;/h1&gt;&lt;p&gt;特性(Attribute) 是用于在运行时传递程序中各种
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="特性-Attribute"><a href="#特性-Attribute" class="headerlink" title="特性(Attribute)"></a>特性(Attribute)</h1><p>特性(Attribute) 是用于在运行时传递程序中各种元素(比如类，方法，结构，枚举，组件等)的行为信息的声明性标签，. NET框架提供了两种类型的特性：预定义特性和自定义特性<br>. NEt提供了三种预定义特性：</p><ol><li>AttributeUsage</li></ol><p><code>[AttributeUsage( validon, AllowMultiple=allowmultiple, Inherited=inherited)]</code><br>validon 规定特性可被放置的语言元素，它是枚举器AttributeTargets的值的组合，默认值是AttributeTarget. All<br>allowmultiple(可选)为该特性的AllowMultiple属性(property)提供一个布尔值，表示在一个地方能否被多次使用<br>inherited(可选的)为该特性的提供一个布尔值，表示该特性可否被派生类所继承</p><ol start="2"><li>Conditional</li></ol><p>标记了一个条件方法，它会引起方法调用的条件编辑，取决于指定的值，比如Debug和Trace<br><code>[Conditional( conditionalSymbol)]</code><br>使用Conditional是封闭#if和#endif内部方法的替代方法<br>条件方法受到以下限制</p><pre><code>-条件方法必须是类声明或结构声明中的方法，如果在接口声明中的方法上指定Conditional属性，将出现编译时错误-条件方法必须有返回值-不能用override修饰符标记条件方法，凡是，可以用virtual修饰符标记条件方法-条件方法不能是接口方法的实现-如果条件方法用在“委托创建表达式”中，也会发生编译时错误</code></pre><ol start="3"><li>Obsolete</li></ol><p><code>[Obsolete(&quot; 方法提示 &quot;, bool )]//标注方法为过期方法, bool 表示调用以后编译器是否报错，true 表示报错。</code></p><h1 id="C-中的预编译指令"><a href="#C-中的预编译指令" class="headerlink" title="C#中的预编译指令"></a>C#中的预编译指令</h1><ol><li>#define 和#undef</li></ol><p>`</p><p>#define DEBUG<br><code>告诉编译器存在给定名称的符号，类似于声明一个变量，这个变量没有真正的值，只是存在而已，这个符号不是实际代码的一部分，而只在编译器编译黛玛诗存在，在C#中没有任何意义</code></p><p>#undef DEBUG<br>`<br>如果符号不存在，#undef没有任何作用，如果符号已存在，则#define也不起作用，必须把#define和#undef命令放在C#源文件的开头为止，在声明要编译的任何对象的代码之前，#define本身没有什么用，但与其他预处理指令(特别是#if)结合使用时，它的功能就非常强大了。</p><ol start="2"><li>#if、#elif、#else 和#endif</li></ol><p>这些指令告诉编译器是否要编译某个代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int DoSomeWork(double x) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    if DEBUG</span><br><span class="line">    Console.WriteLine(&quot;x is &quot; + x);#</span><br><span class="line">    endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只有前面的#define命令定义了符号DEBUG后才执行</p><ol start="3"><li>#warning 和 #error</li></ol><p>当编译器遇到他们时，会分别产生警告或错误。如果编译器遇到#warning指令，会给用户显示#warnong指令后面的文本，之后编译继续执行，如果编译器遇到#error指令，就会给用户显示后面的文本，作为一条编译错误消息，然后立即退出编译，不会产生IL代码</p><ol start="4"><li>#region 和#endregion</li></ol><p>用于吧一段代码标记为有给定名称的一个快</p><ol start="5"><li>#line</li></ol><p>改变编译器在警告个错误信息中显示的文件名和行号信息</p><ol start="6"><li>#pragma</li></ol><p>抑制或还原指定的编译警告，可以在累活方法级别执行</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E7%89%B9%E6%80%A7%E5%92%8C%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-反射</title>
      <link>https://qiyanan.com/2019/08/06/C-%E5%8F%8D%E5%B0%84/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E5%8F%8D%E5%B0%84/</guid>
      <pubDate>Tue, 06 Aug 2019 08:04:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是元数据，什么是反射？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序是用来处理数据的，文本和特性都是数据数据，而我们
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>什么是元数据，什么是反射？</strong></p><ol><li>程序是用来处理数据的，文本和特性都是数据数据，而我们程序本身（类的定义和BCL中的类）这些都是数据</li><li>有关程序及其类型的数据被称为元数据(metadata), 他们保存在程序的程序集中。</li><li>程序在运行时，可以查看其它程序集或其本身的元数据。一个运行的程序查看本身的元数据或者其它程序集的元数据的行为叫做反射</li></ol><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p>BCL 声明了一个叫做Type的抽象类，它被设计用来包含类型的特性，使用这个类的对象能让我们获取程序使用的类型的信息。</p><ol><li>由于Type是抽象类，因此不能利用它去实例化对象，</li><li>对于程序中用到的每一个类型，CLR都会创建一个包含这个类型信息的Type类型的对象</li><li>程序中用到的每一个类型都会关联到独立的Type类的对象</li><li>不管创建的类型有多少个示例，只有一个Type对象会关联到所有这些实例</li></ol><h2 id="获取Type对象"><a href="#获取Type对象" class="headerlink" title="获取Type对象"></a>获取Type对象</h2><ol><li>通过类的实例来获取Type对象</li></ol><p><code>Type t = myInstance. GetType()</code><br>在object类有一个GetType的方法，返回Type对象，因为所有类都是从object继承的，所以我们可以在任何类型上使用GetType()来获取它的Type对象</p><ol start="2"><li>通过typeof 运算符合类名获取Type对象</li></ol><p><code>Type t= typeof(ClassName)</code></p><h3 id="获取里面的字段"><a href="#获取里面的字段" class="headerlink" title="获取里面的字段"></a>获取里面的字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo() fi = t.GetFields(); //只能获取public字段</span><br><span class="line">foreach(FieldInfo f in fi) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(f.Name + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取里面的属性"><a href="#获取里面的属性" class="headerlink" title="获取里面的属性"></a>获取里面的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PropertyInfo[] fi = t.GetProperties(); //只能获取public字段</span><br><span class="line">foreach(PropertyInfo f in fi)</span><br><span class="line"> &#123;</span><br><span class="line">    Console.WriteLine(f.Name + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取里面的方法"><a href="#获取里面的方法" class="headerlink" title="获取里面的方法"></a>获取里面的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo[] fi = t.GetMethods(); //只能获取public字段</span><br><span class="line">foreach(MethodInfo f in fi) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(f.Name + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取Assembly对象"><a href="#获取Assembly对象" class="headerlink" title="获取Assembly对象"></a>获取Assembly对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass my = new MyClass();</span><br><span class="line">Assenbly assem = my.GetType().Assembly; //通过累的type对象获取他所在的程序集Assembly</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E5%8F%8D%E5%B0%84/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-static关键字</title>
      <link>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <guid>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <pubDate>Mon, 05 Aug 2019 08:46:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;静态类&quot;&gt;&lt;a href=&quot;#静态类&quot; class=&quot;headerlink&quot; title=&quot;静态类&quot;&gt;&lt;/a&gt;静态类&lt;/h1&gt;&lt;p&gt;静态类与非静态类的重要区别在于静态类不能被shi’li’hu&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h1><p>静态类与非静态类的重要区别在于静态类不能被shi’li’hu</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/05/C-static%E5%85%B3%E9%94%AE%E5%AD%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-XML</title>
      <link>https://qiyanan.com/2019/08/04/C-XML/</link>
      <guid>https://qiyanan.com/2019/08/04/C-XML/</guid>
      <pubDate>Sun, 04 Aug 2019 06:34:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h1&gt;&lt;h2 id=&quot;XML基础&quot;&gt;&lt;a href=&quot;#XML基础&quot; class=&quot;headerlink&quot; title=&quot;XML基础&quot;&gt;&lt;/a&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="XML基础"><a href="#XML基础" class="headerlink" title="XML基础"></a>XML基础</h2><ol><li>XML是一种标记语言，与HTML很类似</li><li>XML的设计宗旨是持久化或传递数据，而非显示数据</li><li>XML标签没有被预定义，我们可以根据需要自行定义标签，具有自我描述性</li><li>XML本质上仅仅是才纯文本</li></ol><h2 id="XML模式"><a href="#XML模式" class="headerlink" title="XML模式"></a>XML模式</h2><p>XML文档可以用模式来描述，模式是另一个XML文件，描述了允许在一个特定的文档中使用的元素和特性</p><h2 id="XML文档对象模型"><a href="#XML文档对象模型" class="headerlink" title="XML文档对象模型"></a>XML文档对象模型</h2><p>常用的DOM类：<br>XmlNode: 这个类表示文档树中的一个节点，是许多类的基类，如果这个节点表示XML文档的根，就可以从它导航到文档的任意位置<br>XmlDocument: 扩展了XmlNode类，但通常是使用XML的第一个对象，因为这个类用于加载磁盘或其他地方的数据并在这些位置保存数据<br>XmlElement: 表示XML文档中的一个元素，XmlElement派生于XmlLinkedNode，XmlLinkedNode派生于XmlNode<br>XmlAttribute: 表示一个特性，与XmlDocument类一样，派生于XmlNode类<br>XmlText：表示开始标记和结束标记之间的文本<br>XmlNodeList: 标识一个节点集合</p><h3 id="XmlDocument"><a href="#XmlDocument" class="headerlink" title="XmlDocument"></a>XmlDocument</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var document = new XmlDocument();</span><br><span class="line">document.Load(@&quot;C:\地址&quot;);、//文件名是一个绝对路径</span><br></pre></td></tr></table></figure><h3 id="XmlElement"><a href="#XmlElement" class="headerlink" title="XmlElement"></a>XmlElement</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol><li>FirstChild<br>该属性返回当前节点之后的第一个子节点</li><li>LastChild<br>返回当前节点之后的最后一个子节点</li><li>ParentNode<br>返回当前节点的父节点</li><li>NextSibling<br>返回有相同父节点的下一个节点</li><li>HasChildNodes<br>检查当前元素是否有子元素，而不是必须获取FirstChild的值并检查是否为null</li></ol><h3 id="获取节点值"><a href="#获取节点值" class="headerlink" title="获取节点值"></a>获取节点值</h3><ol><li>InnerText 获取当前节点中所有子节点的文本，把它作为一个串联字符串返回</li><li>InnerXml 返回类似于InnerText的文本</li><li>Value Value属性是操作文档中信息的最精炼方式</li></ol><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ol><li>CreateNode<br>创建任意类型的节点，该方法有三个重载，两个允许创建XmlNodeType 枚举中所列出的类型，另一个允许把要使用的节点类型指定为字符串，</li><li>CreateElement<br>只能创建XmlElement类型的节点</li><li>CreateAttribute<br>只能创建XmlAttribute类型的节点</li><li>CreateTextNode<br>创建XmlTextNode类型的节点</li><li>CreatCommen<br>创建注释</li></ol><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><ol><li>AppendChild<br>把一个节点追加到XmlNode类型或派生类型的节点上</li><li>InsertAfter<br>可以控制插入新节点的位置，该方法有两个参数，第一个是新节点，第二个是在其后插入新节点的节点</li><li>InsertBefour<br>新节点在参考节点之后</li></ol><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ol><li>RemoveAll<br>删除节点之上的所有子节点，并且删除字典的特性</li><li>RemoveChild<br>删除节点上的一个子节点，返回从文档中删除的节点</li></ol><h3 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h3><ol><li>SelectSingleNode<br>选择一个节点</li><li>SelectNodes<br>以XmlNodeList类的形式返回一个节点集合</li></ol><h2 id="XML转换为JSON"><a href="#XML转换为JSON" class="headerlink" title="XML转换为JSON"></a>XML转换为JSON</h2><p>C# 系统库有限的支持JSON. 但是可以使用免费的第三方类库将XMl转换为JSON.</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/C-XML/#disqus_thread</comments>
    </item>
    
    <item>
      <title>GitHub使用技巧</title>
      <link>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <guid>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <pubDate>Sun, 04 Aug 2019 06:31:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;Git两大特点&quot;&gt;&lt;a href=&quot;#Git两大特点&quot; class=&quot;headerlink&quot; title=&quot;Git两大特点
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git两大特点"><a href="#Git两大特点" class="headerlink" title="Git两大特点"></a>Git两大特点</h2><ol><li>版本控制</li><li>分布式</li></ol><h2 id="git最基本操作"><a href="#git最基本操作" class="headerlink" title="git最基本操作"></a>git最基本操作</h2><p>初始化仓库：<br><code>git init</code><br>将一个文件添加到暂存区<br><code>git add code.txt</code><br>创建一个版本记录<br><code>git commit -m &#39;verson1&#39;(版本的说明信息)</code><br>查看版本记录<br><code>git log</code><br>版本回退<br><code>git reset --hard head^ /hard head~1-100</code><br>再次返回<br><code>git reset --hard 版本号</code><br>查看之前的操作记录<br><code>git reflog</code><br>查看当前文件状态<br><code>git status</code><br>未添加到暂存区之前撤销改动(增删改)<br><code>git checkout -- 文件名</code><br>撤销暂存区的修改<br><code>git reset HEAD file</code><br>对比文件不同</p><ol><li>工作区文件与版本文件对比</li></ol><p>git diff HEAD – code.txt<br>–代表版本文件<br>++代表工作区文件</p><ol start="2"><li>对比两个版本之间某个文件的不同</li></ol><p>git diff HEAD HEAD^ – code.txt</p><p>删除文件</p><ol><li>不放在暂存区</li></ol><p>rm 文件名</p><ol start="2"><li>放在暂存区</li></ol><p>git rm 文件名</p><h2 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h2><p>查看分支<br><code>git branch</code><br>创建分支<br><code>git branch 分支名</code><br>创建并切换一个新的分支<br><code>git checkout -b 分支名</code><br>切换分支<br><code>git checkout master</code><br>合并<br><code>git merge 分支名</code><br>删除分支<br><code>git branch -d 分支名</code><br>合并冲突(两个分支上同时提交且编辑同一个文件)</p><p><strong><em>每次操作暂存区内容都必须git commit 创建版本记录</em></strong></p><h2 id="工作区-Working-Directory"><a href="#工作区-Working-Directory" class="headerlink" title="工作区(Working Directory)"></a>工作区(Working Directory)</h2><p>电脑中的目录，就是一个工作区</p><h2 id="版本库-Repository"><a href="#版本库-Repository" class="headerlink" title="版本库(Repository)"></a>版本库(Repository)</h2><p>工作区有一个隐藏目录.git, 这个不是工作区，而是git的版本库<br>git的版本库里存了很多东西，其中最重要的就是称为stage的暂存区，还有git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD</p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-Lambda表达式</title>
      <link>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <guid>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <pubDate>Sun, 04 Aug 2019 06:26:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;p&gt;“Lambda表达式”是一个匿名函数，是一种高效的类似于函数式编程的表达式，Lamb
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>“Lambda表达式”是一个匿名函数，是一种高效的类似于函数式编程的表达式，Lambda简化了了开发中需要编写的代码量，它可以包含表达式和语句，并且可用于创建委托或表达式目录树类型，支持带有可绑定到委托或表达式树的输入参数的内联表达式。lambda表达式使用=&gt;运算符，该运算符读作”goes to”。Lambda运算符的左边是输入参数，右边是表达式或语句块。<br><code>x =&gt; x*x</code><br>可以将此表达式分配给委托类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delegate int del(int i);</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    del myDelegate = x =&gt; x * x;</span><br><span class="line">    int j = myDelegate(5); //j = 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目录树类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System.Linq.Expressions;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApplication1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Expression&lt;del&gt; myET = x =&gt; x * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表达式位于=&gt;运算符右侧的lambda表达式称为”表达式lambada”,表达式Lambda会返回表达式的结果，并采用以下基本形式<br><code>(input parameters) =&gt; expression</code><br>仅当lambda只有一个输入参数时，括号才是可选的；否则括号是必须的，括号内的两个或更多个输入参数使用逗号加以分隔；<br><code>(x, y) =&gt; x == y</code><br>有时，编译器难以或无法推断输入类型。如果出现这种情况，你可以显示指定类型<br><code>(int x, string s) =&gt; s.Length &gt; x</code><br>使用空括号指定零个输入参数：<br><code>() =&gt; SomeMethod()</code><br>当Lambada表达式中有多个语句时<br><code>(input paramenters) =&gt; {statement;}</code></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/04/C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-LINQ</title>
      <link>https://qiyanan.com/2019/07/28/C-LINQ/</link>
      <guid>https://qiyanan.com/2019/07/28/C-LINQ/</guid>
      <pubDate>Sun, 28 Jul 2019 10:08:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;LINQ&lt;/strong&gt;&lt;br&gt;定义一个匿名类型对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = new {myTitle = &amp;quot;anonymous type&amp;quot;, myOtherParam = new int[] { 1, 2,
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>LINQ</strong><br>定义一个匿名类型对象：</p><pre><code>var obj = new {myTitle = &quot;anonymous type&quot;, myOtherParam = new int[] { 1, 2, 3, 4 } };</code></pre><p><strong>扩展函数：</strong></p><ol><li>扩展方法必须在一个非嵌套、非泛型的静态类中定义</li><li>扩展方法必须是一个静态方法</li><li>扩展方法至少要有一个参数</li><li>第一个参数必须附加this关键字作为前缀</li><li>第一个参数不能有其他修饰符（比如ref或者out）</li><li>第一个参数不能是指针类型</li></ol><p><strong>LINQ 查询操作符</strong><br>.net的设计者在类库中定义了一系列的扩展方法来方便用户操作集合对象，这些扩展方法构成了LINQ的查询操作符<br>扩展方法有Where, Max, Select, Sum, Any, Average, All, Concat等都是针对IEnumberable的对象进行扩展<br>基本LINQ查询操作</p><ol><li>获取数据源<br>在LINQ查询中，第一步是指定数据源，在LINQ查询中，先使用from子句引入数据源和范围变量</li><li>筛选<br>使用where子句生成结果，查询仅返回表达式为true的元素</li><li>中间件排序<br>orederby子句根据要排序类型的默认比较器，对返回序列中的元素排序，字符串比较顺序默认从A到Z进行排序，逆序使用orderby…descendingz子句</li><li>分组<br>group 子句用于对所获得的结果进行分组，使用group子句结束查询时，结果将以列表的形式列出，列表中的每个元素都是具有key成员的对象，列表中的元素根据该键杯分组，在循环访问生成组序列的查询时，必须使用嵌套foreach循环，外层循环访问每个组，内层循环访问每个组的成员，<br>如果必须引用某个组操作的结果，可使用into关键字创建能被进一步查询的标识符</li><li>联接<br>联接操作在不同序列间创建关联</li><li>选择(投影)<br>Select子句指定在执行查询时产生的值的类型，查询表达式必须以select子句或group子句结尾</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Customers&gt; customers = new List&lt;Customers&gt;() &#123;</span><br><span class="line">    new Customers&#123; Name = &quot;QIyanan&quot;, City = &quot;Gansu&quot;, Age = 16 &#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;IkeQi&quot;,City=&quot;USA&quot;,Age=18&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingQi&quot;,City=&quot;London&quot;,Age=20&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingZhang&quot;,City=&quot;London&quot;,Age=22&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingWang&quot;,City=&quot;London&quot;,Age=24&#125;,</span><br><span class="line">    new Customers&#123; Name=&quot;kingSun&quot;,City=&quot;London&quot;,Age=25&#125;&#125;;</span><br><span class="line">var result = from customer in customers</span><br><span class="line">             where customer.City == &quot;London&quot; &amp;&amp; customer.Name == &quot;kingQi&quot;</span><br><span class="line">             orderby customer.Age descending</span><br><span class="line">             select customer;</span><br><span class="line">var queryCustomersByCity = from cust in customers</span><br><span class="line">                           group cust by cust.City;</span><br><span class="line">foreach(var customerGroup in queryCustomersByCity)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(customerGroup.Key);</span><br><span class="line">    foreach(var customer in customerGroup)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;       &#123;customer.Name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foreach (var customer in result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(customer.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var studentQuery = from student in students</span><br><span class="line">                       where student.Scores[0] &gt; 90 &amp;&amp; student.Scores[3] &lt; 80</span><br><span class="line">                       orderby student.Scores[0] descending</span><br><span class="line">                       select student;</span><br><span class="line">    foreach (var student in studentQuery)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;    &#123;student.Last&#125;,     &#123;student.First&#125;,     &#123;student.Scores[0]&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery2 = from student in students</span><br><span class="line">                        group student by student.Last[0];</span><br><span class="line">    foreach (var studentGroup in studentQuery2)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(studentGroup.Key);</span><br><span class="line">        foreach (var student in studentGroup)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;        &#123;student.Last&#125;,   &#123;student.First&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery3 = from student in students</span><br><span class="line">                        group student by student.Last[0] into studentGroup</span><br><span class="line">                        orderby studentGroup.Key</span><br><span class="line">                        select studentGroup;</span><br><span class="line">    foreach (var groupOfStudents in studentQuery3)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(groupOfStudents.Key);</span><br><span class="line">        foreach (var student in groupOfStudents)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;     &#123;0&#125;,    &#123;1&#125;&quot;, student.Last, student.First);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery5 = from student in students</span><br><span class="line">                        let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3]</span><br><span class="line">                        where totalScore / 4 &lt; student.Scores[0]</span><br><span class="line">                        select student.Last + &quot;     &quot; + student.First;</span><br><span class="line">    foreach (string s in studentQuery5)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery6 = from student in students</span><br><span class="line">                        let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3]</span><br><span class="line">                        select totalScore;</span><br><span class="line">    double averageScore = studentQuery6.Average();</span><br><span class="line">    Console.WriteLine($&quot;Classaverage score = &#123;averageScore&#125;&quot;);</span><br><span class="line">    Console.WriteLine(&quot;===============================================&quot;);</span><br><span class="line">    var studentQuery7 = from student in students</span><br><span class="line">                        where student.Last == &quot;Garcia&quot;</span><br><span class="line">                        select student.First;</span><br><span class="line">    Console.WriteLine(&quot;The garcias in the class are:&quot;);</span><br><span class="line">    foreach (string s in studentQuery7)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LINQ查询函数<br><strong>Where(); 查询结果过滤</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list0 = new List&lt;int&gt; &#123; 6, 4, 2, 7, 9, 0 &#125;;</span><br><span class="line">list0.Where(x =&gt; x &gt; 5);</span><br><span class="line">list0.Where(x =&gt; x &gt;= 1).Where(x =&gt; x &lt;= 5);</span><br><span class="line">list0.Where(x =&gt; x &gt;= 1 &amp;&amp; x &lt;= 5);</span><br></pre></td></tr></table></figure></p><p><strong>Select(), SelectMany();</strong><br>处理结果会传回一个对象，这个对象可以是现在对象，也可以是匿名类型<br>在LINQ语句中的select new语句，会自动被编译器转换Select()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Num = from a in list0</span><br><span class="line">          where a &gt; 3</span><br><span class="line">          select new</span><br><span class="line">          &#123;</span><br><span class="line">             Number = a</span><br><span class="line">          &#125;;</span><br><span class="line">Console.WriteLine(Num.FirstOrDefault().Number);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var selectNum = list0.Where(x =&gt; x &gt; 3).Select(x =&gt; new &#123; Number = x &#125;);</span><br></pre></td></tr></table></figure><p>SelectMany()类似于数据库中的CrossJoin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">List&lt;int&gt; list2 = new List&lt;int&gt;() &#123; 6, 4, 5, 7, 9, 0 &#125;;</span><br><span class="line">var query = list1.SelectMany(x =&gt; list2);</span><br><span class="line">foreach (var iterm in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(iterm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>GroupBy()</strong><br>会按照给定的key(keySelector)以及内容elementSelector,产生群组后的结果GroupBy()设置了使用数列本身作为Key值，并且利用这个Key分组产生分组的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5, 1, 5, 4, 3, 2, 5, 5, 5, 6, 2, 3, 6 &#125;;</span><br><span class="line">var query = list.GroupBy(x =&gt; x);</span><br><span class="line">foreach (var item in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;numer is  &#123;item.Key&#125;, numer has &#123;item.Count()&#125;&quot;);</span><br><span class="line">    foreach (var x in item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;           &#123;x&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ToLookUp()</strong><br>返回值是一个泛型Lookup&lt;TKey, TElement&gt;, 看起来和GroupBy()类似，但是Yolookup是立即执行，GroupBy是延迟执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var marrks = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123; Mark = 90, Group = &quot;A&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 80, Group = &quot;B&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 70, Group = &quot;C&quot;&#125;,</span><br><span class="line">    new &#123; Mark = 60, Group = &quot;D&quot;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">var lookUpValue = marrks.ToLookup(x =&gt; x.Group);</span><br><span class="line">foreach(var item in lookUpValue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;=========Group:&#123;0&#125;===========&quot;,item.Key);</span><br><span class="line">    foreach(var result in item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(result.Group+&quot;   &quot;+result.Mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Join</strong><br>将两个集合进行连接，即数据库中的Inner Join<br>使用LINQ语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var Mark = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123;Name = &quot;C&quot; , Mark = 65&#125;,</span><br><span class="line">    new &#123;Name = &quot;A&quot; , Mark = 70&#125;,</span><br><span class="line">    new &#123;Name = &quot;B&quot; , Mark = 80&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">var Age = new[]</span><br><span class="line">&#123;</span><br><span class="line">    new &#123;Name = &quot;B&quot; , Age = 18&#125;,</span><br><span class="line">    new &#123;Name = &quot;C&quot; , Age = 17&#125;,</span><br><span class="line">    new &#123;Name = &quot;A&quot; , Age = 20&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var query = from mk in Mark</span><br><span class="line">            join ee in Age on mk.Name equals ee.Name</span><br><span class="line">            select new</span><br><span class="line">            &#123;</span><br><span class="line">                name = mk.Name,</span><br><span class="line">                mark = mk.Mark,</span><br><span class="line">                age = ee.Age</span><br><span class="line">            &#125;;</span><br><span class="line">foreach(var item in query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;name &#123;item.name&#125;, Score &#123;item.mark&#125;, Age &#123;item.age&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用LINQ函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var quer1 = Mark.Join(Age, mk =&gt; mk.Name, ae =&gt; ae.Name, (mk, ae) =&gt; new &#123; name = mk.Name, mark = mk.Mark, age = ae.Age &#125;);</span><br><span class="line">foreach (var item in quer1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;name &#123;item.name&#125;,  score&#123; item.mark&#125;,  age&#123;item.age&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中Mark是第一个集合，Join方法的第一个参数Age是第二个集合，mk =&gt; mk.name 是 第一个集合的外键，ae=&gt;ae.Name是第二个集合的外键。<br><strong>GroupJoin;</strong><br>将两个集合进行联接，并对结果进行分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义国家类</span><br><span class="line">class Country</span><br><span class="line">&#123;</span><br><span class="line">    public string CountryName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义省类</span><br><span class="line">class Province</span><br><span class="line">&#123;</span><br><span class="line">    public Country OwnerCountry &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceName &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceSize &#123; get; set; &#125;</span><br><span class="line">    public string ProvinceSpot &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//对国家类进行实例化</span><br><span class="line">Country c1 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;China&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c2 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;America&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c3 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;Korea&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Country c4 = new Country()</span><br><span class="line">&#123;</span><br><span class="line">    CountryName = &quot;Russian&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//对省实例化</span><br><span class="line">Province p1 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Hunan&quot;,</span><br><span class="line">    ProvinceSize = &quot;200&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Old City&quot;,</span><br><span class="line">    OwnerCountry = c1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p2 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Chicago&quot;,</span><br><span class="line">    ProvinceSize = &quot;150&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Linkin Park&quot;,</span><br><span class="line">    OwnerCountry = c2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p3 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Seoul&quot;,</span><br><span class="line">    ProvinceSize = &quot;100&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Tian Tian World&quot;,</span><br><span class="line">    OwnerCountry = c3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p4 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Hunan&quot;,</span><br><span class="line">    ProvinceSize = &quot;200&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Tian Meng Mountain&quot;,</span><br><span class="line">    OwnerCountry = c1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p5 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Moscow&quot;,</span><br><span class="line">    ProvinceSize = &quot;80&quot;,</span><br><span class="line">    ProvinceSpot = &quot;Moscow University&quot;,</span><br><span class="line">    OwnerCountry = c4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Province p6 = new Province()</span><br><span class="line">&#123;</span><br><span class="line">    ProvinceName = &quot;Moscow&quot;,</span><br><span class="line">    ProvinceSize = &quot;80&quot;,</span><br><span class="line">    ProvinceSpot = &quot;HelloWorld&quot;,</span><br><span class="line">    OwnerCountry = c4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义省集合</span><br><span class="line">List&lt;Province&gt; provinces = new List&lt;Province&gt;</span><br><span class="line">&#123;</span><br><span class="line">    p1,p2,p3,p4,p5,p6</span><br><span class="line">&#125;;</span><br><span class="line">//定义国家集合</span><br><span class="line">var countries = new List&lt;Country&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c1,c2,c3,c4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用Join连接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    //使用Join连接</span><br><span class="line">    var joinResult = countries.Join(provinces, country =&gt; country, province =&gt; province.OwnerCountry, (country, province) =&gt;</span><br><span class="line">    new</span><br><span class="line">    &#123;</span><br><span class="line">        countryName = country.CountryName,</span><br><span class="line">        provinceName = province.ProvinceName,</span><br><span class="line">        size = province.ProvinceSize,</span><br><span class="line">        spot = province.ProvinceSpot</span><br><span class="line">    &#125;);</span><br><span class="line">    foreach(var item in joinResult)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;countryName is &#123;item.countryName&#125; , provinceName is &#123;item.provinceName&#125; , size is &#123;item.size&#125;, spot is &#123;item.spot&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用GroupJoin</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var groupJoinResult = countries.GroupJoin(provinces, country=&gt;country, province =&gt; province.OwnerCountry, (country,province) =&gt; new</span><br><span class="line">&#123;</span><br><span class="line">    Name=country.CountryName,</span><br><span class="line">    ProvinceSet=province.Select(x=&gt;x)</span><br><span class="line">&#125;);</span><br><span class="line">foreach (var item in groupJoinResult)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Name);</span><br><span class="line">    foreach(var p in item.ProvinceSet)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(p.ProvinceName + &quot;  &quot; + p.ProvinceSize + &quot;  &quot; + p.ProvinceSpot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/07/28/C-LINQ/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
