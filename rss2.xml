<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ike&#39;s blog</title>
    <link>https://qiyanan.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 13 Sep 2019 05:39:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>TypeScript-AdvancedTypes</title>
      <link>https://qiyanan.com/2019/09/13/TypeScript-AdvancedTypes/</link>
      <guid>https://qiyanan.com/2019/09/13/TypeScript-AdvancedTypes/</guid>
      <pubDate>Fri, 13 Sep 2019 05:38:22 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Advanced-Types&quot;&gt;&lt;a href=&quot;#Advanced-Types&quot; class=&quot;headerlink&quot; title=&quot;Advanced Types&quot;&gt;&lt;/a&gt;Advanced Types&lt;/h1&gt;&lt;h2 id=&quot;Intersection-Type
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Advanced-Types"><a href="#Advanced-Types" class="headerlink" title="Advanced Types"></a>Advanced Types</h1><h2 id="Intersection-Types-交叉类型"><a href="#Intersection-Types-交叉类型" class="headerlink" title="Intersection Types(交叉类型)"></a>Intersection Types(交叉类型)</h2><p>交叉类型是将多个类型合并为一个类型，这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。就是说这个类型的对象同时有了三种类型的成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function extend&lt;First, Second&gt;(first: First, second: Second): First &amp; Second &#123;</span><br><span class="line">    const result: Partial&lt;First &amp; Second&gt; = &#123;&#125;;</span><br><span class="line">    for (const prop in first) &#123;</span><br><span class="line">        if (first.hasOwnProperty(prop)) &#123;</span><br><span class="line">            (result as First)[prop] = first[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (const prop in second) &#123;</span><br><span class="line">        if (second.hasOwnProperty(prop)) &#123;</span><br><span class="line">            (result as Second)[prop] = second[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result as First &amp; Second;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(public name: string) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Loggable &#123;</span><br><span class="line">    log(name: string): void;</span><br><span class="line">&#125;</span><br><span class="line">class ConsoleLogger implements Loggable &#123;</span><br><span class="line">    log(name:string) &#123;</span><br><span class="line">        console.log( `Hello, I&apos;m $&#123;name&#125;.` );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const jim = extend(new Person(&apos;Jim&apos;), ConsoleLogger.prototype);</span><br><span class="line">jim.log(jim.name);</span><br></pre></td></tr></table></figure><h2 id="Union-Types"><a href="#Union-Types" class="headerlink" title="Union Types"></a>Union Types</h2><p>联合类型表示一个值可以是几种类型之一，我们用竖线（|）分隔每个类型，所以 number | string | boolean 表示一个值可以是 number，string，或 boolean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">    fly();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line">interface Fish &#123;</span><br><span class="line">    swim();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line">function getSmallPet(): Fish | Bird &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let pet = getSmallPet();</span><br><span class="line">pet.layEggs();</span><br><span class="line">pet.swim();</span><br></pre></td></tr></table></figure><p><strong>如果我们有一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员</strong></p><h2 id="Type-Guards-and-Differentiating-Types-类型保护和区分类型"><a href="#Type-Guards-and-Differentiating-Types-类型保护和区分类型" class="headerlink" title="Type Guards and Differentiating Types(类型保护和区分类型)"></a>Type Guards and Differentiating Types(类型保护和区分类型)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let pet = getSmallPet();</span><br><span class="line">if ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">    (&lt;Fish&gt;pet).swim;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="User-Defined-type-Guards"><a href="#User-Defined-type-Guards" class="headerlink" title="User-Defined type Guards"></a>User-Defined type Guards</h3><p>这里可以注意到我们不得不多次使用类型断言，假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet 的类型就好了。<br>TypeScript里的类保护机制让他成为了现实，类保护就是一些表达式，他们会在运行时检查以确保在某个作用域里的类型。要定义一个类型保护，我们只要简单的定义一个函数，它的返回值就是一个类型谓词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class="line">    return (pet as Fish).swim !== undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里，pet is Fish 就是类型谓词，谓词为 parameterName is Type 这种形式，parameterName 必须是来自于当前函数签名里的一个参数名</p><p>每当使用一些变量调用 isFish 时，TypeScript 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p><h3 id="using-the-in-operator"><a href="#using-the-in-operator" class="headerlink" title="using the in operator"></a>using the in operator</h3><p>in 操作符现在充当类型的窄化表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function move(pet: Fish | Bird) &#123;</span><br><span class="line">    if (&quot;swim&quot; in pet) &#123;</span><br><span class="line">        return pet.swim();</span><br><span class="line">    &#125;</span><br><span class="line">    return pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typeof type guards</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function isNumber(x: any): x is number &#123;</span><br><span class="line">    return typeof x === &quot;number&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function isString(x: any): x is string &#123;</span><br><span class="line">    return typeof x === &quot;string&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function padLeft(value: string, padding: string | number) &#123;</span><br><span class="line">    if (isNumber(padding)) &#123;</span><br><span class="line">        return Array(padding + 1).join(&quot;&quot;) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (isString(padding)) &#123;</span><br><span class="line">        return padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new Error( `Expected string or number,got&apos;$&#123;padding&#125;&apos;, ` )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了，幸运的是，现在我们不必将 typeof x === “number” 抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护，也就是说我们可以直接在代码里检查类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function padLeft(value: string, padding: string | number) &#123;</span><br><span class="line">    if (typeof padding === &quot;number&quot;) &#123;</span><br><span class="line">        return Array(padding + 1).join(&quot; &quot;) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof padding === &quot;string&quot;) &#123;</span><br><span class="line">        return padding + value</span><br><span class="line">    &#125;</span><br><span class="line">    throw new Error( `Expected string or number,got&apos;$&#123;padding&#125;&apos;, ` )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>这些 typeof 类型保护只有两种形式被识别： typeof v ===”typename” and typeof v ！== “typename”, “typename” 必须是”number”, “string”, “boolean”, or “symbol”，但是 TypeScript 并不会组织你与其他字符串比较，语言不会把那些识别为类型保护</em></strong></p><h2 id="instanceof-type-guards"><a href="#instanceof-type-guards" class="headerlink" title="instanceof type guards"></a>instanceof type guards</h2><p>instanceof 类型保护是通过构造函数来细化类型的一种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface Padder &#123;</span><br><span class="line">    getPaddingString(): string;</span><br><span class="line">&#125;</span><br><span class="line">class SpaceRepeatingPadder implements Padder &#123;</span><br><span class="line">    constructor(private numSpaces: number) &#123; &#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        return Array(this.numSpaces + 1).join(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StringPadder implements Padder &#123;</span><br><span class="line">    constructor(private value: string) &#123; &#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function getRandomPadder() &#123;</span><br><span class="line">    return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">let padder: Padder = getRandomPadder();</span><br><span class="line">if (padder instanceof SpaceRepeatingPadder) &#123;</span><br><span class="line">    padder;</span><br><span class="line">&#125;</span><br><span class="line">if (padder instanceof StringPadder) &#123;</span><br><span class="line">    padder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instanceof 的右侧要求一个构造函数，TypeScript将细化为：</p><ol><li>此构造函数的　prototype 属性的类型，如果它的类型不为 any 的话。</li><li>构造签名所返回的类型的联合。</li></ol><h2 id="Nullable-types"><a href="#Nullable-types" class="headerlink" title="Nullable types"></a>Nullable types</h2><p>TypeScript 具有两种哦就那个特殊的类型，null 和 undefined，他们分别具有值 null 和 undefined，默认情况下，类型检查器认为 null 与 undefined 可以赋值给任何类型。null 与 undefined 是所有其他类型的一个有效值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s = &quot;foo&quot;;</span><br><span class="line">let sn: string | null = &quot;bar&quot;;</span><br><span class="line">sn = null;</span><br><span class="line">sn = undefined;// Error</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/09/13/TypeScript-AdvancedTypes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript-Type Compatibility</title>
      <link>https://qiyanan.com/2019/09/13/TypeScript-TypeCompatibility/</link>
      <guid>https://qiyanan.com/2019/09/13/TypeScript-TypeCompatibility/</guid>
      <pubDate>Fri, 13 Sep 2019 02:32:28 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Type-Compatibility&quot;&gt;&lt;a href=&quot;#Type-Compatibility&quot; class=&quot;headerlink&quot; title=&quot;Type Compatibility&quot;&gt;&lt;/a&gt;Type Compatibility&lt;/h1&gt;&lt;p&gt;TypeSc
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Type-Compatibility"><a href="#Type-Compatibility" class="headerlink" title="Type Compatibility"></a>Type Compatibility</h1><p>TypeScript 中的类型兼容性基于结构化子类型，结构类型是一种仅基于其成员关联类型的方法，这与名义类型形成了对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Named &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p: Named;</span><br><span class="line">p = new Person(&quot;&quot;);</span><br></pre></td></tr></table></figure><p><strong>TypeScript 的类型系统允许某些在编译阶段无法确认其安全性的操作</strong></p><h2 id="Starting-out"><a href="#Starting-out" class="headerlink" title="Starting out"></a>Starting out</h2><p>TypeScript 结构化类型系统的基本规则是，如果 x 要兼容 y，那么 y 至少具有 x 相同的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Named &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">let x: Named;</span><br><span class="line">let y = &#123; name: &quot;Alice&quot;, Location: &quot;Seattle&quot; &#125;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure><h2 id="Comparing-two-functions"><a href="#Comparing-two-functions" class="headerlink" title="Comparing two functions"></a>Comparing two functions</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = (a: number) =&gt; 0;</span><br><span class="line">let y = (b: number, s: string) =&gt; 0;</span><br><span class="line">y = x;</span><br><span class="line">x = y;// Error</span><br></pre></td></tr></table></figure><p>要查看 x 是否能赋值给 y，首先看他们的参数列表，x 的每个参数必须能在 y 里找到对应类型的参数。注意的是参数的名字相同与否无所谓，只看他们的类型，这里，x 的每个参数在 y 中都能找到对应的参数，所以允许赋值。<br>下面来看看如何让处理返回值类型，创建两个仅是返回值类型不同的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = () =&gt; (&#123; name: &quot;Alice&quot; &#125;);</span><br><span class="line">let y = () =&gt; (&#123; name: &quot;Alice&quot;, location: &quot;Seattle&quot; &#125;);</span><br><span class="line">x=y;</span><br><span class="line">y=x; // Error</span><br></pre></td></tr></table></figure><p><strong>类型系统强制原函数的返回值类型必须是目标函数返回值类型的子类型</strong></p><h2 id="Optional-Parameters-and-Rest-Parameters"><a href="#Optional-Parameters-and-Rest-Parameters" class="headerlink" title="Optional Parameters and Rest Parameters"></a>Optional Parameters and Rest Parameters</h2><p>当比较函数兼容性的时候, 可选参数和必选参数是可互换的。<br><strong>源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误</strong><br>当一个函数有剩余参数时，它被当作无限个可选参数。<br>有一个好的例子，常见的函数接受一个回调函数并用于对于程序员来说是可预知的参数但对类型系统来说是不确定的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class="line">&#125;</span><br><span class="line">invokeLater([1, 2], (x, y) =&gt; console.log(x + &quot;,&quot; + y));</span><br><span class="line">invokeLater([1, 2], (x?, y?) =&gt; console.log(x + &quot;,&quot; + y));</span><br></pre></td></tr></table></figure><h2 id="Functions-with-overloads"><a href="#Functions-with-overloads" class="headerlink" title="Functions with overloads"></a>Functions with overloads</h2><p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名，这确保了目标函数可以在所有源函数可调用的地方调用</p><h2 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h2><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容，不同枚举之间是不兼容的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123; Ready, Waiting &#125;;</span><br><span class="line">enum Color &#123; Red, Blue, Green &#125;;</span><br><span class="line">let status = Status.Ready;</span><br><span class="line">status=Color.Green; // Error</span><br></pre></td></tr></table></figure><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>类有静态部分和实例部分的类型. 当比较两个类类型的对象时, <strong>只有实例成员会被比较，静态函数和构造函数不在比较的范围内</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    feet: number;</span><br><span class="line">    constructor(name: string, numFeet: number) &#123;</span><br><span class="line">        this.feet = numFeet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Size &#123;</span><br><span class="line">    feet: number;</span><br><span class="line">    constructor(numFeet: number) &#123;</span><br><span class="line">        this.feet = numFeet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a: Animal;</span><br><span class="line">let s: Size;</span><br><span class="line">a = s;</span><br><span class="line">s = a;</span><br></pre></td></tr></table></figure><h3 id="Private-and-protected-members-in-classes"><a href="#Private-and-protected-members-in-classes" class="headerlink" title="Private and protected members in classes"></a>Private and protected members in classes</h3><p>类的私有成员和受保护成员会影响兼容性, 但检查类实例的兼容时，如果目标类型包含一个私有成员，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员，同样地，这条规则也适用于包含受保护成员实例的类型检查，这允许子类赋值给父类，但是不能与具有相同形状的不同继承层次结构的类兼容。</p><p>##　Generics<br>因为 TypeScript 是结构性的类型系统，类型参数只影响使用其作为类型一部分的结果类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Empty&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let x: Empty&lt;number&gt;;</span><br><span class="line">let y: Empty&lt;string&gt;;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure><p>通过给该接口添加一个成员更改这个个例子，可以看到是如何工作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Empty&lt;T&gt; &#123;</span><br><span class="line">    data: T;</span><br><span class="line">&#125;</span><br><span class="line">let x: Empty&lt;number&gt;;</span><br><span class="line">let y: Empty&lt;string&gt;;</span><br><span class="line">x = y; // Error</span><br></pre></td></tr></table></figure><p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 any 比较。然后用结果类型进行比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let identity = function &lt;T&gt;(x: T): T &#123;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">let reverse = function &lt;U&gt;(y: U): U &#123;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line">identity = reverse;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/09/13/TypeScript-TypeCompatibility/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript-TypeInference</title>
      <link>https://qiyanan.com/2019/09/10/TypeScript-TypeInference/</link>
      <guid>https://qiyanan.com/2019/09/10/TypeScript-TypeInference/</guid>
      <pubDate>Tue, 10 Sep 2019 01:38:47 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Type-Inference&quot;&gt;&lt;a href=&quot;#Type-Inference&quot; class=&quot;headerlink&quot; title=&quot;Type Inference&quot;&gt;&lt;/a&gt;Type Inference&lt;/h1&gt;&lt;h2 id=&quot;Basics&quot;&gt;&lt;a href=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h1><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>TypeScript 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型</p><p><code>let x = 3;</code></p><h2 id="Best-common-type"><a href="#Best-common-type" class="headerlink" title="Best common type"></a>Best common type</h2><p>当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断出一个最合适的通用类型</p><p><code>let x = [0, 1, null];</code></p><p>计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型</p><h2 id="Contextual-Typing"><a href="#Contextual-Typing" class="headerlink" title="Contextual Typing"></a>Contextual Typing</h2><p>上下文类型在很多情况下使用到，通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句，上下文类型也会做为最佳通用类型的候选类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;&#125;</span><br><span class="line">class Rhino extends Animal&#123;&#125;</span><br><span class="line">class Elephant extends Animal&#123;&#125;</span><br><span class="line">class Snake extends Animal&#123;&#125;</span><br><span class="line">function createZoo():Animal[]&#123;</span><br><span class="line">    return [new Rhino(), new Elephant(), new Snake()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/09/10/TypeScript-TypeInference/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript-Enums</title>
      <link>https://qiyanan.com/2019/09/09/TypeScript-Enums/</link>
      <guid>https://qiyanan.com/2019/09/09/TypeScript-Enums/</guid>
      <pubDate>Mon, 09 Sep 2019 06:33:19 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Enums&quot;&gt;&lt;a href=&quot;#Enums&quot; class=&quot;headerlink&quot; title=&quot;Enums&quot;&gt;&lt;/a&gt;Enums&lt;/h1&gt;&lt;p&gt;使用枚举我们可以定义一些带有名字的变量，使用枚举我们可以清晰地表达意图或者创建一组有区别的用例，TypeScript
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h1><p>使用枚举我们可以定义一些带有名字的变量，使用枚举我们可以清晰地表达意图或者创建一组有区别的用例，TypeScript 支持数字的和基于字符串的枚举</p><h2 id="Numeric-enums"><a href="#Numeric-enums" class="headerlink" title="Numeric enums"></a>Numeric enums</h2><p>可以使用 enum 关键字来定义一个 枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up = 1,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以完全不使用初始化器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction&#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举很简单：通过枚举的属性来访问枚举成员，使用枚举的名字声明类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Responses &#123;</span><br><span class="line">    No,</span><br><span class="line">    Yes,</span><br><span class="line">&#125;</span><br><span class="line">function Respond(recipient:string,message:Responses):void&#123;</span><br><span class="line">&#125;</span><br><span class="line">Respond(&quot;Princess Caroline&quot;,Responses.Yes)</span><br></pre></td></tr></table></figure><h2 id="String-enums"><a href="#String-enums" class="headerlink" title="String enums"></a>String enums</h2><p>在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员来进行初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up = &quot;UP&quot;,</span><br><span class="line">    Down = &quot;DOWN&quot;,</span><br><span class="line">    Left = &quot;LEFT&quot;,</span><br><span class="line">    Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Heterogeneous-enums（异构枚举）"><a href="#Heterogeneous-enums（异构枚举）" class="headerlink" title="Heterogeneous enums（异构枚举）"></a>Heterogeneous enums（异构枚举）</h2><p>从技术角度来说，枚举可以混合字符串和数字成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum BooleanLikeHeterogeneousEnum &#123;</span><br><span class="line">    No = 0,</span><br><span class="line">    Yes = &quot;YES&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Computed-and-constant-members"><a href="#Computed-and-constant-members" class="headerlink" title="Computed and constant members"></a>Computed and constant members</h2><p>每个枚举成员都有一个值，它可以是常量或就上出来的</p><ul><li>它是枚举的第一个成员且没有初始化器，这种情况下他被赋值 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123; X &#125;</span><br></pre></td></tr></table></figure><ul><li>它不带有初始化器且它之前的枚举成员是一个数字常量，这种情况下，当前枚举成员的值为他上一个枚举成员的值加 1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum E1 &#123; X, Y, Z &#125;</span><br><span class="line"></span><br><span class="line">enum E2 &#123;</span><br><span class="line">    A = 1, B, C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举成员使用常量枚举表达式初始化，常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值，给一个表达式满足下面条件之一时，他就是一个常量枚举表达式：</li></ul><ol><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li><li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li><li>带括号的常量枚举表达式</li><li>一元运算符 +, -, ~ 其中之一应用在了常量枚举表达式 </li><li>常量枚举表达式作为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 的操作对象，若常数枚举表达式求值后卫 NaN 或 Infinity,则会在编译阶段报错<br>所有其他情况的枚举成员被当作是需要计算得出的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum FileAccess &#123;</span><br><span class="line">    None,</span><br><span class="line">    Read = 1 &lt;&lt; 1,</span><br><span class="line">    Write = 1 &lt;&lt; 2,</span><br><span class="line">    ReadWrite = Read | Write,</span><br><span class="line">    G = &quot;123&quot;.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Union-enums-and-enum-member-types"><a href="#Union-enums-and-enum-member-types" class="headerlink" title="Union enums and enum member types"></a>Union enums and enum member types</h2><p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员，字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p><ul><li>任何字符串字面量(e.g. “foo”, “bar”, “baz”)</li><li>任何数字字面量(e.g. 1, 100)</li><li>应用了一元 - 符号的数字字面量(e.g. -1, -100)</li></ul><p>当所有枚举成员都拥有字面量枚举值时，它就带有可以一种特殊的语义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum ShapeKind &#123;</span><br><span class="line">    Circle,</span><br><span class="line">    Square,</span><br><span class="line">&#125;</span><br><span class="line">interface Circle &#123;</span><br><span class="line">    kind: ShapeKind.Circle;</span><br><span class="line">    radius: number</span><br><span class="line">&#125;</span><br><span class="line">interface Square &#123;</span><br><span class="line">    kind: ShapeKind.Square</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line">let c: Circle = &#123;</span><br><span class="line">    kind: ShapeKind.Circle,</span><br><span class="line">    radius: 100,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enums-at-runtime"><a href="#Enums-at-runtime" class="headerlink" title="Enums at runtime"></a>Enums at runtime</h2><p>枚举是在运行时真正存在的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">    X, Y, Z</span><br><span class="line">&#125;</span><br><span class="line">function f(obj: &#123; X: number &#125;) &#123;</span><br><span class="line">    return obj.X;</span><br><span class="line">&#125;</span><br><span class="line">f(E);</span><br></pre></td></tr></table></figure><h2 id="Enums-at-compile-time"><a href="#Enums-at-compile-time" class="headerlink" title="Enums at compile time"></a>Enums at compile time</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum LogLevel &#123;</span><br><span class="line">    ERROR, WARN, INFO, DEBUG</span><br><span class="line">&#125;</span><br><span class="line">type LogLevelStrings = keyof typeof LogLevel;</span><br><span class="line">function printImportant(key: LogLevelStrings, message: string) &#123;</span><br><span class="line">    const num = LogLevel[key];</span><br><span class="line">    if (num &lt;= LogLevel.WARN) &#123;</span><br><span class="line">        console.log(&apos;Log level kry is: &apos;, key);</span><br><span class="line">        console.log(&apos;Log level Value is: &apos;, num);</span><br><span class="line">        console.log(&apos;Log level message is: &apos;, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printImportant(&apos;ERROR&apos;, &apos;This is a message&apos;);</span><br></pre></td></tr></table></figure><h2 id="Reverse-mappings"><a href="#Reverse-mappings" class="headerlink" title="Reverse mappings"></a>Reverse mappings</h2><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了反向映射，从枚举值到枚举名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Enum &#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line">let a = Enum.A;</span><br><span class="line">let nameOfA = Enum[a];</span><br></pre></td></tr></table></figure><h2 id="const-enums"><a href="#const-enums" class="headerlink" title="const enums"></a>const enums</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const enum Directions&#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line">let directions = [Directions.Up,Directions.Down,Directions.Left,Directions.Right]</span><br></pre></td></tr></table></figure><h2 id="Ambient-enums（外部枚举）"><a href="#Ambient-enums（外部枚举）" class="headerlink" title="Ambient enums（外部枚举）"></a>Ambient enums（外部枚举）</h2><p>Ambient enums</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare enum Enum &#123;</span><br><span class="line">    A = 1,</span><br><span class="line">    B,</span><br><span class="line">    C = 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/09/09/TypeScript-Enums/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript-Generic</title>
      <link>https://qiyanan.com/2019/09/09/TypeScript-Generic/</link>
      <guid>https://qiyanan.com/2019/09/09/TypeScript-Generic/</guid>
      <pubDate>Mon, 09 Sep 2019 05:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Generics&quot;&gt;&lt;a href=&quot;#Generics&quot; class=&quot;headerlink&quot; title=&quot;Generics&quot;&gt;&lt;/a&gt;Generics&lt;/h1&gt;&lt;p&gt;我们可以使用 any 类型来定义函数&lt;/p&gt;
&lt;figure class=&quot;highligh
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p>我们可以使用 any 类型来定义函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity(arg:any):any&#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line">let output=identity(&quot;myString&quot;);//output is any type</span><br><span class="line">console.log(output);</span><br></pre></td></tr></table></figure><h2 id="Generic-function"><a href="#Generic-function" class="headerlink" title="Generic function"></a>Generic function</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg:T):T&#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line">let output=identity(&quot;MyString&quot;);</span><br><span class="line">console.log(output);</span><br></pre></td></tr></table></figure><h2 id="Working-with-Generic-Type-Variables"><a href="#Working-with-Generic-Type-Variables" class="headerlink" title="Working with Generic Type Variables"></a>Working with Generic Type Variables</h2><p>我们可以把泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generic-Types"><a href="#Generic-Types" class="headerlink" title="Generic Types"></a>Generic Types</h2><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;  </span><br><span class="line">&#125;</span><br><span class="line">let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity; </span><br><span class="line">``` </span><br><span class="line">我们也可以使用不同的参数名，只要在数量上能对应上就可以。</span><br></pre></td></tr></table></figure><p>function identity<t>(arg: T): T {<br>    return arg;<br>}<br>let myIdentity: <u>(arg: U) =&gt; U = identity;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们也可以使用带有调用签名的对象字面量来定义泛型函数</span><br></pre></td></tr></table></figure></u></t></p><p>function identity<t>(arg: T): T {<br>    return arg;<br>}<br>let myIdentity: { <u>(arg: U): U } = identity;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个泛型接口</span><br></pre></td></tr></table></figure></u></t></p><p>interface GenericIdentityFn {<br>    <t>(arg: T): T;<br>}<br>function identity<t>(arg: T): T {<br>    return arg;<br>}<br>let myIdentity: GenericIdentityFn = identity;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可能想把泛型参数当作整个接口的一个参数</span><br></pre></td></tr></table></figure></t></t></p><p>interface GenericIdentityFn<t> {<br>    (arg: T): T;<br>}<br>function identity<t>(arg: T): T {<br>    return arg;<br>}<br>let myIdentity: GenericIdentityFn<number> = identity;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Generic Classes</span><br></pre></td></tr></table></figure></number></t></t></p><p>class GenericNumber<t>{<br>    zeroValue: T | undefined;<br>    add: ((x: T, y: T) =&gt; T) | undefined;<br>}<br>let myGenericNumber = new GenericNumber<number>();<br>myGenericNumber.zeroValue = 0;<br>myGenericNumber.add = function (x, y) { return x + y; }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Generic Constraints</span><br><span class="line"></span><br><span class="line">我们定义一个接口来描述约束条件，创建一个包含 .length 属性的接口，使用这个接口和 extends 关键字来实现约束。</span><br></pre></td></tr></table></figure></number></t></p><p>interface lengthwise {<br>    length: number;<br>}<br>function loggingIdentity<t extends lengthwise>(arg: T): T {<br>    console.log(arg.length);<br>    return arg;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### Using Type Parameters in Generic Constraints</span><br></pre></td></tr></table></figure></t></p><p>function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {<br>    return obj[key];<br>}<br>let x = { a: 1, b: 2, c: 3, d: 4 };<br>getProperty(x, “a”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Using Class Types in Generics</span><br><span class="line"></span><br><span class="line">在 TypeScript 使用泛型创建工厂函数时，需要引用构造函数的类类型</span><br></pre></td></tr></table></figure></p><p>function create<t>(c: { new(): T; }): T {<br>    return new c();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A more advanced example</span><br></pre></td></tr></table></figure></t></p><p>class BeeKeeper {<br>    hasMark: boolean;<br>}</p><p>class ZooKeeper {<br>    nameTag: number;<br>}</p><p>class Animal {<br>    numLegs: number;<br>}</p><p>class Bee extends Animal {<br>    keeper: BeeKeeper;<br>}</p><p>class Lion extends Animal {<br>    keeper: ZooKeeper;<br>}</p><p>function createInstance<a extends animal>(c: new () =&gt; A): A {<br>    return new c();<br>}<br>createInstance(Lion).keeper.nameTag;<br>createInstance(Bee).keeper.hasMark;<br><code>`</code></a></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/09/09/TypeScript-Generic/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript-Functions</title>
      <link>https://qiyanan.com/2019/09/09/TypeScript-Functions/</link>
      <guid>https://qiyanan.com/2019/09/09/TypeScript-Functions/</guid>
      <pubDate>Mon, 09 Sep 2019 02:53:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Functions&quot;&gt;&lt;a href=&quot;#Functions&quot; class=&quot;headerlink&quot; title=&quot;Functions&quot;&gt;&lt;/a&gt;Functions&lt;/h1&gt;&lt;p&gt;两种 JavaScript 函数&lt;br&gt;&lt;figure class=&quot;highlig
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>两种 JavaScript 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">let myAdd = function (x, y) &#123; return x + y &#125;; </span><br><span class="line">```</span><br></pre></td></tr></table></figure></p><p>ley z = 100;<br>function addToZ(x, y) {<br>    return x + y + z;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Function Types</span><br><span class="line"></span><br><span class="line">### Typing the Types</span><br><span class="line">让我们替上面那个函数添加类型</span><br></pre></td></tr></table></figure></p><p>function add(x:number, y:number) {<br>    return x + y;<br>}<br>let myAdd = function (x:number, y:number) { return x + y };<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Writing the function type</span><br><span class="line"></span><br><span class="line">`</span><br><span class="line">let myAdd : (x: number, y: number) =&gt; number =</span><br><span class="line">    function (x: number, y: number): number &#123; return x + y; &#125;;</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">我们写参数类型像参数列表一样，给每个采纳数一个名称哥一个类型，这个名字只是为了提供可读性</span><br></pre></td></tr></table></figure></p><p>let myAdd : (baseValue: number, Increment: number) =&gt; number =</p><pre><code>function (x: number, y: number): number { return x + y; };</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">### Inferring the types </span><br><span class="line"></span><br><span class="line">`</span><br><span class="line">let myAdd = function (x: number, y: number): number &#123; return x + y; &#125;;</span><br><span class="line">`</span><br><span class="line">`</span><br><span class="line">let myAdd: (baseValue: number, Increment: number) =&gt; number = function (x, y) &#123; return x + y; &#125;; </span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">### Optional and Default Parameters</span><br><span class="line"></span><br><span class="line">TypeScript 里的每个函数都是必须的，传递给一个函数的参数个数必须与原函数期望的参数个数一致</span><br><span class="line"></span><br><span class="line">1. Optional Parameters</span><br></pre></td></tr></table></figure><p>function buildName(firstName: string, lastName?: string) {</p><pre><code>if(lastName){    return firstName + &quot;&quot; + lastName;}elsereturn firstName;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***可选参数必须跟在必选参数后面***</span><br><span class="line"></span><br><span class="line">2. Default parameters</span><br></pre></td></tr></table></figure><p>function buildName(firstName: string, lastName=”Smith”) {</p><pre><code>if(lastName){    return firstName + &quot;&quot; + lastName;}elsereturn firstName;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">与普通的可选参数不同，带默认值的参数不需要放在必选参数的后面。</span><br><span class="line">**如果带默认值的参数出现在必选参数前面，用户必须明确的传入 undefined 值来获得默认值**</span><br></pre></td></tr></table></figure><p>function buildName(firstName=”Will”, lastName:string) {</p><pre><code>if(lastName){    return firstName + &quot;&quot; + lastName;}elsereturn firstName;</code></pre><p>}<br>let result = buildName(undefined, “Adms”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## Rest Parameters</span><br><span class="line"></span><br><span class="line">有时，我们想同时操作多个参数，或者，我们不知道会有多少参数传递进来，在 TypeScript 里，我们可以把所有的参数收集到一个变量里：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">function buildName(firstName:string, ...restOfName:string[])&#123;</span><br><span class="line">    return firstName+&quot; &quot;+restOfName.join(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">let employeeName = buildName(&quot;joseph&quot;,&quot;Samuel&quot;,&quot;Lucas&quot;,&quot;MacKinzie&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let deck = &#123;</span><br><span class="line">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class="line">    cards: Array(52),</span><br><span class="line">    createCardPicker: function () &#123;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class="line">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class="line">            return &#123;</span><br><span class="line">                suit: this.suits[pickedSuit], card: pickedCard % 13</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cardPicker = deck.createCardPicker();</span><br><span class="line">let pickedCard = cardPicker();</span><br><span class="line">alert( `card: $&#123;pickedCard.card&#125; of $&#123;pickedCard.suit&#125;` );</span><br></pre></td></tr></table></figure><p>可以看到 CreateCardPicker 是个函数，并且它返回一个函数，如股票我们尝试运行这个程序，发现他没有弹出对话框而是报错了，因为 createCarPicker 返回的函数里的 this 设置成了 window 而不是 deck 对象，因为我们只是独立的调用了 cardPicker()，顶级的非方法调用会将 this 视为 window。<br>为了解决这个问题，我们可以在函数被返回时就绑好正确的 this，这样的话，无论之后怎么使用它，都会引用绑定的 deck 对象，我们需要改变函数表达式来使用 ECMAScript 6箭头语法，箭头函数能保存函数时的 this 值，而不是调用时的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let deck = &#123;</span><br><span class="line">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class="line">    cards: Array(52),</span><br><span class="line">    createCardPicker: function () &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class="line">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class="line">            return &#123;</span><br><span class="line">                suit: this.suits[pickedSuit], card: pickedCard % 13</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cardPicker = deck.createCardPicker();</span><br><span class="line">let pickedCard = cardPicker();</span><br><span class="line">alert( `card: $&#123;pickedCard.card&#125; of $&#123;pickedCard.suit&#125;` );</span><br></pre></td></tr></table></figure></p><h3 id="this-parameters"><a href="#this-parameters" class="headerlink" title="this parameters"></a>this parameters</h3><p>让我们往例子里添加有一些接口，Card 和 Deck，让类型的重用能够变得清晰简单些<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">interface Card &#123;</span><br><span class="line">    suit: string;</span><br><span class="line">    card: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Deck &#123;</span><br><span class="line">    suits: string[];</span><br><span class="line">    cards: number[];</span><br><span class="line">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class="line">&#125;</span><br><span class="line">let deck = &#123;</span><br><span class="line">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class="line">    cards: Array(52),</span><br><span class="line">    createCardPicker: function (this: Deck) &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class="line">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class="line">            return &#123;</span><br><span class="line">                suit: this.suits[pickedSuit], card: pickedCard % 13</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cardPicker = deck.createCardPicker();</span><br><span class="line">let pickedCard = cardPicker();</span><br><span class="line">alert( `card: $&#123;pickedCard.card&#125; of $&#123;pickedCard.suit&#125;` );</span><br></pre></td></tr></table></figure></p><p>现在，TypeScript 知道 createCardPicker 期望在某个 deck 对象上调用，也就是说 this 是 Deck 类型的，而非 any</p><h3 id="this-parameters-in-callbacks"><a href="#this-parameters-in-callbacks" class="headerlink" title="this parameters in callbacks"></a>this parameters in callbacks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface UIElement &#123;</span><br><span class="line">    addClickListener(onclick: (this: void, e: Event) =&gt; void): void;</span><br><span class="line">&#125;</span><br><span class="line">class Handler &#123;</span><br><span class="line">    info: string;</span><br><span class="line">    onClickBad(this: Handler, e: Event) &#123;</span><br><span class="line">        console.log(&apos;clicked!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = new Handler();</span><br><span class="line">uiElement.addClickListener(b.onClickBad);</span><br></pre></td></tr></table></figure><h2 id="Overloads"><a href="#Overloads" class="headerlink" title="Overloads"></a>Overloads</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];</span><br><span class="line">function pickedCard(x: &#123; suit: string; card: number &#125;[]): number;</span><br><span class="line">function pickedCard(x: number): &#123; suit: string; card: number; &#125;</span><br><span class="line">function pickedCard(x: any): any &#123;</span><br><span class="line">    if (typeof x == &quot;object&quot;) &#123;</span><br><span class="line">        let pickedCard = Math.floor(Math.random() * x % 13);</span><br><span class="line">        return pickedCard;</span><br><span class="line">    &#125; else if (typeof x == &quot;number&quot;) &#123;</span><br><span class="line">        let pickedSuit = Math.floor(x / 13);</span><br><span class="line">        return &#123; suit: suits[pickedSuit], card: x % 13 &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myDeck = [&#123; suit: &quot;diamonds&quot;, card: 2 &#125;, &#123; suit: &quot;spades&quot;, card: 10 &#125;, &#123; suit: &quot;hearts&quot;, card: 4 &#125;]</span><br><span class="line">let pickedCard1 = myDeck[pickedCard(myDeck)];</span><br><span class="line">alert( `card: $&#123;pickedCard1.card&#125; of $&#123;pickedCard1.suit&#125;` );</span><br><span class="line">let pickedCard2 = pickedCard(15);</span><br><span class="line">alert( `card: $&#123;pickedCard2.card&#125; of $&#123;pickedCard2.suit&#125;` );</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/09/09/TypeScript-Functions/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript-Class</title>
      <link>https://qiyanan.com/2019/09/06/TypeScript-Class/</link>
      <guid>https://qiyanan.com/2019/09/06/TypeScript-Class/</guid>
      <pubDate>Fri, 06 Sep 2019 09:00:05 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;TypeScript-Class&quot;&gt;&lt;a href=&quot;#TypeScript-Class&quot; class=&quot;headerlink&quot; title=&quot;TypeScript-Class&quot;&gt;&lt;/a&gt;TypeScript-Class&lt;/h1&gt;&lt;p&gt;下面让我们看一个简单使用类的
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="TypeScript-Class"><a href="#TypeScript-Class" class="headerlink" title="TypeScript-Class"></a>TypeScript-Class</h1><p>下面让我们看一个简单使用类的例子： </p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Greeter &#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    constructor(message: string) &#123;</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        return &quot;hello, &quot; + this.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let greeter = new Greeter(&quot;world&quot;);</span><br><span class="line">console.log(greeter.greet());</span><br></pre></td></tr></table></figure><h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    move(distanceInMeters:number=0)&#123;</span><br><span class="line">        console.log( `Animal moved $&#123;distanceInMeters&#125;m` );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    bark()&#123;</span><br><span class="line">        console.log(&quot;woof! woof! &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const dog=new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(10);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure><p>这个例子展示了最基本的继承功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(theName: string) &#123;</span><br><span class="line">        this.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters: Number = 0) &#123;</span><br><span class="line">        console.log( `$&#123;this.name&#125;moved $&#123;distanceInMeters&#125;` );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters = 5) &#123;</span><br><span class="line">        console.log(&quot;Slithering...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Horse extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters = 45) &#123;</span><br><span class="line">        console.log(&quot;galloping...&quot;);</span><br><span class="line">        super.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let sam = new Snake(&quot;sammy the Python&quot;);</span><br><span class="line">let tom: Animal = new Horse(&quot;Tommy the palomino&quot;);</span><br><span class="line">sam.move();</span><br><span class="line">tom.move(34);</span><br></pre></td></tr></table></figure><h2 id="Public-private-and-protected-修饰符"><a href="#Public-private-and-protected-修饰符" class="headerlink" title="Public, private, and protected 修饰符"></a>Public, private, and protected 修饰符</h2><p><strong><em>在 TypeScript 中，每一个成员默认是 Public </em></strong></p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>当成员被标记成 private 时，它就不能在声明它的类的外部访问。<br>当比较有 private 成员和 protected 成员的类型时，我们以不同的方式对待它们，如果两个类型中有一个是 private 成员，另一个成员必须有一个来自同一处声明的 private 成员，我们就认为这两个类型是兼容的，上述业适用于 protected 成员</p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><ol><li>一个成员声明为 protected 可以被派生类访问，</li><li>构造函数也可以被声明为 protected，这意味值这个类不能在包含它的类外被实例化，但是能够被继承。</li></ol><h2 id="Readonly-modifier"><a href="#Readonly-modifier" class="headerlink" title="Readonly modifier"></a>Readonly modifier</h2><p>我们可以使用 readonly 关键字将属性设置为只读的，只读属性必须在声明时或构造函数里被初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Octopus &#123;</span><br><span class="line">    readonly name: string;</span><br><span class="line">    readonly numberOfLegs: number = 8;</span><br><span class="line">    constructor(theName: string) &#123;</span><br><span class="line">        this.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dad = new Octopus(&quot;man with the 8 strong legs&quot;)</span><br></pre></td></tr></table></figure><h2 id="Parameter-properties"><a href="#Parameter-properties" class="headerlink" title="Parameter properties"></a>Parameter properties</h2><p>参数属性允许我们在一个地方创建和初始化成员，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Octopus&#123;</span><br><span class="line">    readonly numberOfLegs:number=8;</span><br><span class="line">    constructor(readonly name:string)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let dad = new Octopus(&quot;man with the 8 strong legs&quot;)</span><br></pre></td></tr></table></figure><h2 id="Accessors"><a href="#Accessors" class="headerlink" title="Accessors"></a>Accessors</h2><p>TypeScript 支持 getters/setters 作为一种拦截对象成员访问的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Employee &#123;</span><br><span class="line">    private _fullName: string;</span><br><span class="line">    get fullName(): string &#123;</span><br><span class="line">        return this._fullName;</span><br><span class="line">    &#125;</span><br><span class="line">    set fullName(newName: string) &#123;</span><br><span class="line">        if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) &#123;</span><br><span class="line">            throw new Error(&quot;fullName has a max length of &quot; + fullNameMaxLength)&apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        this._fullName = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Static-Properties"><a href="#Static-Properties" class="headerlink" title="Static Properties"></a>Static Properties</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Grid &#123;</span><br><span class="line">    static origin = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">    calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123;</span><br><span class="line">        let xDist = (point.x - Grid.origin.x);</span><br><span class="line">        let yDist = (point.y - Grid.origin.y);</span><br><span class="line">        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(public scale: number) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">let grid1 = new Grid(1.0);</span><br><span class="line">let grid2 = new Grid(5.0);</span><br><span class="line">console.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));</span><br><span class="line">console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 100 &#125;));</span><br></pre></td></tr></table></figure><h2 id="Abstract-Classes"><a href="#Abstract-Classes" class="headerlink" title="Abstract Classes"></a>Abstract Classes</h2><p>抽象类被视为其他派生类的基类使用，他们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节，abstract 关键字用于定义抽象类和在抽象类内部定义抽象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract makeSound(): void;</span><br><span class="line">    move(): void &#123;</span><br><span class="line">        console.log(&quot;roaming the earth...&quot;;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Constructor-functions"><a href="#Constructor-functions" class="headerlink" title="Constructor functions"></a>Constructor functions</h2><p>当你在 TypeScript 声明一个类的时候，你实际上同时创建了多个声明，首先就是类的实例类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Greeter &#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    constructor(message: string) &#123;</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        return &quot;Hello, &quot; + this.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let greeter: Greeter;</span><br><span class="line">greeter = new Greeter(&quot;world&quot;);</span><br><span class="line">console.log(greeter.greet());</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/09/06/TypeScript-Class/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TypeScript - Basic Type</title>
      <link>https://qiyanan.com/2019/08/09/TypeScript-Basic%20Type/</link>
      <guid>https://qiyanan.com/2019/08/09/TypeScript-Basic%20Type/</guid>
      <pubDate>Fri, 09 Aug 2019 02:42:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Basic-Types&quot;&gt;&lt;a href=&quot;#Basic-Types&quot; class=&quot;headerlink&quot; title=&quot;Basic Types&quot;&gt;&lt;/a&gt;Basic Types&lt;/h1&gt;&lt;h2 id=&quot;布尔值&quot;&gt;&lt;a href=&quot;#布尔值&quot; class=&quot;he
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h1><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p><code>let isDone:boolean = false;</code></p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>(和JavaScript一样，TypeScript里的所有数字都是浮点型的，这些浮点类型是number)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0Xf00d;</span><br><span class="line">let binaryLiteral: number = 0b1010；</span><br><span class="line">let octaliteral: number = 0o744;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>(使用单引号或者双引号表示字符串)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name； string = &quot; bob&quot;;</span><br><span class="line">name = &quot;smith&quot;;</span><br></pre></td></tr></table></figure><p>可以使用模板字符串，也可以定义多行文本和内嵌表达式，这种字符串是被反引号包围( ` ), 并且以$( expr )这种形式嵌入表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name: string = `Gene` ;</span><br><span class="line">let age: number = 37;</span><br><span class="line">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class="line">I &apos;ll be $&#123; age+1 &#125; years old next month.`;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在元素类型后面接上[], 表示此类型组成的一个数组：</p><p><code>let list: number[] = {1, 2, 3};</code></p><p>使用数据泛型，Array&lt;元素类型&gt;</p><p><code>let list: Array&lt; number &gt; = {1, 2, 3};</code></p><h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>(允许表示一个已知元素数量和类型的数组，各元素的类型不必相同)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Declare a tuple type</span><br><span class="line">let x: [string , number];</span><br><span class="line">//Initialize</span><br><span class="line">x = [&quot;hello&quot;, 10];//OK</span><br><span class="line">//Initialize it incorrectly</span><br><span class="line">x = [10,&apos;hello&apos;];//Error</span><br></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log( x[0].substr(1));// OK</span><br><span class="line">console.log( x[1].substr(1));// Error,&apos;numbers&apos; does not have &apos;substr&apos;</span><br></pre></td></tr></table></figure><p><strong><em>当访问一个越界的元素，会使用联合类型替代：（联合类型是高级主题）</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[3] = &quot;world&quot;; // OK，字符串可以赋值给(string | sumber)类型</span><br><span class="line">console.log(x[5].toString());//OK，&apos;string&apos; 和&apos;number&apos;都有toString</span><br><span class="line">x[6] =true ;//Error,布尔不是(string | number)类型</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123; Red, Green,Blue&#125;</span><br><span class="line">let c: Coloe = Coleo.Green;</span><br></pre></td></tr></table></figure><p>默认情况下，从0开始为元素编号，也可以手动设置</p><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>(使类型检查器不对这些值检查直接让他们通过编译阶段)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any = 4; </span><br><span class="line">notSure = &quot;maybe a string instead&quot;; </span><br><span class="line">notSure = false;</span><br></pre></td></tr></table></figure><p><strong>any</strong> 类型是十分有用的，它允许你在编译时可选择的包含或者移除类型检查，你可能认为在其他语言中 <strong>Object</strong> 有类似的作用，然而，<strong>Object</strong>只允许你给它赋任意值，即便它拥有方法，你不能调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any = 4;</span><br><span class="line">notSure.ifitExists();//okay, ifitExists might exist at runtime</span><br><span class="line">notSure.toFixed();//Okay, toFixed exists</span><br></pre></td></tr></table></figure><p><img src="/2019/08/09/TypeScript-Basic Type/Any.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let prettySure: Object = 4;</span><br><span class="line">prettySure.ToFixed();//Error:Property &quot;toFind&quot; doesn&apos;t exist on type &apos;Object&apos;.</span><br></pre></td></tr></table></figure><p><img src="/2019/08/09/TypeScript-Basic Type/Object.png" alt="avatar"></p><p>如果你只知道一部分数据类型的时候，<strong>any</strong> 类型也是有用的，比如你可能有一个包含了不同数据类型的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [1, true, &quot;free&quot;];</span><br><span class="line">list[1] = 100;</span><br></pre></td></tr></table></figure><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>某种程度上来说，void 类型与 any 类型相反，它表示没有任何类型，你通常会看到当一个函数没有返回值的时候，该函数的返回值类型是 void</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">    console.log(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 void 类型的变量没有什么大用，应为你只能为它赋予 undefined 和 null：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br><span class="line">let unKnow: void = null;</span><br></pre></td></tr></table></figure><h2 id="Null-and-Underfined"><a href="#Null-and-Underfined" class="headerlink" title="Null and Underfined"></a>Null and Underfined</h2><p>TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null，和 void 相似，他们的本身用处不是很大：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure><p>默认情况下，<strong>null</strong> 和 <strong>undefined</strong> 是所有类型的子类型，这意味着你可以将 null 和 undefined 赋值给任何类型就像 number。<br>然而，你指定了 –strictNullChecks 标记，null 和 undefined 只能赋值给他们各自本身，（其中 undefined 也不能赋值给 void），这就帮助避免了很多常见的问题，也许你想在某处传一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefined。<br><strong><em>注意：我们鼓励尽可能多的使用 –strictNullChecks</em></strong></p><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>never 类型表示的是那些永不存在的类型。例如，never 类型是那些总是会抛出异常或者根本就不会有返回值的函数表达式或者箭头函数的返回值类型，当变量被永不为真的类型保护所约束时，该变量可能是 never 类型。</p><p>never 类型是任何类型的子类型，也可以赋值给任何类型，除了 never 本身以外，没有值可以赋值给 never 类型，即便是 any 也不可以赋值给 never。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>object 表示的是除 number, string, boolean, symbol, null, undefined 的非原始类型，<br>使用 object 类型，就可以更好的表示像 object.create 这样的 API。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line">create(&#123; prop: 0 &#125;);OK</span><br><span class="line">create(null);OK</span><br><span class="line">create(42);//Error</span><br><span class="line">create(&quot;string&quot;);//Error</span><br><span class="line">create(false);//error</span><br><span class="line">create(undefined);//Error</span><br></pre></td></tr></table></figure><h2 id="Type-assertions"><a href="#Type-assertions" class="headerlink" title="Type assertions"></a>Type assertions</h2><ul><li><p>类型断言有两种形式，第一种是尖括号语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string &quot;;</span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br></pre></td></tr></table></figure></li><li><p>as 语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let somevalue: any=&quot;this is a string&quot;; </span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure></li></ul><p><strong>当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的</strong></p>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/09/TypeScript-Basic%20Type/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-浅度复制与深度复制</title>
      <link>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/</guid>
      <pubDate>Tue, 06 Aug 2019 08:14:26 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;浅度复制和深度复制&quot;&gt;&lt;a href=&quot;#浅度复制和深度复制&quot; class=&quot;headerlink&quot; title=&quot;浅度复制和深度复制&quot;&gt;&lt;/a&gt;浅度复制和深度复制&lt;/h1&gt;&lt;h2 id=&quot;浅度复制&quot;&gt;&lt;a href=&quot;#浅度复制&quot; class=&quot;headerli
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="浅度复制和深度复制"><a href="#浅度复制和深度复制" class="headerlink" title="浅度复制和深度复制"></a>浅度复制和深度复制</h1><h2 id="浅度复制"><a href="#浅度复制" class="headerlink" title="浅度复制"></a>浅度复制</h2><p>浅度复制指按照引用复制对象<br>简单的按照成员复制对象可以通过派生于System. Object的MemberwiseClone()方法来完成，这是一个受保护的方法，这个方法提供的复制功能称为浅度复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Content </span><br><span class="line">&#123;</span><br><span class="line">    public int val;</span><br><span class="line">&#125;</span><br><span class="line">public class Cloner </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public Cloner(int newVal) =&gt; MyContent.val = newVal;</span><br><span class="line">    public object GetCopy() =&gt; MemberwiseClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cloner mySource = new Cloner(5);</span><br><span class="line">Cloner myTarget = (Cloner) mySource.GetCopy();</span><br><span class="line">Console.WriteLine($ &quot;myTarget.MyContent.Val=&#123;myTarget.MyContent.val&#125;&quot;);</span><br><span class="line">mySource.MyContent.val = 2;</span><br><span class="line">Console.WriteLine($ &quot;myTarget.MyContent.Val=&#123;myTarget.MyContent.val&#125;&quot;);</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><h2 id="深度复制"><a href="#深度复制" class="headerlink" title="深度复制"></a>深度复制</h2><p>复制的是一个对象的值<br>可以实现一个ICloneable接口，以标准方式进行深度复制，如果使用这个接口，就必须实现它包含的Clone()方法，这个方法返回一个System. Object的值，我们可以采用各种处理方式，实现所选的任何一个方法体来得到这个对象，如果愿意就可以进行深度复制，但不是必须的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Cloner: ICloneable </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public Cloner(int newVal) =&gt; MyContent.val = newVal;</span><br><span class="line"></span><br><span class="line">    public object Clone() </span><br><span class="line">    &#123;</span><br><span class="line">        Cloner clonedCloner = new Cloner(MyContent.val);</span><br><span class="line">        return clonedCloner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //public object GetCopy() =&gt; MemberwiseClone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意在比较复杂的对象系统中，调用Clone是一个递归过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Cloner: ICloneable </span><br><span class="line">&#123;</span><br><span class="line">    public Content MyContent = new Content();</span><br><span class="line">    public object Clone() </span><br><span class="line">    &#123;</span><br><span class="line">        Cloner clonedCloner = new Cloner();</span><br><span class="line">        clonedCloner.MyContent = MyContent.Clone();</span><br><span class="line">        return clonedCloner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E6%B5%85%E5%BA%A6%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C#-迭代器</title>
      <link>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <guid>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <pubDate>Tue, 06 Aug 2019 08:11:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;p&gt;只要实现了IEnumerable接口，就可以使用foreach循环&lt;br&gt;在foreach循环中，迭代一个collectionObj
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>只要实现了IEnumerable接口，就可以使用foreach循环<br>在foreach循环中，迭代一个collectionObject集合的过程如下：</p><ol><li>调用collectionObject. GetEnumerator(), 返回一个IEnumerator引用，这个方法可通过IEnumerable接口的实现代码来获得，但这是可选的。</li><li>调用所返回的IEnumerator接口的MoveNext()方法。</li><li>如果MoveNext() 方法返回true，就使用IEnumerator接口的Current属性来获取对象的一个引用，用于foreach循环</li><li>重复前面两步，直到MoveNext()方法返回false为止，此时循环停止</li></ol><h2 id="IEnumerable和IEnumerator使用场景："><a href="#IEnumerable和IEnumerator使用场景：" class="headerlink" title="IEnumerable和IEnumerator使用场景："></a>IEnumerable和IEnumerator使用场景：</h2><ol><li>如果要迭代一个类，则使用方法GetEnumerator(), 其返回类型是IEnumerator。</li><li>如果要迭代一个类成员，例如一个方法，则使用IEnumerable。</li></ol><p><strong>在迭代器块中，使用yield关键字选择要在foreach循环中使用的值</strong><br><code>yield return &lt; value &gt;;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Program </span><br><span class="line">&#123;</span><br><span class="line">    public static IEnumerable SimpleList() </span><br><span class="line">    &#123;</span><br><span class="line">        yield return &quot;string 1&quot;;</span><br><span class="line">        yield return &quot;string 2&quot;;</span><br><span class="line">        yield return &quot;string 3&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args) </span><br><span class="line">    &#123;</span><br><span class="line">        foreach(var x in SimpleList()) </span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Program </span><br><span class="line">&#123;</span><br><span class="line">    private long min;</span><br><span class="line">    private long max;</span><br><span class="line">    public Program(): this(2, 100) &#123;&#125;</span><br><span class="line">    public Program(long minimum, long maxinum) </span><br><span class="line">    &#123;</span><br><span class="line">        if (minimum &lt; 2) </span><br><span class="line">        &#123;</span><br><span class="line">            min = 2;</span><br><span class="line">        &#125; else </span><br><span class="line">        &#123;</span><br><span class="line">            min = minimum;</span><br><span class="line">        &#125;</span><br><span class="line">        max = maxinum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IEnumerator GetEnumerator() </span><br><span class="line">    &#123;</span><br><span class="line">        for (var possiblePrime = min; possiblePrime &lt;= max; possiblePrime++) </span><br><span class="line">        &#123;</span><br><span class="line">            bool isPrime = true;</span><br><span class="line">            for (var possibleFactor = 2; possibleFactor &lt;= (long) Math.Floor(Math.Sqrt(possiblePrime)); possibleFactor++) </span><br><span class="line">            &#123;</span><br><span class="line">                var remainderAfterDivision = possiblePrime % possibleFactor;</span><br><span class="line">                if (remainderAfterDivision == 0) </span><br><span class="line">                &#123;</span><br><span class="line">                    isPrime = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (isPrime) </span><br><span class="line">            &#123;</span><br><span class="line">                yield</span><br><span class="line">                return possiblePrime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void Main(string[] args) </span><br><span class="line">    &#123;</span><br><span class="line">        var primeFrom2to1000 = new Program(55, 100);</span><br><span class="line">        foreach(long i in primeFrom2to1000) </span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write($ &quot;&#123;i&#125;   &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器和集合"><a href="#迭代器和集合" class="headerlink" title="迭代器和集合"></a>迭代器和集合</h2><p>在字典类型的集合中的对象使用迭代器进行迭代存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Animal: DictionaryBase </span><br><span class="line">&#123;</span><br><span class="line">    public void Add(string newID, Animal newAnimal) </span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary.Add(newID, newAnimal);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Delete(string animalID) </span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary.Remove(animalID);</span><br><span class="line">    &#125;</span><br><span class="line">    public Animal this[string animalID] //声明索引器</span><br><span class="line">    &#123;</span><br><span class="line">        get </span><br><span class="line">        &#123;</span><br><span class="line">            return (Animal) Dictionary[animalID];</span><br><span class="line">        &#125;</span><br><span class="line">        set </span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary[animalID] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可在这段代码中添加如下的简单迭代器，以便执行预期操作(对子类特有的操作)：//<strong>不加此方法，程序在编译的时候可以编译过去，但是会在运行时报错</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public new IEnumerator GetEnumerator() </span><br><span class="line">&#123;</span><br><span class="line">    foreach(object animal in Dictionary.Values) </span><br><span class="line">    &#123;</span><br><span class="line">        yield</span><br><span class="line">        return (Animal) animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可使用下面的代码来迭代集合中的Animal对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var animal1 = new Animal();</span><br><span class="line">animal1.Add(&quot;01&quot;, new Animal() </span><br><span class="line">&#123;</span><br><span class="line">    Name = &quot;dog&quot;</span><br><span class="line">&#125;);</span><br><span class="line">animal1.Add(&quot;02&quot;, new Animal());</span><br><span class="line">animal1.Add(&quot;03&quot;, new Animal());</span><br><span class="line">animal1.Add(&quot;04&quot;, new Animal());</span><br><span class="line">foreach(Animal a in animal1) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://qiyanan.com/2019/08/06/C-%E8%BF%AD%E4%BB%A3%E5%99%A8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
