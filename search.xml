<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C#-static关键字]]></title>
    <url>%2F2019%2F08%2F05%2FC-static%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-XML]]></title>
    <url>%2F2019%2F08%2F04%2FC-XML%2F</url>
    <content type="text"><![CDATA[XMLXML基础 XML是一种标记语言，与HTML很类似 XML的设计宗旨是持久化或传递数据，而非显示数据 XML标签没有被预定义，我们可以根据需要自行定义标签，具有自我描述性 XML本质上仅仅是才纯文本 XML模式XML文档可以用模式来描述，模式是另一个XML文件，描述了允许在一个特定的文档中使用的元素和特性 XML文档对象模型常用的DOM类：XmlNode: 这个类表示文档树中的一个节点，是许多类的基类，如果这个节点表示XML文档的根，就可以从它导航到文档的任意位置XmlDocument: 扩展了XmlNode类，但通常是使用XML的第一个对象，因为这个类用于加载磁盘或其他地方的数据并在这些位置保存数据XmlElement: 表示XML文档中的一个元素，XmlElement派生于XmlLinkedNode，XmlLinkedNode派生于XmlNodeXmlAttribute: 表示一个特性，与XmlDocument类一样，派生于XmlNode类XmlText：表示开始标记和结束标记之间的文本XmlNodeList: 标识一个节点集合 XmlDocument12var document = new XmlDocument();document.Load(@&quot;C:\地址&quot;);、//文件名是一个绝对路径 XmlElement属性 FirstChild该属性返回当前节点之后的第一个子节点 LastChild返回当前节点之后的最后一个子节点 ParentNode返回当前节点的父节点 NextSibling返回有相同父节点的下一个节点 HasChildNodes检查当前元素是否有子元素，而不是必须获取FirstChild的值并检查是否为null 获取节点值 InnerText 获取当前节点中所有子节点的文本，把它作为一个串联字符串返回 InnerXml 返回类似于InnerText的文本 Value Value属性是操作文档中信息的最精炼方式 创建节点 CreateNode创建任意类型的节点，该方法有三个重载，两个允许创建XmlNodeType 枚举中所列出的类型，另一个允许把要使用的节点类型指定为字符串， CreateElement只能创建XmlElement类型的节点 CreateAttribute只能创建XmlAttribute类型的节点 CreateTextNode创建XmlTextNode类型的节点 CreatCommen创建注释 插入节点 AppendChild把一个节点追加到XmlNode类型或派生类型的节点上 InsertAfter可以控制插入新节点的位置，该方法有两个参数，第一个是新节点，第二个是在其后插入新节点的节点 InsertBefour新节点在参考节点之后 删除节点 RemoveAll删除节点之上的所有子节点，并且删除字典的特性 RemoveChild删除节点上的一个子节点，返回从文档中删除的节点 选择节点 SelectSingleNode选择一个节点 SelectNodes以XmlNodeList类的形式返回一个节点集合 XML转换为JSONC# 系统库有限的支持JSON. 但是可以使用免费的第三方类库将XMl转换为JSON.]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub使用技巧]]></title>
    <url>%2F2019%2F08%2F04%2FGitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[GitGit两大特点 版本控制 分布式 git最基本操作初始化仓库：git init将一个文件添加到暂存区git add code.txt创建一个版本记录git commit -m &#39;verson1&#39;(版本的说明信息)查看版本记录git log版本回退git reset --hard head^ /hard head~1-100再次返回git reset --hard 版本号查看之前的操作记录git reflog查看当前文件状态git status未添加到暂存区之前撤销改动(增删改)git checkout -- 文件名撤销暂存区的修改git reset HEAD file对比文件不同 工作区文件与版本文件对比git diff HEAD – code.txt–代表版本文件++代表工作区文件 对比两个版本之间某个文件的不同git diff HEAD HEAD^ – code.txt 删除文件 不放在暂存区rm 文件名 放在暂存区git rm 文件名 git分支操作查看分支git branch创建分支git branch 分支名创建并切换一个新的分支git checkout -b 分支名切换分支git checkout master合并git merge 分支名删除分支git branch -d 分支名合并冲突(两个分支上同时提交且编辑同一个文件) 每次操作暂存区内容都必须git commit 创建版本记录 工作区(Working Directory)电脑中的目录，就是一个工作区 版本库(Repository)工作区有一个隐藏目录.git, 这个不是工作区，而是git的版本库git的版本库里存了很多东西，其中最重要的就是称为stage的暂存区，还有git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-Lambda表达式]]></title>
    <url>%2F2019%2F08%2F04%2FC-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Lambda表达式“Lambda表达式”是一个匿名函数，是一种高效的类似于函数式编程的表达式，Lambda简化了了开发中需要编写的代码量，它可以包含表达式和语句，并且可用于创建委托或表达式目录树类型，支持带有可绑定到委托或表达式树的输入参数的内联表达式。lambda表达式使用=&gt;运算符，该运算符读作”goes to”。Lambda运算符的左边是输入参数，右边是表达式或语句块。x =&gt; x*x可以将此表达式分配给委托类型123456delegate int del(int i);static void Main(string[] args)&#123; del myDelegate = x =&gt; x * x; int j = myDelegate(5); //j = 25&#125; 目录树类型123456789101112using System.Linq.Expressions;namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; Expression&lt;del&gt; myET = x =&gt; x * x; &#125; &#125;&#125; 表达式位于=&gt;运算符右侧的lambda表达式称为”表达式lambada”,表达式Lambda会返回表达式的结果，并采用以下基本形式(input parameters) =&gt; expression仅当lambda只有一个输入参数时，括号才是可选的；否则括号是必须的，括号内的两个或更多个输入参数使用逗号加以分隔；(x, y) =&gt; x == y有时，编译器难以或无法推断输入类型。如果出现这种情况，你可以显示指定类型(int x, string s) =&gt; s.Length &gt; x使用空括号指定零个输入参数：() =&gt; SomeMethod()当Lambada表达式中有多个语句时(input paramenters) =&gt; {statement;}]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-LINQ]]></title>
    <url>%2F2019%2F07%2F28%2FC-LINQ%2F</url>
    <content type="text"><![CDATA[LINQ定义一个匿名类型对象： var obj = new {myTitle = &quot;anonymous type&quot;, myOtherParam = new int[] { 1, 2, 3, 4 } }; 扩展函数： 扩展方法必须在一个非嵌套、非泛型的静态类中定义 扩展方法必须是一个静态方法 扩展方法至少要有一个参数 第一个参数必须附加this关键字作为前缀 第一个参数不能有其他修饰符（比如ref或者out） 第一个参数不能是指针类型 LINQ 查询操作符.net的设计者在类库中定义了一系列的扩展方法来方便用户操作集合对象，这些扩展方法构成了LINQ的查询操作符扩展方法有Where, Max, Select, Sum, Any, Average, All, Concat等都是针对IEnumberable的对象进行扩展基本LINQ查询操作 获取数据源在LINQ查询中，第一步是指定数据源，在LINQ查询中，先使用from子句引入数据源和范围变量 筛选使用where子句生成结果，查询仅返回表达式为true的元素 中间件排序orederby子句根据要排序类型的默认比较器，对返回序列中的元素排序，字符串比较顺序默认从A到Z进行排序，逆序使用orderby…descendingz子句 分组group 子句用于对所获得的结果进行分组，使用group子句结束查询时，结果将以列表的形式列出，列表中的每个元素都是具有key成员的对象，列表中的元素根据该键杯分组，在循环访问生成组序列的查询时，必须使用嵌套foreach循环，外层循环访问每个组，内层循环访问每个组的成员，如果必须引用某个组操作的结果，可使用into关键字创建能被进一步查询的标识符 联接联接操作在不同序列间创建关联 选择(投影)Select子句指定在执行查询时产生的值的类型，查询表达式必须以select子句或group子句结尾 12345678910111213141516171819202122232425List&lt;Customers&gt; customers = new List&lt;Customers&gt;() &#123; new Customers&#123; Name = &quot;QIyanan&quot;, City = &quot;Gansu&quot;, Age = 16 &#125;, new Customers&#123; Name=&quot;IkeQi&quot;,City=&quot;USA&quot;,Age=18&#125;, new Customers&#123; Name=&quot;kingQi&quot;,City=&quot;London&quot;,Age=20&#125;, new Customers&#123; Name=&quot;kingZhang&quot;,City=&quot;London&quot;,Age=22&#125;, new Customers&#123; Name=&quot;kingWang&quot;,City=&quot;London&quot;,Age=24&#125;, new Customers&#123; Name=&quot;kingSun&quot;,City=&quot;London&quot;,Age=25&#125;&#125;;var result = from customer in customers where customer.City == &quot;London&quot; &amp;&amp; customer.Name == &quot;kingQi&quot; orderby customer.Age descending select customer;var queryCustomersByCity = from cust in customers group cust by cust.City;foreach(var customerGroup in queryCustomersByCity)&#123; Console.WriteLine(customerGroup.Key); foreach(var customer in customerGroup) &#123; Console.WriteLine($&quot; &#123;customer.Name&#125;&quot;); &#125;&#125;foreach (var customer in result)&#123; Console.WriteLine(customer.Name);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void Main(string[] args)&#123; var studentQuery = from student in students where student.Scores[0] &gt; 90 &amp;&amp; student.Scores[3] &lt; 80 orderby student.Scores[0] descending select student; foreach (var student in studentQuery) &#123; Console.WriteLine($&quot; &#123;student.Last&#125;, &#123;student.First&#125;, &#123;student.Scores[0]&#125;&quot;); &#125; Console.WriteLine(&quot;===============================================&quot;); var studentQuery2 = from student in students group student by student.Last[0]; foreach (var studentGroup in studentQuery2) &#123; Console.WriteLine(studentGroup.Key); foreach (var student in studentGroup) &#123; Console.WriteLine($&quot; &#123;student.Last&#125;, &#123;student.First&#125;&quot;); &#125; &#125; Console.WriteLine(&quot;===============================================&quot;); var studentQuery3 = from student in students group student by student.Last[0] into studentGroup orderby studentGroup.Key select studentGroup; foreach (var groupOfStudents in studentQuery3) &#123; Console.WriteLine(groupOfStudents.Key); foreach (var student in groupOfStudents) &#123; Console.WriteLine(&quot; &#123;0&#125;, &#123;1&#125;&quot;, student.Last, student.First); &#125; &#125; Console.WriteLine(&quot;===============================================&quot;); var studentQuery5 = from student in students let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3] where totalScore / 4 &lt; student.Scores[0] select student.Last + &quot; &quot; + student.First; foreach (string s in studentQuery5) &#123; Console.WriteLine(s); &#125; Console.WriteLine(&quot;===============================================&quot;); var studentQuery6 = from student in students let totalScore = student.Scores[0] + student.Scores[1] + student.Scores[2] + student.Scores[3] select totalScore; double averageScore = studentQuery6.Average(); Console.WriteLine($&quot;Classaverage score = &#123;averageScore&#125;&quot;); Console.WriteLine(&quot;===============================================&quot;); var studentQuery7 = from student in students where student.Last == &quot;Garcia&quot; select student.First; Console.WriteLine(&quot;The garcias in the class are:&quot;); foreach (string s in studentQuery7) &#123; Console.WriteLine(s); &#125;&#125; LINQ查询函数Where(); 查询结果过滤1234List&lt;int&gt; list0 = new List&lt;int&gt; &#123; 6, 4, 2, 7, 9, 0 &#125;;list0.Where(x =&gt; x &gt; 5);list0.Where(x =&gt; x &gt;= 1).Where(x =&gt; x &lt;= 5);list0.Where(x =&gt; x &gt;= 1 &amp;&amp; x &lt;= 5); Select(), SelectMany();处理结果会传回一个对象，这个对象可以是现在对象，也可以是匿名类型在LINQ语句中的select new语句，会自动被编译器转换Select()1234567var Num = from a in list0 where a &gt; 3 select new &#123; Number = a &#125;;Console.WriteLine(Num.FirstOrDefault().Number); 1var selectNum = list0.Where(x =&gt; x &gt; 3).Select(x =&gt; new &#123; Number = x &#125;); SelectMany()类似于数据库中的CrossJoin1234567List&lt;int&gt; list1 = new List&lt;int&gt;() &#123; 1, 2, 3, 4, 5 &#125;;List&lt;int&gt; list2 = new List&lt;int&gt;() &#123; 6, 4, 5, 7, 9, 0 &#125;;var query = list1.SelectMany(x =&gt; list2);foreach (var iterm in query)&#123; Console.WriteLine(iterm);&#125; GroupBy()会按照给定的key(keySelector)以及内容elementSelector,产生群组后的结果GroupBy()设置了使用数列本身作为Key值，并且利用这个Key分组产生分组的数据12345678910List&lt;int&gt; list = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5, 1, 5, 4, 3, 2, 5, 5, 5, 6, 2, 3, 6 &#125;;var query = list.GroupBy(x =&gt; x);foreach (var item in query)&#123; Console.WriteLine($&quot;numer is &#123;item.Key&#125;, numer has &#123;item.Count()&#125;&quot;); foreach (var x in item) &#123; Console.WriteLine($&quot; &#123;x&#125;&quot;); &#125;&#125; ToLookUp()返回值是一个泛型Lookup&lt;TKey, TElement&gt;, 看起来和GroupBy()类似，但是Yolookup是立即执行，GroupBy是延迟执行12345678910111213141516var marrks = new[]&#123; new &#123; Mark = 90, Group = &quot;A&quot;&#125;, new &#123; Mark = 80, Group = &quot;B&quot;&#125;, new &#123; Mark = 70, Group = &quot;C&quot;&#125;, new &#123; Mark = 60, Group = &quot;D&quot;&#125;,&#125;;var lookUpValue = marrks.ToLookup(x =&gt; x.Group);foreach(var item in lookUpValue)&#123; Console.WriteLine(&quot;=========Group:&#123;0&#125;===========&quot;,item.Key); foreach(var result in item) &#123; Console.WriteLine(result.Group+&quot; &quot;+result.Mark); &#125;&#125; Join将两个集合进行连接，即数据库中的Inner Join使用LINQ语句：12345678910111213141516171819202122232425var Mark = new[]&#123; new &#123;Name = &quot;C&quot; , Mark = 65&#125;, new &#123;Name = &quot;A&quot; , Mark = 70&#125;, new &#123;Name = &quot;B&quot; , Mark = 80&#125;&#125;;var Age = new[]&#123; new &#123;Name = &quot;B&quot; , Age = 18&#125;, new &#123;Name = &quot;C&quot; , Age = 17&#125;, new &#123;Name = &quot;A&quot; , Age = 20&#125;&#125;;var query = from mk in Mark join ee in Age on mk.Name equals ee.Name select new &#123; name = mk.Name, mark = mk.Mark, age = ee.Age &#125;;foreach(var item in query)&#123; Console.WriteLine($&quot;name &#123;item.name&#125;, Score &#123;item.mark&#125;, Age &#123;item.age&#125;&quot;);&#125; 使用LINQ函数：12345var quer1 = Mark.Join(Age, mk =&gt; mk.Name, ae =&gt; ae.Name, (mk, ae) =&gt; new &#123; name = mk.Name, mark = mk.Mark, age = ae.Age &#125;);foreach (var item in quer1)&#123; Console.WriteLine($&quot;name &#123;item.name&#125;, score&#123; item.mark&#125;, age&#123;item.age&#125;&quot;);&#125; 其中Mark是第一个集合，Join方法的第一个参数Age是第二个集合，mk =&gt; mk.name 是 第一个集合的外键，ae=&gt;ae.Name是第二个集合的外键。GroupJoin;将两个集合进行联接，并对结果进行分组12345678910111213//定义国家类class Country&#123; public string CountryName &#123; get; set; &#125;&#125;//定义省类class Province&#123; public Country OwnerCountry &#123; get; set; &#125; public string ProvinceName &#123; get; set; &#125; public string ProvinceSize &#123; get; set; &#125; public string ProvinceSpot &#123; get; set; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//对国家类进行实例化Country c1 = new Country()&#123; CountryName = &quot;China&quot;&#125;;Country c2 = new Country()&#123; CountryName = &quot;America&quot;&#125;;Country c3 = new Country()&#123; CountryName = &quot;Korea&quot;&#125;;Country c4 = new Country()&#123; CountryName = &quot;Russian&quot;&#125;;//对省实例化Province p1 = new Province()&#123; ProvinceName = &quot;Hunan&quot;, ProvinceSize = &quot;200&quot;, ProvinceSpot = &quot;Old City&quot;, OwnerCountry = c1&#125;;Province p2 = new Province()&#123; ProvinceName = &quot;Chicago&quot;, ProvinceSize = &quot;150&quot;, ProvinceSpot = &quot;Linkin Park&quot;, OwnerCountry = c2&#125;;Province p3 = new Province()&#123; ProvinceName = &quot;Seoul&quot;, ProvinceSize = &quot;100&quot;, ProvinceSpot = &quot;Tian Tian World&quot;, OwnerCountry = c3,&#125;;Province p4 = new Province()&#123; ProvinceName = &quot;Hunan&quot;, ProvinceSize = &quot;200&quot;, ProvinceSpot = &quot;Tian Meng Mountain&quot;, OwnerCountry = c1&#125;;Province p5 = new Province()&#123; ProvinceName = &quot;Moscow&quot;, ProvinceSize = &quot;80&quot;, ProvinceSpot = &quot;Moscow University&quot;, OwnerCountry = c4&#125;;Province p6 = new Province()&#123; ProvinceName = &quot;Moscow&quot;, ProvinceSize = &quot;80&quot;, ProvinceSpot = &quot;HelloWorld&quot;, OwnerCountry = c4&#125;; 12345678910//定义省集合List&lt;Province&gt; provinces = new List&lt;Province&gt;&#123; p1,p2,p3,p4,p5,p6&#125;;//定义国家集合var countries = new List&lt;Country&gt;&#123; c1,c2,c3,c4&#125;; 使用Join连接12345678910111213141516 //使用Join连接 var joinResult = countries.Join(provinces, country =&gt; country, province =&gt; province.OwnerCountry, (country, province) =&gt; new &#123; countryName = country.CountryName, provinceName = province.ProvinceName, size = province.ProvinceSize, spot = province.ProvinceSpot &#125;); foreach(var item in joinResult) &#123; Console.WriteLine($&quot;countryName is &#123;item.countryName&#125; , provinceName is &#123;item.provinceName&#125; , size is &#123;item.size&#125;, spot is &#123;item.spot&#125;&quot;); &#125; Console.ReadKey();&#125; 使用GroupJoin12345678910111213var groupJoinResult = countries.GroupJoin(provinces, country=&gt;country, province =&gt; province.OwnerCountry, (country,province) =&gt; new&#123; Name=country.CountryName, ProvinceSet=province.Select(x=&gt;x)&#125;);foreach (var item in groupJoinResult)&#123; Console.WriteLine(item.Name); foreach(var p in item.ProvinceSet) &#123; Console.WriteLine(p.ProvinceName + &quot; &quot; + p.ProvinceSize + &quot; &quot; + p.ProvinceSpot); &#125;&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-多线程]]></title>
    <url>%2F2019%2F07%2F28%2FC-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程什么是进程？狭义定义：进程就是一段程序的执行过程广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，他是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元进程的特点动态性，并发性，独立性，异步性进程的基本操作获取进程Process[] processes = Process.GetProcesses()；启动进程：1234ProcessStartInfo psi = newProcessStartInfo();//设置psi属性//命令行参数Process newProcess = Process.Start(psi); 杀掉进程：Process.Close()//并非真正结束进程，释放进程所占用的资源Process.Kill()//不建议使用什么是线程？线程，称为轻量级进程，是程序执行流的最小单元，一个标准的线程是由线程ID, 当前指令指针(PC), 寄存器集合和堆栈组成，线程是进程的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源多线程编程.NET程序中基本的线程 Garbage collector 线程：用于垃圾回收 Finalizer线程：用于调度对象的Finalize方法 Main线程：程序的额入口线程 UI线程：用于更新渲染用户界面，存在于Windows Form, WPF, Windows Store类型的程序中 Thread类1234567891011Thread t = new Thread(Run); //创建t.Start(); //启动t.Name = &quot;Hello World&quot;; //设置线程名t.isBackground = true;//设置为后台进程, 随着进程的退出线程也退出Thread.Sleep(1000);//挂起当前线程t.Join();//阻塞当前线程，直到t线程结束t.Abort();终止t，无条件退出，报一个异常t.Interrupt();//当t处于Wait，Sleep或Join时，终止t，且会报一个异常Thread类构造函数可使用下面的delegate作为参数：ThreadStart:public delegate void ThreadStart(); 线程池(ThreadPool)创建线程需要时间和资源，如果有很多不同的小任务要起线程来完成，可以使用ThreaPool创建和管理这些线程，ThreadPool管理着一个线程列表，可以在需要时增减线程的数量，这个数量的上限和下限都是可匹配的，也可以重复利用线程。和使用Thread类创建线程的方式不同，使用ThreadPool时，线程的创建，销毁以及并发线程数等因素皆有ThreadPool统一控制12ThreadPool.QueueUserWorkItem(WaitCallback callBack);ThreadPool.QueueUserWorkItem(WaitCallback callback, Object state); 使用ThreadPool时应注意 ThreadPool中的线程均为后台线程，不能改成前台线程 ThreadPool中的线程不能被显式退出或暂停 ThreadPool中的线程不能被显式的修改线程明和控制优先级 ThreadPool中的线程不能被显式Join，必须使用其他的同步资源手段达到这个目的 正常的线程运行结束后会被销毁，而ThreadPool中的线程会被重复利用 ThreadPool中线程不应该用于管理常驻线程或其他需要一直运行的线程，这种情况应该是使用Thread类穿件一个新的线程 Task类Task是对ThreadPool进行一层抽象封装，旨在是开发专注于上层操作，不用关心底层Thread的控制 Task具有很强的灵活性 可以指定连续的工作 可以区分执行任务的成功与否 可以创建依赖关系，将任务层次化两种表现形式：Task, Task, 后者表示可以返回结果12var tf = new TaskFactory();var t1 = tf.StartNew(); var t2 = Task.Factory.StartNew(TaskMethod);var t3 = new Task(TaskMethod);t3.Start();//表示异步启动Task连续执行Task t1 = new Task(DoOnFirst);Task t2 = t1.ContinueWith(DoOnSecond);Task t3 = t1.ContinueWith(DoOnSecond);Task t4 = t2.ContinueWith(DoOnSecond);Task t5 = t1.ContinueWith(DoOnError,TaskContinuationOptions,OnlyOnfaulted);TaskContinuationOptions枚举参数：OnlyOnFaulted, NotOnFaulted, OnlyOnCancled, NotOnCanceled,OnlyOnRanToToCompletion, ExcuteSynchronously…Task层次执行在父Task中创建一个子Task，就形成了层次依赖关系，父Task结束，则子Task也随着结束Task类常用方法ContinueWith: 创建一个在当前task执行结束后开始执行的新TaskDelay：创建一个在指定Delay时间后完成的TaskRun：返回一个压入ThreadPool的新TaskStart：开始一个TaskWait：等待当前实例Task结束WaitAll：等待所有Task结束WaitAny：等待任意Task结束WhenAll: 创建一个新的Task, 当被传作参数的所有Task都结束后，这个Task会被标识为结束WhenAny: 创建一个新Task, 当被传作参数的任意Task结束后，这个Task会被标识为结束CurrentId：获取当前正在执行的task IDTask类常用属性isCompleted: 判断当前task实例是否已经结束isFaulted：判断当前task实例是否由于一个未捕获的异常而结束Status：获取当前task实例的状态IsCanceled: 判断当前task实例是否被取消Exception：获取导致当前task结束的异常Factory：返回一个Task的工厂用来创建新taskID: 获取当前task实例ID 异步委托如果要创建一个轻量级的线程，一种简单的办法是使用委托(Delegate), 并异步调用它。委托通过线程池来完成异步任务可以使用不同的技术异步调用委托 Poll AsyncWaitHandle AsyncCallback 基本模型：IAsyncResult ar=delegate.BeginInvoke(…, AsyncCallback, …);object obj = delegaye.EndInvoke(ar);async和await关键字async关键字：标识一个方法是异步的。await关键字：用来等待一个异步方法的结果 线程同步进程内部的同步 Lock //区域性加锁，内部实现基于Monitor 123456789101112class Counter&#123; int i; private object thisLock = new object(); public void Increase() &#123; lock (thisLock) &#123; i++; &#125; &#125;&#125; Monitor锁Monitor.Enter(thisLock)释放锁Monitor.Exit(this.Lock);//建议写在finally块中 InterLocked // AutoResetEvent类 //允许线程通过发信号互相通信123AutoResetEvent are = new AutoResetEvent(false);are.WaitOne();//阻塞当前线程，等待信号量are.Set();//设置信号量，唤醒一个等待信号量的线程 多个进程中线程的同步 WaitHandle Mutex Semaphore Event ReaderWriterLockSlim 死锁所谓死锁是指两个或以上的进程在执行过程中，因正度资源而造成的一种互相等待的现象，若无外力作用，他们都无法推进下去。 创建多线程的步骤： 编写线程所要执行的方法 例化Thread类，并传入一个指向线程所要执行方法的委托。（这时线程已经产生，但还没有运行） 调用Thread实例的Start方法，标记该线程可以被CPU执行了，但具体执行时间由CPU决定 123456789101112131415161718192021222324252627282930namespace ConsoleApp2&#123; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; class Program &#123; static void Main() &#123; var p1 = new ThreadTest(); var thread1 = new Thread(new ThreadStart(p1.Thread1)); //该代码可改写为var thread1 = new Thread(p1.Thread1); var thread2 = new Thread(delegate () &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(&quot;I am created by anonymous function&quot;); &#125; &#125;); var thread3 = new Thread(() =&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(&quot;i am created by Lambda expression&quot;); &#125; &#125;); thread1.Start(); thread2.Start(); thread3.Start(); Console.ReadKey(); &#125; &#125; class ThreadTest &#123; public void Thread1() &#123; Console.WriteLine(&quot;this is no parms function&quot;); &#125; &#125;&#125; C# 多线程与Java 多线程异同：都是通过Thread类来实现多线程都是调用start方法来开启一个线程 Java实现多线程一般有三种方法： 继承Thread类,实现thread类里的run()方法 实现Runnable接口，重写run()方法，并将此对象以参数的形式传给Thread对象 实现Callable接口，重写Call()方法，并将此对象传给futureTask对象内，再将FutureTask对象作为参数传入Thread对象内。 C# 实现多线程： 通过ThreadStart委托来实现多线程 使用匿名方法来实现多线程 使用Lambda表达式实现多线程 ThreeadPool实现多线程，只要执行完毕，自动退出ThreadPool.QueueUserWorkItem(p1.Thread1);//委托的方法必须有一个Object类型的参数 Task实现多线程 .NET程序集程序集，简单来说就是一个公共语言运行库(CLR)为宿主的，版本化的，自描述的二进制文件，程序集的构成： 程序集清单 元数据 实现这些类型的MSIL代码 资源集，诸如位图，指针，静态文本等。 程序集分类： 私有程序集（部署在本地） 共享程序集（部署在全局应用缓存——GAC) 类库类库是一个综合性的面向对象的可重用类型集合，这些类库包括：接口，抽象类和具体类类库不等于框架（Franework）类库会在编译之后生成一个dll文件，其他项目可以引用]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-委托]]></title>
    <url>%2F2019%2F07%2F28%2FC-%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[委托:委托就是具有相同返回值类型和参数的方法的抽象 声明委托：delegate &lt;retutrn type&gt; 委托名(参数类型)委托是一个特殊的类，需要实例化，凡是可以声明类的地方，都可以声明委托 泛型委托：Predicate 泛型委托表示的方法需要传入一个T类型的参数，并且返回一个bool类型的返回值1234567891011121314var d1 = new Predicate&lt;int&gt;(Compare);static bool Compare(int a)&#123; var flag = false; if (a &gt; 5) &#123; flag = true; return flag; &#125; else &#123; return flag; &#125;&#125; Action 泛型委托参数0-16个，类型不确定。不能有返回值1234var d1 = new Action&lt;int,string&gt;(Compare);static void Compare(int a,string b)&#123;&#125; Func 泛型委托参数0-16个，类型不确定，必须有一个返回值，返回值为最后一个参数类型12345var d1 = new Func&lt;int,string&gt;(Compare);static string Compare(int a)&#123; return &quot;test Func&quot;;&#125; 多播委托委托对象可使用“+”运算符进行合并，只有两个相同类型的委托可被合并“-”运算符可用于从合并的委托中移除组件委托1234567NumberChanger nc;var nc1 = new NumberChanger(AddNum);var nc2 = new NumberChanger(MultNum);nc = nc1;nc += nc2;nc(5);Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); 输出结果：Value of Num: 75程序执行过程：初始化两个委托nc1，nc2，实现委托的合并操作，执行nc(5)时，实际先执行AddNum(),执行之后紧接着执行MultNum()，因此，结果为75.]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-集合]]></title>
    <url>%2F2019%2F07%2F28%2FC-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合(Collection)ArrayList: 动态数组，需要装箱与拆箱List: 与ArrayList类的泛型等效，性能提高 方法：添加元素：List.Add(T item); 添加一个元素List.AddRange(IEnumerable Collection); 添加一组元素Insert(int index, T item); 在index位置添加一个元素遍历List元素; 使用foreach进行遍历 删除元素：List.Remove(T item); 删除一个值List.RemoveAt(int index); 删除下标为index的元素List.RemoveRange(int index , int count); 从下标index开始，删除count个元素List.Contains(T item); 判断某个元素是否在该List中List.Sort(); 在List里面元素排序,默认是元素第一个字母按升序List.Reverse(); 给List里面元素顺序反转List.Clear(); 清空ListList.Count(); 获取元素数目：List.Find(Predicatematch);搜索与指定谓词所定义的条件相匹配的元素，并返回整个List中的第一个匹配元素123456789101112131415var list = new List&lt;string&gt;();string[] temArr = &#123; &quot;aq&quot;, &quot;qwe&quot;, &quot;qweqwr&quot;, &quot;wqeqw&quot;, &quot;ewq&quot;, &quot;aeqw&quot;, &quot;dad&quot;, &quot;a&quot; &#125;;list.AddRange(temArr);var str = list.Find(x =&gt; &#123; if (x.Length == 1) &#123; return true; &#125; else &#123; return false; &#125; &#125;);Console.WriteLine(str); List.FindLast();搜索与指定谓词所定义的条件相匹配的元素，并返回整个List中的最后一个匹配元素List.TrueForAll();确定是否List中的每个元素都与指定的谓词所定义的条件相匹配List.FindAll();检查与指定谓词所定义的条件相匹配的所有元素List.Take(n);获得前n行 返回值为IEnumetable,T的类型与List的类型一样List.RemoveAll();移除与指定谓词所定义的条件相匹配的所有元素，返回删除的个数Dictionary&lt;[key],[value]&gt;;提供快速的基于键值的元素查找,必须对键值类型进行说明创建及初始化：var myDictonary = new Dictionary&lt;int,string&gt;();添加一个元素：myDictonary.Add(1, &quot;C#&quot;);通过Key查找元素：myDictonary[1];]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-运算符重载]]></title>
    <url>%2F2019%2F07%2F28%2FC-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[运算符重载：重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。12345678910111213141516171819202122232425262728293031323334class Box&#123; public double Length &#123; get; set; &#125; public double Width &#123; get; set; &#125; public double Heigth &#123; get; set; &#125; public double GetVolume() &#123; return this.Length * this.Width * this.Heigth; &#125; public static Box operator +(Box b, Box c) &#123; var box = new Box(); box.Length = b.Length + c.Length; box.Width = b.Width + c.Width; box.Heigth = b.Heigth + c.Heigth; return box; &#125;&#125;static void Main(string[] args)&#123; var box1 = new Box(); box1.Length = 10; box1.Width = 20; box1.Heigth = 30; var box2 = new Box(); box2.Length = 30; box2.Width = 40; box2.Heigth = 50; var box3 = box1 + box2; Console.WriteLine(box1.GetVolume()); Console.WriteLine(box2.GetVolume()); Console.WriteLine(box3.GetVolume()); Console.ReadKey();&#125;]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-文件操作]]></title>
    <url>%2F2019%2F07%2F28%2FC-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[File I/ODirectory 类的常用属性public System.IO.DirectoryInfo Directory { get; }DirectoryName, Exists, isReadOnly, length(当前文件的的大小), Name Directory 类的常用方法:CreateDirectory()在指定路径中创建所有目录和子目录，除非他们已经存在， 如果该目录已存在，此方法不会创建一个新目录，但它将返回DirectoryInfo现有目录的对象。Delete()从指定路径删除空目录Delete(String, Boolean)删除指定的目录，并删除该目录所有的子目录和文件Move()移动目录public static void Move (string sourceDirName, string destDirName)GetDirectories()1public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption); 1public static string[] GetDirectories (string path);//返回路径中子目录的完整名称的数组, 如果未找到任何目录，则为空数组 1public static string[] GetDirectories (string path, string searchPattern) string path: 相对路径或者绝对路径，此字符串不区分大小写string searchPattern: 与path中的子目录的名称匹配的搜索字符串，此参数可以包含有效文本个通配符的组合，不支持正则表达式 12345var directory = Directory.GetDirectories(@&quot;c:\&quot;);foreach (var d in directory)&#123; Console.WriteLine(d);&#125; GetFiles()得到当前目录下所有文件public static string[] GetFiles (string path)Exists()指向现有目录，则为true，如果该目录不存在或者在尝试确定指定目录是否存在时出错，则为false1234567891011121314151617181920212223var directoryPath = @&quot;c:\test&quot;;var filePath = @&quot;MyTest.txt&quot;;if (!Directory.Exists(directoryPath))//尝试确定指定目录是否存在时，则为false&#123; Directory.CreateDirectory(directoryPath);&#125;if (!File.Exists(Path.Combine(directoryPath,filePath)))&#123; using (StreamWriter sw = File.CreateText(Path.Combine(directoryPath, filePath)))//文件夹路径必须存在， &#123; sw.WriteLine(&quot;hello&quot;); sw.WriteLine(&quot;and&quot;); sw.WriteLine(&quot;welcome&quot;); &#125;&#125;using (StreamReader sr = File.OpenText(Path.Combine(directoryPath, filePath)))&#123; string s; while ((s = sr.ReadLine()) != null) &#123; Console.WriteLine(s); &#125;&#125; DirectoryInfo类的常用属性:Exists; FullNam; Name; Parent; Root; DirectoryInfo类的常用方法:初始化：var dir = new DirectoryInfo(Path);Create()创建一个空目录Delete()public override void Delete ();//若当前目录为空则删除public void Delete (bool recursive);//指定是否删除子目录和文件CreateSubdirectory()在指定路径的基础上创建一个或多个子目录12var direcotaryInfo = new DirectoryInfo(@&quot;c:\test\test\test&quot;);direcotaryInfo.CreateSubdirectory(&quot;text&quot;); GetDirectories()public System.IO.DirectoryInfo[] GetDirectories ()GetFiles()public System.IO.FileInfo[] GetFiles ()public System.IO.FileInfo[] GetFiles (string searchPattern);1234foreach (var fi in di.GetFiles(&quot;*2*&quot;))&#123; Console.WriteLine(fi.Name);&#125; MoveTo()public void MoveTo (string destDirName) File与FileInfo的区别：File是静态类，所有方法都是静态的，可以通过类名直接调用，不需要实例化，如果对文件进行少量操作，或者对很多文件进行操作，建议使用FileInfo是普通类，只有实例化对象之后才可以调用其中的方法，如果需要对一个文件进行大量操作，建议使用FileInfo File常用方法：Create(string path)Delete(string path)// 删除文件应先判空1234if (File.Exists(filePath))&#123; File.Delete(filePath);&#125; Move()public static void Move (string sourceFileName, string destFileName)Copy()1public static void Copy (string sourceFileName, string destFileName)//复制以后不允许覆盖同名文件 ReadAllText(string path)public static string ReadAllText(string path)//打开一个文件，读取所有的行，然后关闭文件ReadAllLines(string path)public static string[] ReadAllLines(string path)ReadLines(string path)public static IEnumerable&lt;string&gt; ReadLines(string path)ReadAllBytes(string path)public static byte[] ReadAllBytes(string path) FileInfo类常用属性初始化：var fileinfo = new FileInfo(@&quot;C:\test\test\test.txt&quot;);//路径必须是文件 FileInfo类的常用方法Create()public System.IO.FileStream Create ()Delete()public override void Delete ()MoveTo()public void MoveTo (string destFileName) //将指定文件移到新位置，提供要指定新文件名的选项CopyTo()public System.IO.FileInfo CopyTo (string destFileName)//不允许覆盖源文件1public System.IO.FileInfo CopyTo (string destFileName, bool overwrite)//可以覆盖源文件 遍历一个目录：12345678910111213public void GetAllFiles(string directoryPath)&#123; var rootDirectory = new DirectoryInfo(directoryPath); foreach (var file in rootDirectory.GetFiles()) &#123; Console.WriteLine($&quot;File Name is &#123;file.Name&#125;&quot;); &#125; foreach (var directory in rootDirectory.GetDirectories()) &#123; Console.WriteLine(directory.Name); this.GetAllFiles(directory.FullName); &#125;&#125; 文件内容操作12345Object——&gt;MarshalByRefObject——&gt;Stream——&gt;FileStreamObject——&gt;MarshalByRefObject——&gt;TextReader——&gt;StreramReaderObject——&gt;MarshalByRefObject——&gt;TextWriter——&gt;StreamWriterObject——&gt;MarshalByRefObject——&gt;TextReader——&gt;StringReaderObject——&gt;MarshalByRefObject——&gt;TextWriter——&gt;StringWriter Strean流，提供了读写的方法是以字节码的形式从流中读取内容 FileStream处理的是字节，继承Stream，一个FileStream类的实例实际代表一个文件流，使用FileStream类可以对文件系统上的文件 进行读取，写入，打开和关闭操作public FileStream(string path, FileMode mode, FileAccess access);path指明文件搜所在路径信息mode是FileMode的枚举值，表示打开或者创建的方式CreateNew 创建新文件，如果文件已存在，则IOExcepptionCreate 创建新文件，文件已存在，源文件将被覆盖Open 打开文件，如果文件不存在则报FileNoFoundExceptionOpenOrCreate 打开文件，文件不存在则创建文件Truncate 打开已经存在的文件，清楚文件中的内容，保留文件的创建日期，如果文件不存在，则会跑出异常Append 打开先有文件并把Position设置在文档尾部，如果文件不存在将创建新文件，Append只能同FileAccess.Writer 一起使用access 是FileAccess的枚举值，它控制对文件的访问权限Read 打开文件用于只读Write 打开文件用于读写ReadWrite 打开文件用于读写创建文件：1var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Create, FileAccess.Write); FileStream 类中常用属性bool CanRead 表示是否可以读取bool CanSeek 表示是否支持查找bool CanWrite 表示是否可以写入bool IsAsync 表示是异步还是同步打开bool Length 获取用字节表示的流长度string Name 获取文件的全路径int Read(byte[] array,int offset,int count) //从流中读取字节块并将数据写入给定缓冲区中1234567using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Open, FileAccess.Read))&#123; var array = new byte[fileStream.Length]; fileStream.Read(array, 0, array.Length); var c = Encoding.UTF8.GetChars(array); Console.WriteLine(c);&#125; void Write(byte[] array,int offset,int count) //将字节块写入文件流123456using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))&#123; var name = &quot;qiyanan&quot;; var arrayWrite = Encoding.UTF8.GetBytes(name); fileStream.Write(arrayWrite, 0, arrayWrite.Length);&#125; StreamReader处理的是字符，从流中读取字符构造函数：StreamReader(Stream) //为指定的流初始化StreamReader类的新实例123456using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))&#123; using (var streanReader = new StreamReader(fileStream)) &#123; &#125;&#125; StreamReader(String)为指定的文件名初始化StreamReader类的新实例123using (var streamReader=new StreamReader(@&quot;c:\test\a.txt&quot;))&#123;&#125; StreamReader(Stream, Encoding)默认编码是Unicode, UTF-8是其子集123456using (var fileStream = new FileStream(@&quot;C:\test\a.txt&quot;, FileMode.Append, FileAccess.Write))&#123; using (var streanReader = new StreamReader(fileStream, Encoding.GetEncoding(&quot;GB2312&quot;))) &#123; &#125;&#125; 常用方法Read()单字符读入public override int Read (); //返回值为ascll码ReadLine()行读入public override string ReadLine ()12345678using (var streanReader = new StreamReader(@&quot;C:\test\a.txt&quot;))&#123; string Ichar = null; while ((Ichar=streanReader.ReadLine() )!= null) &#123; Console.WriteLine(Ichar); &#125;&#125; StringReader从字符串读取字符 StreamWriterpublic override void Write(string value)//字符串写入12345using (var streamWriter=new StreamWriter(@&quot;c:\test\a.txt&quot;,true))&#123; var str = &quot;qi yanan is good &quot;; streamWriter.Write(str);&#125; public override void Write(char value) //字符写入public override void Write(char[] buffer)//字符数组写入public virtual void WriteLine () //写入空行，等同于跳到下一行` StringWriter字符串写入 Stream:BufferedStream //提供针对Stream的包装功能，使Stream支持缓存读写功能MemoryStream //提供对内存中一块数据的读写FileStream //提供基本的对文件进行二进制流读写的功能，与文件的类型无关UnmanagedMemoryStream //提供从托管代码访问非托管内存块的能力 文件操作注意事项：不要将文件流一次性读取到内存中，这样很容易造成内存泄漏一定要保证文件流被关闭，可以使用using和try…finallya两种方式用流读写数据时需要注意读写的长度是否准确，避免读写空字符判断StreamReader是否读写结束不可直接判断读取string是否为空StreamReader和StteramWriter是对文本的操作，应注明编码格式 对内存中一块数据的读写1234567891011121314public static void ShowMemoryString(string testString)&#123; using (MemoryStream stream = new MemoryStream()) &#123; if (stream.CanWrite) &#123; byte[] buffer = Encoding.Default.GetBytes(testString); stream.Write(buffer, 0, buffer.Length); byte[] resultBuffer = stream.ToArray(); string resultString = Encoding.UTF8.GetString(resultBuffer); Console.WriteLine(resultString); &#125; &#125;&#125; FileStream对文件进行字节流读写的功能，与文件的类型无关123456789public static void ShowFileContent(string filePath)&#123; FileStream fileStream = File.Open(filePath, FileMode.Open); byte[] fileContentBuffer = new byte[fileStream.Length]; fileStream.Read(fileContentBuffer, 0, fileContentBuffer.Length); fileStream.Close(); string fileContent = Encoding.Default.GetString(fileContentBuffer); Console.WriteLine(fileContent);&#125; 使用using语法糖省略文件流关闭操作1234567891011public static void ShowFileContent(string filePath)&#123; byte[] fileContentBuffer; using(FileStream fileStream = File.Open(filePath, FileMode.OpenOrCreate)) &#123; fileContentBuffer = new byte[fileStream.Length]; fileStream.Read(fileContentBuffer,0,fileContentBuffer.Length); &#125; string fileContent = Encoding.Default.GetString(fileContentBuffer); Console.WriteLine(fileContent);&#125; 分批次读入文件的内容1234567891011121314151617public static void CopyFileContent(string sourceFilePath, string destinationFilePath)&#123; using (FileStream destinationFileStream = File.Open(destinationFilePath, FileMode.Create, FileAccess.Write)) &#123; const int bufferSize = 4 * 1024 * 1024; byte[] fileContentBuffer = new byte[bufferSize]; using (FileStream sourceFileStream = File.Open(sourceFilePath, FileMode.Open, FileAccess.Read)) &#123; int data; do &#123; data = sourceFileStream.Read(fileContentBuffer, 0, fileContentBuffer.Length); destinationFileStream.Write(fileContentBuffer, 0, data); &#125; while (data &gt; 0); &#125; &#125;&#125; FileMode 定义了四种打开文件的方法：Append: 打开一个已有文件，并将光标放置在文件的末尾，如果文件不存在，则创建文件Create: 创建一个新的文件，如果文件已存在，则删除旧文件，然后创建新文件CreateNew：创建一个新文件，如果文件已存在，则抛出异常Open：打开一个已有的文件，如果文件不存在，则抛出异常FileAccess成员有Read, ReadWrite 和Write]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-关键字]]></title>
    <url>%2F2019%2F07%2F28%2FC-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[abstractabstract修饰符可用于类，方法，属性。在类声明中使用abstract指明这个类仅用作其他类的基类，而不用于实例化，标记为抽象的成员必须由派生自抽象类的非抽象类来实现12345678910111213141516171819202122232425262728293031abstract class Shape&#123; public abstract int x &#123; get;&#125; public abstract int GetArea();&#125;class Square : Shape&#123; int side; public Square(int n) &#123; this.side = n; public override int GetArea() &#123; return side * side; &#125; public override int x &#123; get &#123; return x + 10; &#125; &#125; interface I &#123; void N(); &#125; abstract class C : I &#123; public abstract void N(); &#125;&#125; 抽象类功能： 抽象类不能实例化 抽象类可能包含抽象方法和访问器 无法使用sealed修饰符来修改抽象类 派生自抽象类的非抽象类，必须包含全部已继承的抽象方法和访问器的实际实现 抽象方法功能： 抽象方法是隐式的虚拟方法 只有抽象类中才允许抽象方法声明 抽象方法没有主体，仅以 ; 结尾，签名之后没有大括号 {} 抽象方法中不能使用static或virtual关键字修饰 抽象属性： 静态属性上不能使用abstract修饰符 通过包含使用override修饰符的属性声明，可在派生类中写抽象继承属性 async修饰符可将方法，lambda 表达式或匿名方法指定为异步。如果对方法或表达式使用此修饰符，则称其为异步方法 const使用const 关键字声明某个常量字段或常量局部变量，相当于Java中的static final 组合 readonlyconst关键字不同。const字段只能在该字段的声明中初始化。readonly字段可以在声明或者构造函数中初始化。因此，根据所需要使用的构造函数，readonly字段可能具有不同的值。 as将结果显示转换为给定的引用或可以为null值的类型，如果无法进行转换，则as运算符返回null，与强制类型转换不同，as运算符永远不会引发异常 ()强制转换运算符(T)E表达式E的结果显示的转换为T,如果转换失败，则发生编译时错误 TyprOf()用于获取某个类型的System.Type实例， base 关键字用于从子类中访问父类的成员， 调用基类上已被其他方法重写的方法， 指定创建子类实例跳跃父类构造函数 break语句将终止其所在位置的最接近封闭循环或switch语句，控制权传递给已终止语句后面的语句 checked对整型类型算术运算和转换显示启用溢出检查 default(T)生成T类型的默认值：T t = default(T); event声明发布服务器类中的事件,事件是天生的多播委托，没有赋值，只有+=以及-=操作，事件可以做到隔离保护，数据安全。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;namespace ConsoleApp3&#123; public delegate void GreetingDelegate(string name); public class GreetingManager &#123; public event GreetingDelegate greetingDelegate; public void GreetPeople(string name) &#123; greetingDelegate(name); &#125; &#125; class Program &#123; private static void EnglishGreeting(string name) &#123; Console.WriteLine(&quot;Morning , &quot; + name); &#125; private static void ChineseGreeting(string name) &#123; Console.WriteLine(&quot;zao shang hao ,&quot; + name); &#125; //public static void GreetPeople(string name, GreetingDelegate MakeGreeting) //&#123; // MakeGreeting(name); //&#125; static void Main(string[] args) &#123; GreetingManager gm = new GreetingManager(); gm.greetingDelegate += ChineseGreeting; gm.GreetPeople(&quot;ike qi&quot;); gm.greetingDelegate += EnglishGreeting; //gm.greetingDelegate = EnglishGreeting; //gm.greetingDelegate += ChineseGreeting; gm.GreetPeople(&quot;qi ya nan &quot;); //gm.GreetPeople(&quot;Ike Qi&quot;, EnglishGreeting); //GreetingDelegate greetingDelegate=new GreetingDelegate(EnglishGreeting); //greetingDelegate = EnglishGreeting; //greetingDelegate += ChineseGreeting; //greetingDelegate(&quot;qiyanan&quot;); //GreetPeople(&quot;qiyanan&quot;,greetingDelegate); //greetingDelegate -= ChineseGreeting; //greetingDelegate(&quot;zhang hong chao &quot;); Console.ReadKey(); &#125; &#125;&#125; operator和implicit或explicit分别用于定义隐式转换或显式转换，定义转换的类型必须是该转换类型或目标类型。可用两种类型中的任何一种类型来定义两种用户定义类型之间的转换。 extern修饰符用于声明在外部实现的方法，还可以定义外部程序集别名，使得可以从单个程序集中引用同一组件的不同版本 finally通过使用 finally 块，可以清除 try 块中分配的任何资源，即使在 try 块中发生异常，也可以运行代码。 通常情况下，finally 块的语句会在控件离开 try 语句时运行。 fixed可防止垃圾回收器重新定位可移动的变量 is运算符检查表达式的结果是否与给定类型兼容 #lock #获取给定对象的互斥 lock，执行语句块，然后释放 lock。 持有 lock 时，持有 lock 的线程可以再次获取并释放 lock。 阻止任何其他线程获取 lock 并等待释放 lock。当同步对共享资源的线程访问时，请锁定专用对象实例private readonly object balanceLock=new object();避免将以下对象用作lock对象：this，Type实例，字符串实例，包括字符串文本 new 运算符创建类型的新实例， 可用作成员声明修饰符或泛型类型约束。 可以显式隐藏从基类继承的成员。 隐藏继承的成员时，该成员的派生版本将替换基类版本。 虽然可以不使用 new 修饰符来隐藏成员，但将收到编译器警告。 如果使用 new 来显式隐藏成员，将禁止此警告 out作为参数修饰符，它允许按引用而不是按值向方法传递参数。接口和委托的泛型类型参数声明中，该声明指定类型参数为协变。 params关键字可以指定采用数目可变的参数的方法参数。 params关键字之后不允许有任何其他参数，并且在方法声明中只允许有一个 params 关键字。params 参数类型必须是一维数组 ref关键字指示按引用传递的值要使用 ref 参数，方法定义和调用方法均必须显式使用 ref 关键 sealed修饰符可阻止其他类继承自该类 sizeof用于获取非托管类型的大小 可空类型(Nullable)C# 提供了一个特殊的数据类型，Nullable类型，表示一个数据类型可以赋值为空 ?在数据类型后面加上 ? 可使其变成可空类型int? x=null; ??如果 ?? 前面的操作数的结果是null，则返回 ?? 后面操作数的值，否则就是前面操作数的值]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-String成员]]></title>
    <url>%2F2019%2F07%2F28%2FC-String%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[String成员属性Chars(索引器): 获取string对象特定位置的字符 //java必须使用 charAt() 方法获取特定字符123456789static void Main(string[] args)&#123; var str = &quot;1234&quot;; for(int i = 0; i &lt; str.Length; i++) &#123; Console.WriteLine(str[i]); &#125; Console.ReadKey();&#125; length: 获取字符串长度 //C#属于属性，Java属于方法length（） String成员方法Compare(string, string)：比较两个指定的 String 对象，并返回一个指示二者在排序顺序中的相对位置的整数，属于静态方法Format(): 格式化链接字符串public static string Format (string format, object arg0);Contains(): 返回一个bool，指示特定的字符是否在此字符串内public bool Contains (string value);StartsWith(): 确定此字符串实例的开头是否与指定的字符串匹配public bool StartsWith (string value);EndsWith(): 确定此字符串实例的结尾是否与特定的字符串匹配public bool EndsWith (string value);IndexOf(string): 字符串第一次出现的位置public int IndexOf (string value);LastIndexOf(String): 字符串最后一次出现的位置public int LastIndexOf (string value);Replace(string , string): 返回一个新的字符串，字符串调研该方法会把与字符串中第一个参数替换成第二个参数的内容public string Replace (string oldValue, string newValue);Split(Char[]): 分割字符串, 返回一个字符数组123456789static void Main(string[] args)&#123; var str = &quot;1;2;34&quot;; var a = str.Split(&apos;;&apos;); foreach (var b in a) &#123; Console.WriteLine(b); &#125;&#125; Substring(int): 从特定位置切割字符串public string Substring (int startIndex);public string Substring (int startIndex, int length);从指定的字符位置开始且具有指定的长度ToLower(): 转换为小写模式ToUpper(): 转换为大写模式Trim(): 移除字符串中的所有前导和尾部空白字符OrdinalIgnoreCase(): 忽略字符串大小写进行比较 StringBuilder 常用属性Capacity: 获取或设置可包含在当前实例所分配的内存中的最大字符数Chars[Int32]: 获取或设置此实例中指定字符位置处的字符Length: 获取或设置当前 StringBuilder 对象的长度。MaxCapacity: 获取此实例的最大容量。 StringBuilder 常用方法Append(): 追加AppendFormat(“{0}，{1}”，): 格式化追加Clear(): 从当前StringBuilder实例中移除所有字符Equals(Object): 确定指定的对象是否等于指定的对象Insert(int , String): 将字符串插入到指定字符位置Remove(int , int): 将指定范围的字符串从此实例中移除Replace(String , String): 将此实例中出现的所有指定字符串的替换为其他指定字符串 Object类的Equals方法：Equals(object a, object b): 比较值是否相等ReferenceEquals(object a, object b): 比较引用是否相等，对于值类型会先进行装箱,值类型会返回false==: 对于值类型和string，比较值是否相等,对于引用类型，比较引用是否相等]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#-编码规范]]></title>
    <url>%2F2019%2F07%2F28%2FC-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[格式化代码:Crtl K + D ( Visual Studio )花括号 { } 尽量不要省略缩进使用四个空格, 不使用制表符 tab 命名规范:PasCal: 所有单词首字母大写Camel: 首单词首字母小写，其他单词首字母大写以下是具体的命名规范 通用命名约定——单词的选择 为标识符选择易于阅读的名字 可读性 避免使用下划线，连字符 不适用匈牙利命名方式 避免使用与关键字有冲突的标识符 尽量使用CLR通用类型名，例：String, int32, int64 …Namespace的命名：.(|) [[[.Subnamespace]],如：AvePoint.PlatformRecovery.Backup不能根据公司的组织架构来定义命名空间文件组织：不要在一个源文件中包含一个以上的公用类型，要用相同的名字命名文件与类文件结构和命名空间的结构是一致的将using指令放在命名空间之内注释：代码足够清晰不用注释避免块注释不要把注释放在行尾，一般放在上面接口第一个字母大写 I基类使用 base 结尾Bool 类型使用 is，can 等前缀异常处理:尽量使用系统异常使用 throw 抛出异常，不使用 throw e不使用异常写程序逻辑不要百分百吞掉异常日志规范：要在异常日志中保留完整的堆栈信息不在循环体内打 log]]></content>
      <categories>
        <category>C#基础</category>
      </categories>
      <tags>
        <tag>C#基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-File类]]></title>
    <url>%2F2019%2F05%2F21%2FJava-File%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[在Java语言里提供有对于文件操作系统操作的支持，这个支持就在java.io.File类中进行了定义，File类是唯一一个与文件本身操作（创建，删除，重命名等等）有关的类。 File类的基本使用： File类是Comparable接口的一个子类，所以File类的对象是可以做排序处理的。 构造方法：public File(String pathname),设置要操作的完整路径；构造方法：public File(File parent, String child), 设置父路径与子目录 如果要进行文件的基本操作，可以使用如下的方法：创建新的文件：public boolean creatNewFile() throws IOException判断文件是否存在: public boolean exists();删除文件：public boolean delete(); 文件处理 在使用File类进行文件处理的时候需要注意的是：程序——&gt; JVM ——&gt; 操作系统函数——&gt; 文件处理。 在进行文件创建的时候有一个重要的前提：文件的父路径必须首先存在。获取父路径：public File getParentFile();创建目录：public boolean mkdirs();1234567891011121314public class Main &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;D:/hello/demo/demo.txt&quot;); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; if (file.exists()) &#123; file.delete(); &#125; else &#123; System.out.println(file.createNewFile()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-单例模式]]></title>
    <url>%2F2019%2F05%2F12%2FJava-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式的核心本质在于：类内部的构造方法私有化，在类的内部产生实例化对象之后通过static方法获取实例化对象进行类中的结构调用，单例设计模式一般分为两类：懒汉式，饿汉式。 饿汉式12345678910111213141516171819202122232425262728package com.company;public class SingleTon &#123; private SingleTon()&#123; System.out.println(Thread.currentThread().getName()); &#125;; private static SingleTon instance = new SingleTon(); public static SingleTon getInstance()&#123; return instance; &#125; public void print()&#123; System.out.println(&quot;线程执行&quot;); &#125;&#125;package com.company;public class Main &#123; public static void main(String[] args)&#123; // write your code here for(int i=0;i&lt;3;i++)&#123; new Thread(()-&gt;&#123; SingleTon.getInstance().print(); &#125;,&quot;线程&quot;+i).start(); &#125; &#125;&#125; 执行结果：1234线程0线程执行线程执行线程执行 饿汉模式的特点：类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，饿汉式天生是线程安全的，可以直接用于多线程而不会出现问题 懒汉式简单的懒汉模式1234567891011121314151617181920package com.company;public class SingleTon &#123; private SingleTon() &#123; System.out.println(Thread.currentThread().getName()); &#125; private static SingleTon instance = null; public static SingleTon getInstance() &#123; if (instance == null) &#123; instance = new SingleTon(); &#125; return instance; &#125; public void print() &#123; System.out.println(&quot;线程执行&quot;); &#125;&#125; 执行结果123456线程1线程执行线程2线程执行线程0线程执行 该模式下程序是非线程安全的，为了实现线程安全可采用以下三种方式： 使用synchronized方法进行同步：1234567891011121314151617181920package com.company;public class SingleTon &#123; private SingleTon() &#123; System.out.println(Thread.currentThread().getName()); &#125; private static SingleTon instance = null; public static synchronized SingleTon getInstance() &#123; if (instance == null) &#123; instance = new SingleTon(); &#125; return instance; &#125; public void print() &#123; System.out.println(&quot;线程执行&quot;); &#125;&#125; 执行结果：1234线程0线程执行线程执行线程执行 该方式虽然实现了延迟加载，但是和饿汉模式相比，它引入了同步关键字，因此，它的时耗要远远大于饿汉模式下实现单例。 使用双检锁的方法进行同步处理123456789101112131415161718192021222324package com.company;public class SingleTon &#123; private SingleTon() &#123; System.out.println(Thread.currentThread().getName()); &#125; private static volatile SingleTon instance = null; public static SingleTon getInstance() &#123; if (instance == null) &#123; synchronized (SingleTon.class) &#123; if (instance == null) &#123; instance = new SingleTon(); &#125; &#125; &#125; return instance; &#125; public void print() &#123; System.out.println(&quot;线程执行&quot;); &#125;&#125; 运行结果：1234线程0线程执行线程执行线程执行 该方法虽然实现了线程同步，相比于同步方法的时耗会低一些，但任然不是最佳选择 使用内部类维护单例的实例12345678910111213141516171819package com.company;public class SingleTon &#123; private SingleTon() &#123; System.out.println(Thread.currentThread().getName()); &#125; private static class SingletonHolder &#123; private static SingleTon instance = new SingleTon(); &#125; public static SingleTon getInstance() &#123; return SingletonHolder.instance; &#125; public void print() &#123; System.out.println(&quot;线程执行&quot;); &#125;&#125; 执行结果：1234线程0线程执行线程执行线程执行 在这个实现中，当SingleTon类被加载时，其内部类并不会被初始化，而当getInstance()方法被调用时，才会加载SingletonHoder, 从而初始化instance，由于实例的建立是在类加载时完成，故天生对多线程友好，getInstance()方法也不需要使用同步关键字，因此，这种实现方式时比较完美的。]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Class类对象的三种实例化模式]]></title>
    <url>%2F2019%2F05%2F09%2FJava-Class%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[反射之中的所有核心操作都是通过Class类对象展开的，可以说Class类是反射操作的根源所在，如果要获得它的实例化对象，可以采用三种方式完成 【Object类支持】Object类可以根据实例化对象获取Class对象12345678public class Main &#123; public static void main(String[] args) &#123; Person person=new Person(); Class sr=person.getClass(); System.out.println(sr); &#125;&#125; JVM直接支持 类.class的形式实例化1234567public class Main &#123; public static void main(String[] args) &#123; Class sr=Person.class; System.out.println(sr); &#125;&#125; 通过Class.forName(“类名”)实例化123456789101112public class Main &#123; public static void main(String[] args) &#123; Class&lt;?&gt; sr= null; try &#123; sr = Class.forName(&quot;Person&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(sr); &#125;&#125;]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-工厂模式+反射+泛型]]></title>
    <url>%2F2019%2F05%2F09%2FJava-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%8F%8D%E5%B0%84-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[如果要想进行对象的实例化处理，除了可以使用关键字new之外，还可以使用反射机制来完成，那么到底是使用关键字new还是使用反射呢？最好的解释方案是通过工厂模式来解决 工厂模式工厂模式最大特点：客户端的一个程序类不直接牵扯到对象的实例化管理，只与接口发生关联，通过工厂类获取指定接口的实例，传统的工厂模式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.company;public interface Imessage &#123; //消息接口 void send();&#125;package com.company;public class NetMessage implements Imessage &#123; @Override //网络消息类 public void send() &#123; System.out.println(&quot;【网络消息发送】&quot;); &#125;&#125;package com.company;public class CloudMessage implements Imessage &#123; @Override //云消息类 public void send() &#123; System.out.println(&quot;【云消息发送】&quot;); &#125;&#125;package com.company;public class Factory &#123;//工厂类 private Factory()&#123;&#125;; public static Imessage getInstance(String className)&#123; if(&quot;netmessage&quot;.equalsIgnoreCase(className))&#123; return new NetMessage(); &#125;else if(&quot;cloudMessage&quot;.equalsIgnoreCase(className))&#123; return new CloudMessage(); &#125; return null; &#125;&#125;package com.company;public class Main &#123; public static void main(String[] args) &#123; // write your code here Imessage netMessage=Factory.getInstance(&quot;netmessage&quot;); netMessage.send(); Imessage cloudmessage=Factory.getInstance(&quot;cloudmessage&quot;); cloudmessage.send(); &#125;&#125; 此种工厂设计模式属于静态工厂设计模式，如果现在需要追加一个子类，那么工厂模式必须修改，如果不追加此种判断是无法获取指定接口对象的，因此，我们通过工厂模式 + 反射机制来解决问题。 工厂模式 + 反射123456789101112131415161718192021222324252627282930313233343536package com.company;import java.lang.reflect.InvocationTargetException;public class Factory &#123; private Factory() &#123; &#125; public static Imessage getInstance(String className) &#123; Imessage instance = null; try &#123; instance = (Imessage) Class.forName(className).getDeclaredConstructor().newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return instance;// if(&quot;netmessage&quot;.equalsIgnoreCase(className))&#123;// return new NetMessage();// &#125;else if(&quot;cloudMessage&quot;.equalsIgnoreCase(className))&#123;// return new CloudMessage();// &#125;// return null; &#125;&#125;package com.company;public class Main &#123; public static void main(String[] args)&#123; // write your code here Imessage netMessage=Factory.getInstance(&quot;com.company.NetMessage&quot;); netMessage.send(); Imessage cloudmessage=Factory.getInstance(&quot;com.company.CloudMessage&quot;); cloudmessage.send(); &#125;&#125; 当我们在开发过程中，可能存在有大量的接口，并且这些接口都可能需要通过工厂类实例化，此时，该工厂既不能只为一个特定的接口服务，而是应该为所有的接口服务，因此，我们采用工厂模式 + 反射 + 泛型来解决 工厂模式 + 反射 + 泛型123456789101112131415161718192021222324252627282930package com.company;import java.lang.reflect.InvocationTargetException;public class Factory &#123; private Factory() &#123; &#125; public static &lt;T&gt; T getInstance(String className, Class&lt;T&gt; tClass) &#123; T instance = null; try &#123; instance = (T) Class.forName(className).getDeclaredConstructor().newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return instance; &#125;&#125;package com.company;public class Main &#123; public static void main(String[] args)&#123; // write your code here Imessage netMessage=Factory.getInstance(&quot;com.company.NetMessage&quot;,Imessage.class); netMessage.send(); IService houseService=Factory.getInstance(&quot;com.company.HouseService&quot;,IService.class); houseService.service(); &#125;&#125; 此时的工厂设计模式将不再受限指定的接口，可以为所有的接口提供实例化服务]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-多线程]]></title>
    <url>%2F2019%2F05%2F02%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在Java中，实现多线程一般有三种方式： 继承Thread类，实现run()方法，调用start()方法，启动一个线程代码如下：123456789101112131415161718192021222324public class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(currentThread().getName()); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; MyThread myThreadA = new MyThread(); MyThread myThreadB = new MyThread(); MyThread myThreadC = new MyThread(); myThreadA.start(); myThreadB.start(); myThreadC.start(); &#125;&#125; 实现Runnable接口，重写run()方法，并将此对象以参数的形式传给Thread对象，并调用Thread对象的start()方法，开启线程代码如下：12345678910111213141516171819202122232425public class MyThread implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;我正在执行&quot;); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; MyThread myThread=new MyThread(); Thread threadA = new Thread(myThread, &quot;线程A&quot;); Thread threadB = new Thread(myThread, &quot;线程B&quot;); Thread threadC = new Thread(myThread, &quot;线程C&quot;); threadA.start(); threadB.start(); threadC.start(); &#125;&#125; 实现Collable接口，重写Call()方法, 并将它传让FutureTask对象内，再将FutureTask对象传入Thread对象内，调用Thread对象的start()方法开启线程123456789101112131415161718192021import java.util.concurrent.Callable;public class MyThread implements Callable&lt;String&gt; &#123; @Override public String call() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;线程执行&quot; + i); &#125; return &quot;线程执行完毕&quot;; &#125;&#125;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Main &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new MyThread()); new Thread(futureTask).start(); System.out.println(futureTask.get()); &#125;&#125; Runnable 接口和Callable 的区别： Runnable 是在JDK 1.0 的时候提出的多线程实现接口，而Callable是在JDK1.5 之后提出的； java.lang.Runnable 接口之中只提供有一个run()方法，并且没有返回值； java.util.concurrent Callable 接口提供有call() 方法，可以有返回值。想要实现多线程的启动，必须使用Thread类的start()方法]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-继承与组合]]></title>
    <url>%2F2019%2F04%2F29%2FJava-%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[继承继承(inheritance)是指Child类的对象可以使用仅对Father类的对象有效的方法或者属性，它使得这些方法和属性就好像是Child类自己定义的一样，此时Father类是Child类的父类，Child类是Father类的子类。在类结构中，父类的内部对于子类是可见的，所以，通过继承的代码复用是一种“白盒式代码复用”。 组合组合(composition)是指通过对现有的对象进行拼装(组合)产生新的更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以，称这种代码复用是“黑盒式代码复用”。1234567class Queue extends Array&#123; // 继承&#125;class Queue extends Object&#123; private Array asArray //组合&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-OOP]]></title>
    <url>%2F2019%2F04%2F29%2FJava-OOP%2F</url>
    <content type="text"><![CDATA[什么是面向对象的程序设计？什么是面向过程的程序设计程序设计范型，开发程序发的方法，基于面向过程面向过程：分析出解决问题所需要的步骤，使用函数把这些步骤实现，通过顺序执行一组组语句来实现一个个功能，这些语句的执行过程就是整个程序例如：计算器程序，在main()函数里定义一系列的数据结构，然后开始写加减乘除等函数，实现功能面向对象：抽象度更高，眼光集中在解决问题本身，他的目标是使模块的抽象度更高，实现可复用。计算器创建一个Calculator类，在类里定义必要的数据成员，实现功能。 什么是对象？万物皆对象，不但包括具体存在的，还包括抽象的规则，计划等。对象具有状态，可以用数据来描述，例如：一个人，姓名：齐**，年龄：22，体重：65，身高：175等对象具有行为，例如，运动，吃饭，睡觉，敲代码！！！ 什么是类？具有相同或相似性质的对象的集合就是类，例如：人，学生，动物。。。类具有属性：是对象的抽象，例如：姓名，年龄，体重。。。类具有行为：是对对象行为的抽象。。。抽象类：一般情况下，除了继承树的叶子节点以外，其他的所有类都是抽象类具体类：继承树的叶子节点一般情况下是具体类 类的实例化通过类产生对象，叫做类的实例化， 用关键字new语法： 类 实例名 = new 类（）； 运用反射手段，调用java.long.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法。 运用对象的clone()方法 运用反序列化手段，调用java.io.ObjectInputStream 对象的 readObjet()方法。1 和2 都会明确的，显式的调用构造函数；3 是在内存上对已有对象的克隆，所以不会调用构造函数；4 是从文件中还原类的对象，也不会调用构造函数 继承！！！面向对象中类与类之间的一种关系，继承的类称为子类，派生类，而被继承的类称为父类，基类，或者超类，类与类继承之后，除了构造方法，子类具有父类的所有属性和方法，构造方法是调用，不是继承，同时子类可以加入新的属性或者方法。 继承的设计原则：高内聚，低耦合，类的继承层数不能超过三层。如何让对象访问父类有参构造函数？？super封装概念：类将内部数据隐藏，为用户提供对象的属性和行为的接口，用户通过这些接口使用这些类，无需知道这些类内部是如何构成的，不能操作类中的内部数据目的：防止对实现细节的访问封装根据具体的需要，设置使用者的访问权限，并通过 访问修饰符 来实现。一个访问修饰符 定义了一个类成员的范围和可见性。支持的访问修饰符如下所示：Public 完全公开，没有访问限制，；Private 私有成员，在类的内部可以使用，子类，实例都不能访问；Protected 保护成员，该类的内部和继承类中可以访问 多态通过继承实现的不同对象调用相同的方法，表现出不同的行为，称之为多态 接口（Interface）接口就是一种特别的类。只需要定义函数，函数不用实现，接口内定义的函数必须在子类里面全部得实现可以实现多继承]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-重载与重写]]></title>
    <url>%2F2019%2F04%2F29%2FJava-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重载重载(overload) 指编写一个与已有函数同名但是函数参数不同的函数，重载不是一种面向对象的编程，而只是一种语法规则，重载与多态没有直接关系。 特征 相同的范围（在同一个类中） 函数名字相同 参数不同 virtual关键字可有可无 重写重写(override) 指派生类重写基类的虚函数，重写的函数必须有一致的参数表和返回值 特征 不同的范围（分别位于派生类与基类） 函数名字相同 参数相同 基类函数必须有virtual关键字]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-成员内部类的访问方式]]></title>
    <url>%2F2019%2F04%2F28%2FJava-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方式一：在外部提供一个方法创建内部类的对象进行访问。方式二：在其它类直接创建内部类的对象，格式： 内部类 变量名 = new 外部类().内部类();内部类需要注意的细节: 如果在外部类与内部类存在同名的成员变量时，在内部类中默认情况下是访问内部类中的成员变量，可以通过外部类.this.成员变量 来访问外部类的成员变量。 123456789101112131415161718192021public class Test &#123; public int a = 1; public class Tes &#123; public int a = 3; public void out() &#123; System.out.println(&quot;内部类的a值：&quot; + a); System.out.println(&quot;外部类的a值：&quot; + Test.this.a); &#125; &#125; public Test() &#123; new Tes().out(); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 私有的成员内部类只能在外部类提供一个方法创建内部类的对象进行访问，不能再其他类创建对象。 成员内部类一旦出现了静态成员，那么该类也必须使用static修饰。局部内部类在一个类的方法内部定义了另外一个类，那么方法内的类称为局部内部类注意：如果局部内部类访问了局部变量，那么该变量需要用final修饰]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Object类的方法]]></title>
    <url>%2F2019%2F04%2F28%2FJava-Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Object 基类的方法如下：clone(): 创建并返回此对象的一个副本。equals(Object obj): 指示某个其他对象是否和此对象“相等”。finalize(): 当垃圾回收器确定不存在对该对象的的个更多引用时，由对象的垃圾回收器调用此方法。getClass(): 返回一个对象的运行时类。hashCode(): 返回对象的哈希值。notify(): 唤醒在此对象监视器上等待的单个线程。notifyAll()：唤醒在此对象监视器上等待的所有线程。toString(): 返回该对象的字符串表示。wait(): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll()。wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll(), 或者超过指定的时间量。wait(long timeout , int nanos): 导致当前线程等待，直到其他线程调用此对象的notify()或者notifyAll(), 或者其他某个线程中断当前线程，或者超过指定的时间量。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-抽象类和接口]]></title>
    <url>%2F2019%2F04%2F28%2FJava-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[抽象类有时候，基类并不与具体的事物相联系，而是只表达一种抽象的概念，用以为它的派生类提供一个公共的界面，为此，Java引入了抽象类(abstract class)的概念.一个抽象类要注意以下几点： 抽象类只能做为其他类的基类，它不能直接被实例化，且不能使用new操作符； 抽象类允许包含抽象成员，但不是必须的，抽象类可以有非抽象方法； 抽象类不能同时是final的； 如果一个非抽象类从抽象类中诞生，则必须通过重写来实现继承而来的抽象成员； 抽象类可以被抽象类所继承，结果仍是抽象类； 抽象类允许被声明。123456789101112131415161718192021222324252627282930313233abstract class Person //建立抽象类&#123; public abstract void SayHello(); //抽象方法SayHello public void about() &#123; System.out.println(&quot;Abstract Demo&quot;); &#125;&#125;class Student extends Person //实体类Student继承Person&#123; public void SayHello() &#123; // 重写抽象方法SayHello System.out.println(&quot;SayHello&quot;); &#125;&#125;class Nurse extends Person //建立实体类Nurse继承Person&#123; //没有重写抽象方法SayHello，即这个类是错误的&#125;abstract class Pupil extends Person //建立抽象类Pupil继承Person&#123; public void SayHello() &#123; System.out.println(&quot;SayHello&quot;); &#125;&#125;abstract class Worker extends Person //建立抽象类Work继承Person&#123; //抽象类继承抽象类，可以不用重写抽象方法&#125; 接口 接口用于描述系统对外提供的所有服务，因此接口中的成员常量和方法都必须是公开的(public)类型的，确保外部使用者能够访问他们； 接口仅仅描述系统做什么，但不知名如何去做，所以接口中的方法都是抽象(abstract)方法； 接口不涉及和任何具体实例相关的细节，因此，接口没有构造方法，不能被实例化，没有实例变量，只有静态(static)变量； 接口中的变量是所有实现类共有的，即，变量是final类型，也就是常量了； 接口中不能出现变量，属性只能读，不能改； 接口默认的方法是abstract的，接口属性默认是public static final ，且必须赋初值。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合]]></title>
    <url>%2F2019%2F04%2F28%2FJava-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[java 容器类库一共有两种主要类型：Collection和MapCollection 和Map 的区别在于每个容器内每个“槽”所存的元素个数不同，Collection 类型中，每个“槽”只有一个元素，Map类型中，持有key-value关联，类似小型数据库，所有的Java容器都可以自动调整自己的尺寸。各自旗下的子类关系如图：Collection:Map:Collection 的子类如下：&emsp;&emsp;——List: 将以特定顺序存储元素，所以取出来的顺序可能和放入顺序不同&emsp;&emsp;&emsp;&emsp;——ArrayList: 擅长随机访问元素，但在List中插入，删除，移动元素较慢&emsp;&emsp;&emsp;&emsp;——LinkedList: 插入，删除，移动元素方便，随机访问元素慢&emsp;&emsp;——Set：每个值只能保存一个对象，不能含有重复的元素&emsp;&emsp;&emsp;&emsp;——HashSet：使用散列函数&emsp;&emsp;&emsp;&emsp;——TreeSet：使用红黑树&emsp;&emsp;&emsp;&emsp;——LinkedHashSet 使用链表结合散列函数&emsp;&emsp;&emsp;&emsp;——Queue:队列，先进先出的容器Map 的子类如下：&emsp;&emsp;——HashSet&emsp;&emsp;——HashTable&emsp;&emsp;——TreeMap 其他特征: List, Set, Map将所有对象视为Object类型； Collection, List, Set, Map 都是接口，不能被实例化在各种List中，最好的做法是以ArrayList作为默认选择。当插入，删除频繁时，使用LinkedList(), Vector总是比ArrayList慢，在各种Set中，HashSet通常优于HashTree(插入，查找）。只有当需要产生一个经过排序的序列时，采用TreeSet。Hashtree的意义是用来维护其内元素的排序；在各种Map中，HashMap用于快速查找，当元素的个数固定时，Array的效率是最高的HashMap与HashTable的区别都属于Map接口的类，实现了将唯一键映射到特定的值上。HashMap 类没有分类或者排序，它允许一个null键和多个null值HashTable 不允许null键和null值。HashTable的方法是Synchronize的，HashMap不是]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-内存管理]]></title>
    <url>%2F2019%2F04%2F28%2FJava-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[垃圾收集Java中使用被称为垃圾收集器的技术来监视Java程序的运行，当对象不在使用时，就自动释放对象所使用的内存。垃圾收集器是自动运行的，一般情况下，无须显式的请求垃圾收集器，程序运行时，垃圾收集器会不时检查对象的各个引用，并非是无引用对象所占用的内存。调用System 类中的静态gc()方法可以运行垃圾收集器，但这样并不能保证立即回收指定对象。Java垃圾回收机制：gc即垃圾收集机制，是指JVN用于释放那些不再使用的对象所占用的内存。Java的垃圾回收机制时为所有的Java应用进程服务的，而不是为某个特定的进程服务的，因此，任何一个进程都不能命令垃圾回收机制做什么，怎么做或做多少，在JVM垃圾收集器收集一个对象之前，一般要求程序中调用适当的方法来释放资源，但在没有明确释放资源的情况下，Java提供了默认机制终止化该对象来释放资源，这个方法就是finalize()。在finalize()方法返回之后，对象消失，垃圾收集开始执行。 一块内存空间是否符合垃圾收集器收集标准1.给对象赋予了控制null, 以后再也没有调用过2.给对象赋予了新值，即重新分配了内存空间一块内存空间符合了垃圾收集器的收集标准，并不意味着这块内存空间就一定会被垃圾收集器收集 内存管理变量的内存分配情况1.不要试图去假定垃圾收集发生的时间，这一切都是未知的。2.Java提供了一种强行执行的垃圾收集的方法——调用System.gc()，但这是一个不确定方法。3.挑选适合自己的垃圾收集器4.防止内存泄漏5.尽早释放无用对象的引用，对于频繁申请内存和释放内存的操作，最好使用finalize强制执行，或者写自己的finalize方法。 什么是Java中的内存泄漏在Java中，内存泄漏就是存在一些被分配的对象，这些对象有两个特点：1.对象是可达的，即在有向图中，存在通路可以与其相连；2.对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象可以判定位Java中的内存泄漏，这些对象不会被gc所回收，然而他们却占用内存。例如：123456Vector v = new Vector(10);for (int i = 1; i &lt; 100; i++)&#123; Object o = new Object(); v.add(o); o = null;&#125; 内存泄露的主要原因：保留下来却永远不再使用的对象引用。 cloneJava中clone的含义是，假设x是一个非空对象，则：123x.clone() != x //true , 就是说他们不是一个对象x.clone().getClass() == x.getClass() //true, 说明他们是同一个类型的classx.equals(x.clone()) //true, 说明值相等 clone方法是在Object中定义的，而且是proteced 的，只有实现了Cloneable接口，才可以在该类的实例上调用clone方法，否则会抛出CloneNotSupportException，该方法从Object类中继承而来，该接口只是一个标记。]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-序列化]]></title>
    <url>%2F2019%2F04%2F28%2FJava-%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[如何实现Java的序列化？序列化一个对象只需要让他实现Serializable接口（这是一个“标记接口”，tagging interface,没有任何方法）就行，但是，当语言引入序列化概念之后，它有很多标准类库的类，包括primitive的wrapper类，所有的容器类，以及别的很多类，都会相应的发生改变，甚至连Class对象都会被序列化。要想序列化对象，必须先创建一个OutputStream，然后把它嵌进ObjectOutputStream。这是就能调用writeObject() 方法把对象写入OutputStream, 读的时候需要把InputStream嵌到ObjectInputStream中，然后在调用readObject()方法。代码如下：1234567891011121314151617181920212223242526272829303132public class SerSingleton implements java.io.Serializable&#123; String name; private SerSingleton()&#123; System.out.println(&quot;Singleton is create&quot;); name = &quot;SerSingleton&quot;; &#125; private static SerSingleton instance = new SerSingleton(); public static SerSingleton getInstance()&#123; return instance; &#125; public static void createString()&#123; System.out.println(&quot;CreateString in Singleton&quot;); &#125; private Object readResolve()&#123;//阻止新生成的实例，总是返回当前对象 return instance; &#125;&#125;public void test() throw Exception&#123; SerSingleton s1 = null ; SerSingleton s = SerSingleton.getInstance(); //先将实例串化到文件 FileOutputStream fos = new FileOutputStream(&quot;SerSingleton.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(s); oos.flush(); oos.close(); //从文件读出原来的单例类 FileInputStream fis = new FileInputStream(&quot;SerSingleton.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); s1 = (SerSingleton) ois.readObject(); Assert.assertEquals(s,s1); &#125;]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-输入/输出流]]></title>
    <url>%2F2019%2F04%2F28%2FJava-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Java的IO操作有面向字节（Byte）和面向字符（Character）两种方式。&emsp;&emsp;面向字节的操作以8位对二进制数据进行操作，对数据不进行转换，对数据不进行转换，这些类都是InputStream 和OutputStream 的子类，&emsp;&emsp;面向字符的操作以字符为单位进行操作，在读的时候将二进制数据转换为字符，在写的时候将字符转换为二进制数据，这些类都是Reader和Writer的子类。&emsp;&emsp;即以InputStream（输入）/OutputStream（输出）为后缀的是字节流，以Reader（输入）/Writer（输出）为后缀的是字符流。使用FileOutputStream的标准输出12345678910111213public class Main &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;D:/hello/demo/demo.txt&quot;); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; OutputStream outputStream=new FileOutputStream(file,true); String str=&quot;hello world&quot;; outputStream.write(str.getBytes()); outputStream.close(); &#125;&#125; 该程序在整体处理之中，只是创建了文件的父目录，但是并没有创建文件，在程序执行后发现文件可以自动帮助用户创建。使用FileInputStream的标准输入1234567891011public class Main &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;D:/hello/demo/demo.txt&quot;); InputStream inputStream=new FileInputStream(file); byte data[]=new byte[1024]; int len=inputStream.read(data); System.out.println(&quot;[&quot;+new String(data,0,len)+&quot;]&quot;); inputStream.close(); &#125;&#125; 在Writer类里面提供有许多的输出操作方法：输出字符数组：public void write(char[] char) throws IOException输出字符串：public void write(String str) throws IOException使用FileWriter标准输出1234567891011121314public class Main &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;D:/hello/demo/demo.txt&quot;); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); &#125; Writer writer = new FileWriter(file); String str = &quot;hello,world&quot;; writer.write(str); writer.append(&quot;中国人民万岁&quot;); writer.close(); &#125;&#125; 使用Writer输出的最大优势在于可以直接利用字符串完成，Writer是字符流，字符处理的优势在于中文处理Reader类并没有像Writer一样提供有整个字符串的输入处理操作，只能够利用字符数组来实现接收：接收数据：public int read(char[] cbuf) throws IOException:使用FileReader标准输入12345678910111213public class Main &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;D:/hello/demo/demo.txt&quot;); if (file.exists()) &#123; Reader reader = new FileReader(file); char data[] = new char[1024]; int len = reader.read(data); System.out.println(new String(data, 0, len)); reader.close(); &#125; &#125;&#125; 字符流读取的时候只能按照字符数组的形式来实现处理操作下面是Java流类图结构：]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-静态变量与私有变量]]></title>
    <url>%2F2019%2F04%2F27%2FJava-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[static 关键字，可以被应用到类，方法和变量中 static变量&emsp; static变量称作静态变量，静态变量被所有对象共享，内存中只是一个副本，当且仅当被初次加载时会被初始化 static方法&emsp; static方法是没有this的方法，在static方法内部不能调用非静态方法，反过来是可以的，可以在没有创建任意对象的前提下通过本身调用static方法。 Java静态类&emsp; 如果一个类被声明为static，只有一种情况，就是静态内部类（内嵌类）。如果在外部类声明static，程序编译不会通过。1）静态内部类和静态方法一样，只能访问静态的成员变量和方法，不能访问非静态的方法和属性，但是普通类可以访问任意外部类的成员变量和方法2）静态内部类可以声明普通成员变量和方法，而普通内部类不能声明static成员变量和方法3）静态内部类可以单独初始化Inner i = new Outer.Inner();普通内部类初始化：12Outer n = new Outer();Inner i = o.new Inner(); 静态内部类使用场景一般是当外部类需要使用内部类，而内部类无需外部类资源，并且内部类可以单独创建的时候会考虑采用静态内部类的设计。1234567891011121314151617181920212223242526272829303132public class Outer &#123; private String name; private int age; public static class Builder &#123; private String name; private int age; public Builder(int age) &#123; this.age = age; &#125; public Builder withName(String name) &#123; this.name = name; return this; &#125; public Builder withAge(int age) &#123; this.age = age; return this; &#125; public Outer build() &#123; return new Outer(this); &#125; &#125; private Outer(Builder b) &#123; this.age = b.age; this.name = b.name; &#125;&#125; 静态内部类调用外部类的构造函数，来构造外部类，由于静态内部类可以被单独初始化，所以有了以下实现1234public Outer getOuter()&#123; Outer outer = new Outer.Builder(2).withName(&quot;Ike&quot;).build(); return outer;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-传递与引用]]></title>
    <url>%2F2019%2F04%2F27%2FJava-%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Explain call by value and call by reference. Which of this these two does Java support?不管Java参数的类型是什么，一律传递参数的副本对于基本类型而言，传值就是把自己复制一份传递，即使自己的副本变了，自己也不变。对于对象类型而言，它传的引用副本指向自己的地址，而不是自己实际值的副本，原因以下： 对象类型是存储在堆里，速度相对于基本类型比较慢； 对象类型本身比较大，如果采用重新复制对象值的办法，浪费内存且速度又慢。以参数形式传递简单类型的变量时，实际上是将参数的值作为一个副本传进方法函数的，那么在方法函数中不管怎么改变其值，其结果都是改变了副本的值，而不是源值。123456789101112public class Test&#123; public static void test (Boolean test)&#123; test = !test; System.out.println(&quot;In test(boolean) : test = &quot; + test); &#125; public static void main(String[] args)&#123; boolean test = true ; System.out.println(&quot;Before test(boolean) : test = &quot; + test); test(test); System.out.println(&quot;After test(boolean) : test =&quot; + test); &#125;&#125; 运行结果：123Before test(boolean) : test = trueIn test(boolean) : test = falseAfter test(boolean) : test = true]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-反射（Reflection）]]></title>
    <url>%2F2019%2F04%2F27%2FReflection%2F</url>
    <content type="text"><![CDATA[在Java语言里面之所以会有如此众多的开源技术支撑，很大的一部分来自于Java最大的特征——反射机制，如果不能灵活的使用反射进行项目的开发与设计，那么可以说你未接触到Java的精髓。所有的技术实现的目标只有一点：重用性。对于反射机制首先考虑的是“反”与“正”的操作，所谓的“正”操作指的是当我们要使用一个类的时候，一定要先导入程序所在的包，而后根据类进行对象的实例化，并且依靠对象调用类中的方法。但是如果说“反”，根据实例化对象推出其类型。如果要实现反的处理操作，那么首先要采用的就是Object类中所提供的一个方法获取Class对象信息：public final Class&lt;?&gt;getClass();通过getClass()可以帮助使用者找到对象的根源 可以运用反射手段，调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()方法，创建一个对象1234567891011121314ipublic class Main &#123; public static void main(String[] args) &#123; Class&lt;?&gt; sr= null; try &#123; sr = Class.forName(&quot;Person&quot;); Object o = sr.getConstructor().newInstance(); System.out.println(o); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(sr); &#125;&#125;]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-final, finally, finalize的区别]]></title>
    <url>%2F2019%2F04%2F27%2FJava-final-finally-finalize%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[finalfinal 可以用于控制成员，方法，或者是一个类是否可以被重写或者继承等功能 finnal 成员当在类中定义变量时，若在前面加上final关键字，那么，这个变量一旦被初始化，便不可改变，这里的不可变的意思对基本类型来说其值不可变，而对于对象变量来说是其引用不可变，初始化可以在两个地方，一是其定义处，二是在构造函数中，两者只能选其一。当你在方法中不需要改变做为参数的对象变量时，明确使用final进行声明，会防止你无意地修改影响调用方法。 final 方法将方法声明为final有两个原因，第一就是明确已经知道这个方法提供的功能满足要求，不需要进行拓展，并且不允许任何从此类继承的类来重写这个方法，但是可以继承这个方法，即可以直接调用；第二就是允许编译器将所有对此方法的调用转化为inline（行内）调用的机制，它会在调用final方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用，例如：保存断点，压栈等操作，这样可能会使程序效率有所提高。 final 类一个final 类是无法被任何类继承的，也就意味着，此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美，不需要进行修改或扩展。final类中的成员既可以明确指出final也可以不指出。 finalyfinally 关键字是对Java异常处理模型的补充，finally结构使代码总会执行，而不管有无异常发生，使用finally可以维护对象的内部状态，并且可以清理非内存资源。 finalizefinalize是方法名。Java允许使用finalize()方法在垃圾收集器将对象从内存清除出去之前作必要的清理工作。它是Object类中定义的，所有的类都继承了它。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-异常]]></title>
    <url>%2F2019%2F04%2F27%2FJava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[什么是异常在Java程序运行时，常常会出现一些非正常的现象，这种情况称为运行错误。根据其性质可以分为异常和错误。Java程序中，所有抛出的异常都必须从Throwable派生而来。类Throwable有两个直接子类：Error和Exception。一般来说，最常见的错误程序进入死循环，内存泄露等Java错误对应的类为Error类，Error类对象有Java虚拟机生成并抛弃Java异常对应的类为Exception类，Java编译器要求程序必须捕获或声明所有的非运行时异常，但对运行时异常可以不做处理。其中类RuntimeException代表运行时由Java虚拟机生成的异常，原因是编程错误，其他则为非运行异常，原因是程序碰到了意外情况，如输入/输出异常IOException等。 异常关键字Java异常处理的关键语句有五个：try, catch, throw, throws, finally. 其中，try, catch, finally三个语句块应注意：1）try, catch, finally 三个语句块不能单独使用三者可以组成try…catch…finally, try…catch, try…finally三种结构，catch语句可以有一个或者多个，finally语句最多一个。2）try, catch, finally 三个变量的作用域为代码块内部，分别独立而不能互相访问3）若有多个catch块，只会匹配其中一个异常类并执行catch块代码，而不会在执行别的catch块，并且匹配catch语句的顺序是由上到下的。 throw, throws关键字的区别如下throw 关键字用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在头部声明方法可能抛出的异常类型。throws 关键字用于方法体外部的声明部分，仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应当继续抛出。 异常处理中常见的问题过于庞大的try块大量的语句装入一个try块，找出异常不容易；对于这种问题，可以设置多个异常抛出点来解决，异常对象从产生点产生后，到被捕捉后终止生命的全过程中，实际是一个传值过程 异常的完整性在Java语言中，如果一个函数运行时可能会向上层调用者函数抛出一个异常。那么，它就必须在该函数的声明中显式地注明（采用throws关键字）。如果你在程序中利用throw出现一个异常，那么你的程序中必须要用catch处理这个异常。1234567try&#123; //throw Exception&#125;catch (Exception ex)&#123; //find Exception //hand of it&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-运算符]]></title>
    <url>%2F2019%2F04%2F27%2FJava-%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[语言中运算符分为三类：单目运算符，二目运算符，三目运算符。单目运算符只对一个参数进行运算（如++，—-等）；双目运算符就是对两个参数进行运算（如+，-，&gt;,&lt;,等）；三目运算符就是对三个参数进行运算（如？，：）。运算符的优先级别（1级优先级最高，16级最低）：123456789101112131415161级：—— . ()2级：—— ++ --3级：—— new 4级：—— * / %5级：—— + -6级：—— &gt;&gt; &lt;&lt; &gt;&gt; &gt;7级：—— &gt; &lt; &gt;= &lt;=8级：—— == !=9级：—— &amp;10级：—— ^11级：—— !12级：—— &amp;&amp;13级：—— ||14级：—— ?:15级：—— = += -= /= %= ^=16级：—— &amp;= &lt;&lt;= &gt;&gt;= 在Java编程规范中提到：当两个表达式有一个是常量表达式，另一个变量是T时，而常量表达式可以通过被T表示时，输出的结果是T类型。“&amp;”, “|”, “^” 是位运算符并且可以充当布尔逻辑运算符。例：int c = a &amp; b;意思是首先a和b按位与，a是1，b是2，a的二进制数位是0001，b的二进制位是0010，布尔运算符优先级别高于逻辑运算符。&amp;，| 逻辑运算与 &amp;&amp;，|| 运算符的重要区别是，前者是非短路运算，后者是短路运算编译器对 &amp;&amp; 和 || 已经优化过，凡 &amp;&amp; 前面的是false，那么 &amp;&amp; 后面的表达式将不会执行，|| 前面的是true，|| 后面的就不用做了。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 性能调优]]></title>
    <url>%2F2019%2F04%2F23%2FJava-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[程序的性能通过执行速度，内存分配，启动时间，负载承受能力来变现，其中：执行速度：程序的反映是否迅速，响应时间是否足够短。内存分配：内存分配是否合理，是否过多地消耗内存或者存在泄露。启动时间：程序从运行到可以正常处理业务需要花费多长时间。负载承受能力：当系统压力上升时，系统的执行速度，响应时间的上升曲线是否平缓。 性能的参考标准：执行时间：一段代码从开始运行到运行结束，所使用的时间CPU时间：函数或者线程所占用的CPU的时间内存分配：程序在运行时所占用的内存空间磁盘吞吐量：描述I/O使用情况网络吞吐量：描述网络的使用情况响应时间：系统对某用户行为或者事件做出响应的时间，响应时间鱼越短，性能越好]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-类型转换]]></title>
    <url>%2F2019%2F04%2F15%2FJava-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Java 的数据类型分为三大类，即布尔型，字符型和数值型，其中数值型又分为整型和浮点型，相对于数据类型，Java的变量类型为boolean；字符型为char,整型byte、short、int、long;浮点型float、double其中四种整型变量和两种浮点型变量分别对应于不同的精度和范围。此外，编程时还经常用到两种类型变量，即String和Data。 数据类型转换的种类Java数据类型的转换一般分三种，分别是：简单数据类型之间的转换，字符串与其他数据类型之间的转换，其他实用数据类型的转换。 简单数据类型之间的转换在Java中，整型，实型，字符型被视为简单数据类型，这些类型由低级到高级分别为（byte, short,char）——&gt;int——&gt;long——&gt;float——&gt;double。简单数据类型之间的转换又可以分为：低级到高级的自动类型转换，高级到低级的强制类型转换，包装类过滤类型能够转换 自动类型转换低级变量可以直接转换为高级变量，这叫自动类型转换。例如，下面的语句可以在节Java中直接通过 byte b ; i = b ; long 1 = b ; float f = b ;double d = b ;如果低级类型为char型，向高级类型（整型）转换时，会转换为对应的ASCLL码值，例如； char c = &#39;c&#39; ; int i = c ; System.out.println(&quot;output:&quot; + i);输出 : output:99; 强制类型转换int i = 99 ; byte b = (byte)i ; char c = (char)i; 注意：这种转换可能会导致溢出或精度的下降。 包装类过滤类型转换Java 的包装类可以直接将简单类型的变量表示为一个类。Java共有六种包装类，分别是Boolean、Character、Integer、Long、Float和Double。String和Data本身就是类，不存在包装类的概念。在进行简单数据类型之间的抓换时，可以利用包装类进行中间过渡，一般情况下，首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换。例1：float——&gt;double 123float f1 = 100.00f ; Float F1 = new Float(f1) ;Double d1 = F1.doubleValue() ; 例2：double——&gt;int 123double d1 = 100.00;Double D1 = new Double(d1);int i1 = D1.intValue(D1); 例3：int——&gt;double ，自动转换： 12int i1 = 200;double d1 = i1; 字符串与其他数据类型之间的转换在Java中，所有的类都继承于java.lang.Object, 在Object类中定义了toString()方法，即所有的类都可转换为字符串。 字符串转其他类型字符串转换为数值型变量有两种对应关系：一种是其转换为对应的ASCLL码；两一种是转换关系，例如，”1”就是数值1，而不是ASCLL码，对于这种转换，可以使用Character的getNumericValue(char ch)方法。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
